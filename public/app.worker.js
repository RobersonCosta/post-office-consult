/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/babel-loader/lib/index.js!./node_modules/mapbox-gl/dist/mapbox-gl-csp-worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js!./node_modules/mapbox-gl/dist/mapbox-gl-csp-worker.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/mapbox-gl/dist/mapbox-gl-csp-worker.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var mapboxgl = function () {\n  \"use strict\";\n\n  var t = e;\n\n  function e(t, e, r, n) {\n    this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = r, this.p2y = n;\n  }\n\n  e.prototype.sampleCurveX = function (t) {\n    return ((this.ax * t + this.bx) * t + this.cx) * t;\n  }, e.prototype.sampleCurveY = function (t) {\n    return ((this.ay * t + this.by) * t + this.cy) * t;\n  }, e.prototype.sampleCurveDerivativeX = function (t) {\n    return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\n  }, e.prototype.solveCurveX = function (t, e) {\n    var r, n, i, s, o;\n\n    for (void 0 === e && (e = 1e-6), i = t, o = 0; o < 8; o++) {\n      if (s = this.sampleCurveX(i) - t, Math.abs(s) < e) return i;\n      var a = this.sampleCurveDerivativeX(i);\n      if (Math.abs(a) < 1e-6) break;\n      i -= s / a;\n    }\n\n    if ((i = t) < (r = 0)) return r;\n    if (i > (n = 1)) return n;\n\n    for (; r < n;) {\n      if (s = this.sampleCurveX(i), Math.abs(s - t) < e) return i;\n      t > s ? r = i : n = i, i = .5 * (n - r) + r;\n    }\n\n    return i;\n  }, e.prototype.solve = function (t, e) {\n    return this.sampleCurveY(this.solveCurveX(t, e));\n  };\n  var r = n;\n\n  function n(t, e) {\n    this.x = t, this.y = e;\n  }\n\n  n.prototype = {\n    clone: function () {\n      return new n(this.x, this.y);\n    },\n    add: function (t) {\n      return this.clone()._add(t);\n    },\n    sub: function (t) {\n      return this.clone()._sub(t);\n    },\n    multByPoint: function (t) {\n      return this.clone()._multByPoint(t);\n    },\n    divByPoint: function (t) {\n      return this.clone()._divByPoint(t);\n    },\n    mult: function (t) {\n      return this.clone()._mult(t);\n    },\n    div: function (t) {\n      return this.clone()._div(t);\n    },\n    rotate: function (t) {\n      return this.clone()._rotate(t);\n    },\n    rotateAround: function (t, e) {\n      return this.clone()._rotateAround(t, e);\n    },\n    matMult: function (t) {\n      return this.clone()._matMult(t);\n    },\n    unit: function () {\n      return this.clone()._unit();\n    },\n    perp: function () {\n      return this.clone()._perp();\n    },\n    round: function () {\n      return this.clone()._round();\n    },\n    mag: function () {\n      return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n    equals: function (t) {\n      return this.x === t.x && this.y === t.y;\n    },\n    dist: function (t) {\n      return Math.sqrt(this.distSqr(t));\n    },\n    distSqr: function (t) {\n      var e = t.x - this.x,\n          r = t.y - this.y;\n      return e * e + r * r;\n    },\n    angle: function () {\n      return Math.atan2(this.y, this.x);\n    },\n    angleTo: function (t) {\n      return Math.atan2(this.y - t.y, this.x - t.x);\n    },\n    angleWith: function (t) {\n      return this.angleWithSep(t.x, t.y);\n    },\n    angleWithSep: function (t, e) {\n      return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);\n    },\n    _matMult: function (t) {\n      var e = t[2] * this.x + t[3] * this.y;\n      return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;\n    },\n    _add: function (t) {\n      return this.x += t.x, this.y += t.y, this;\n    },\n    _sub: function (t) {\n      return this.x -= t.x, this.y -= t.y, this;\n    },\n    _mult: function (t) {\n      return this.x *= t, this.y *= t, this;\n    },\n    _div: function (t) {\n      return this.x /= t, this.y /= t, this;\n    },\n    _multByPoint: function (t) {\n      return this.x *= t.x, this.y *= t.y, this;\n    },\n    _divByPoint: function (t) {\n      return this.x /= t.x, this.y /= t.y, this;\n    },\n    _unit: function () {\n      return this._div(this.mag()), this;\n    },\n    _perp: function () {\n      var t = this.y;\n      return this.y = this.x, this.x = -t, this;\n    },\n    _rotate: function (t) {\n      var e = Math.cos(t),\n          r = Math.sin(t),\n          n = r * this.x + e * this.y;\n      return this.x = e * this.x - r * this.y, this.y = n, this;\n    },\n    _rotateAround: function (t, e) {\n      var r = Math.cos(t),\n          n = Math.sin(t),\n          i = e.y + n * (this.x - e.x) + r * (this.y - e.y);\n      return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;\n    },\n    _round: function () {\n      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n    }\n  }, n.convert = function (t) {\n    return t instanceof n ? t : Array.isArray(t) ? new n(t[0], t[1]) : t;\n  };\n  var i = \"undefined\" != typeof self ? self : {};\n  const s = Math.pow(2, 53) - 1,\n        o = Math.PI / 180;\n\n  function a(t) {\n    return t * o;\n  }\n\n  function l(t, e, r) {\n    return Math.min(r, Math.max(e, t));\n  }\n\n  function u(t) {\n    const e = [];\n\n    for (const r in t) e.push(t[r]);\n\n    return e;\n  }\n\n  function c(t, ...e) {\n    for (const r of e) for (const e in r) t[e] = r[e];\n\n    return t;\n  }\n\n  function h() {\n    return function t(e) {\n      return e ? (e ^ 16 * Math.random() >> e / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);\n    }();\n  }\n\n  function p(t) {\n    return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t);\n  }\n\n  function f(t, e) {\n    t.forEach(t => {\n      e[t] && (e[t] = e[t].bind(e));\n    });\n  }\n\n  function d(t, e) {\n    return -1 !== t.indexOf(e, t.length - e.length);\n  }\n\n  function y(t, e, r) {\n    const n = {};\n\n    for (const i in t) n[i] = e.call(r || this, t[i], i, t);\n\n    return n;\n  }\n\n  function m(t) {\n    return Array.isArray(t) ? t.map(m) : \"object\" == typeof t && t ? y(t, m) : t;\n  }\n\n  const g = {};\n\n  function x(t) {\n    g[t] || (\"undefined\" != typeof console && console.warn(t), g[t] = !0);\n  }\n\n  function v(t, e, r) {\n    return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x);\n  }\n\n  function b(t) {\n    let e = 0;\n\n    for (let r, n, i = 0, s = t.length, o = s - 1; i < s; o = i++) r = t[i], n = t[o], e += (n.x - r.x) * (r.y + n.y);\n\n    return e;\n  }\n\n  function w() {\n    return \"undefined\" != typeof WorkerGlobalScope && \"undefined\" != typeof self && self instanceof WorkerGlobalScope;\n  }\n\n  function _(t) {\n    const e = {};\n\n    if (t.replace(/(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g, (t, r, n, i) => {\n      const s = n || i;\n      return e[r] = !s || s.toLowerCase(), \"\";\n    }), e[\"max-age\"]) {\n      const t = parseInt(e[\"max-age\"], 10);\n      isNaN(t) ? delete e[\"max-age\"] : e[\"max-age\"] = t;\n    }\n\n    return e;\n  }\n\n  let k = null;\n\n  function S(t) {\n    if (null == k) {\n      const e = t.navigator ? t.navigator.userAgent : null;\n      k = !!t.safari || !(!e || !(/\\b(iPad|iPhone|iPod)\\b/.test(e) || e.match(\"Safari\") && !e.match(\"Chrome\")));\n    }\n\n    return k;\n  }\n\n  function A(t) {\n    try {\n      const e = i[t];\n      return e.setItem(\"_mapbox_test_\", 1), e.removeItem(\"_mapbox_test_\"), !0;\n    } catch (t) {\n      return !1;\n    }\n  }\n\n  var I = z;\n\n  function z(t, e, r) {\n    var n = this.cells = [];\n\n    if (t instanceof ArrayBuffer) {\n      this.arrayBuffer = t;\n      var i = new Int32Array(this.arrayBuffer);\n      t = i[0], this.d = (e = i[1]) + 2 * (r = i[2]);\n\n      for (var s = 0; s < this.d * this.d; s++) {\n        var o = i[3 + s],\n            a = i[3 + s + 1];\n        n.push(o === a ? null : i.subarray(o, a));\n      }\n\n      var l = i[3 + n.length + 1];\n      this.keys = i.subarray(i[3 + n.length], l), this.bboxes = i.subarray(l), this.insert = this._insertReadonly;\n    } else {\n      this.d = e + 2 * r;\n\n      for (var u = 0; u < this.d * this.d; u++) n.push([]);\n\n      this.keys = [], this.bboxes = [];\n    }\n\n    this.n = e, this.extent = t, this.padding = r, this.scale = e / t, this.uid = 0;\n    var c = r / e * t;\n    this.min = -c, this.max = t + c;\n  }\n\n  function M(t, e) {\n    return t(e = {\n      exports: {}\n    }, e.exports), e.exports;\n  }\n\n  z.prototype.insert = function (t, e, r, n, i) {\n    this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);\n  }, z.prototype._insertReadonly = function () {\n    throw \"Cannot insert into a GridIndex created from an ArrayBuffer.\";\n  }, z.prototype._insertCell = function (t, e, r, n, i, s) {\n    this.cells[i].push(s);\n  }, z.prototype.query = function (t, e, r, n, i) {\n    var s = this.min,\n        o = this.max;\n    if (t <= s && e <= s && o <= r && o <= n && !i) return Array.prototype.slice.call(this.keys);\n    var a = [];\n    return this._forEachCell(t, e, r, n, this._queryCell, a, {}, i), a;\n  }, z.prototype._queryCell = function (t, e, r, n, i, s, o, a) {\n    var l = this.cells[i];\n    if (null !== l) for (var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++) {\n      var p = l[h];\n\n      if (void 0 === o[p]) {\n        var f = 4 * p;\n        (a ? a(c[f + 0], c[f + 1], c[f + 2], c[f + 3]) : t <= c[f + 2] && e <= c[f + 3] && r >= c[f + 0] && n >= c[f + 1]) ? (o[p] = !0, s.push(u[p])) : o[p] = !1;\n      }\n    }\n  }, z.prototype._forEachCell = function (t, e, r, n, i, s, o, a) {\n    for (var l = this._convertToCellCoord(t), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++) for (var f = u; f <= h; f++) {\n      var d = this.d * f + p;\n      if ((!a || a(this._convertFromCellCoord(p), this._convertFromCellCoord(f), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t, e, r, n, d, s, o, a)) return;\n    }\n  }, z.prototype._convertFromCellCoord = function (t) {\n    return (t - this.padding) / this.scale;\n  }, z.prototype._convertToCellCoord = function (t) {\n    return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));\n  }, z.prototype.toArrayBuffer = function () {\n    if (this.arrayBuffer) return this.arrayBuffer;\n\n    for (var t = this.cells, e = 3 + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++) r += this.cells[n].length;\n\n    var i = new Int32Array(e + r + this.keys.length + this.bboxes.length);\n    i[0] = this.extent, i[1] = this.n, i[2] = this.padding;\n\n    for (var s = e, o = 0; o < t.length; o++) {\n      var a = t[o];\n      i[3 + o] = s, i.set(a, s), s += a.length;\n    }\n\n    return i[3 + t.length] = s, i.set(this.keys, s), i[3 + t.length + 1] = s += this.keys.length, i.set(this.bboxes, s), s += this.bboxes.length, i.buffer;\n  };\n  var B = M(function (t, e) {\n    var r = {\n      transparent: [0, 0, 0, 0],\n      aliceblue: [240, 248, 255, 1],\n      antiquewhite: [250, 235, 215, 1],\n      aqua: [0, 255, 255, 1],\n      aquamarine: [127, 255, 212, 1],\n      azure: [240, 255, 255, 1],\n      beige: [245, 245, 220, 1],\n      bisque: [255, 228, 196, 1],\n      black: [0, 0, 0, 1],\n      blanchedalmond: [255, 235, 205, 1],\n      blue: [0, 0, 255, 1],\n      blueviolet: [138, 43, 226, 1],\n      brown: [165, 42, 42, 1],\n      burlywood: [222, 184, 135, 1],\n      cadetblue: [95, 158, 160, 1],\n      chartreuse: [127, 255, 0, 1],\n      chocolate: [210, 105, 30, 1],\n      coral: [255, 127, 80, 1],\n      cornflowerblue: [100, 149, 237, 1],\n      cornsilk: [255, 248, 220, 1],\n      crimson: [220, 20, 60, 1],\n      cyan: [0, 255, 255, 1],\n      darkblue: [0, 0, 139, 1],\n      darkcyan: [0, 139, 139, 1],\n      darkgoldenrod: [184, 134, 11, 1],\n      darkgray: [169, 169, 169, 1],\n      darkgreen: [0, 100, 0, 1],\n      darkgrey: [169, 169, 169, 1],\n      darkkhaki: [189, 183, 107, 1],\n      darkmagenta: [139, 0, 139, 1],\n      darkolivegreen: [85, 107, 47, 1],\n      darkorange: [255, 140, 0, 1],\n      darkorchid: [153, 50, 204, 1],\n      darkred: [139, 0, 0, 1],\n      darksalmon: [233, 150, 122, 1],\n      darkseagreen: [143, 188, 143, 1],\n      darkslateblue: [72, 61, 139, 1],\n      darkslategray: [47, 79, 79, 1],\n      darkslategrey: [47, 79, 79, 1],\n      darkturquoise: [0, 206, 209, 1],\n      darkviolet: [148, 0, 211, 1],\n      deeppink: [255, 20, 147, 1],\n      deepskyblue: [0, 191, 255, 1],\n      dimgray: [105, 105, 105, 1],\n      dimgrey: [105, 105, 105, 1],\n      dodgerblue: [30, 144, 255, 1],\n      firebrick: [178, 34, 34, 1],\n      floralwhite: [255, 250, 240, 1],\n      forestgreen: [34, 139, 34, 1],\n      fuchsia: [255, 0, 255, 1],\n      gainsboro: [220, 220, 220, 1],\n      ghostwhite: [248, 248, 255, 1],\n      gold: [255, 215, 0, 1],\n      goldenrod: [218, 165, 32, 1],\n      gray: [128, 128, 128, 1],\n      green: [0, 128, 0, 1],\n      greenyellow: [173, 255, 47, 1],\n      grey: [128, 128, 128, 1],\n      honeydew: [240, 255, 240, 1],\n      hotpink: [255, 105, 180, 1],\n      indianred: [205, 92, 92, 1],\n      indigo: [75, 0, 130, 1],\n      ivory: [255, 255, 240, 1],\n      khaki: [240, 230, 140, 1],\n      lavender: [230, 230, 250, 1],\n      lavenderblush: [255, 240, 245, 1],\n      lawngreen: [124, 252, 0, 1],\n      lemonchiffon: [255, 250, 205, 1],\n      lightblue: [173, 216, 230, 1],\n      lightcoral: [240, 128, 128, 1],\n      lightcyan: [224, 255, 255, 1],\n      lightgoldenrodyellow: [250, 250, 210, 1],\n      lightgray: [211, 211, 211, 1],\n      lightgreen: [144, 238, 144, 1],\n      lightgrey: [211, 211, 211, 1],\n      lightpink: [255, 182, 193, 1],\n      lightsalmon: [255, 160, 122, 1],\n      lightseagreen: [32, 178, 170, 1],\n      lightskyblue: [135, 206, 250, 1],\n      lightslategray: [119, 136, 153, 1],\n      lightslategrey: [119, 136, 153, 1],\n      lightsteelblue: [176, 196, 222, 1],\n      lightyellow: [255, 255, 224, 1],\n      lime: [0, 255, 0, 1],\n      limegreen: [50, 205, 50, 1],\n      linen: [250, 240, 230, 1],\n      magenta: [255, 0, 255, 1],\n      maroon: [128, 0, 0, 1],\n      mediumaquamarine: [102, 205, 170, 1],\n      mediumblue: [0, 0, 205, 1],\n      mediumorchid: [186, 85, 211, 1],\n      mediumpurple: [147, 112, 219, 1],\n      mediumseagreen: [60, 179, 113, 1],\n      mediumslateblue: [123, 104, 238, 1],\n      mediumspringgreen: [0, 250, 154, 1],\n      mediumturquoise: [72, 209, 204, 1],\n      mediumvioletred: [199, 21, 133, 1],\n      midnightblue: [25, 25, 112, 1],\n      mintcream: [245, 255, 250, 1],\n      mistyrose: [255, 228, 225, 1],\n      moccasin: [255, 228, 181, 1],\n      navajowhite: [255, 222, 173, 1],\n      navy: [0, 0, 128, 1],\n      oldlace: [253, 245, 230, 1],\n      olive: [128, 128, 0, 1],\n      olivedrab: [107, 142, 35, 1],\n      orange: [255, 165, 0, 1],\n      orangered: [255, 69, 0, 1],\n      orchid: [218, 112, 214, 1],\n      palegoldenrod: [238, 232, 170, 1],\n      palegreen: [152, 251, 152, 1],\n      paleturquoise: [175, 238, 238, 1],\n      palevioletred: [219, 112, 147, 1],\n      papayawhip: [255, 239, 213, 1],\n      peachpuff: [255, 218, 185, 1],\n      peru: [205, 133, 63, 1],\n      pink: [255, 192, 203, 1],\n      plum: [221, 160, 221, 1],\n      powderblue: [176, 224, 230, 1],\n      purple: [128, 0, 128, 1],\n      rebeccapurple: [102, 51, 153, 1],\n      red: [255, 0, 0, 1],\n      rosybrown: [188, 143, 143, 1],\n      royalblue: [65, 105, 225, 1],\n      saddlebrown: [139, 69, 19, 1],\n      salmon: [250, 128, 114, 1],\n      sandybrown: [244, 164, 96, 1],\n      seagreen: [46, 139, 87, 1],\n      seashell: [255, 245, 238, 1],\n      sienna: [160, 82, 45, 1],\n      silver: [192, 192, 192, 1],\n      skyblue: [135, 206, 235, 1],\n      slateblue: [106, 90, 205, 1],\n      slategray: [112, 128, 144, 1],\n      slategrey: [112, 128, 144, 1],\n      snow: [255, 250, 250, 1],\n      springgreen: [0, 255, 127, 1],\n      steelblue: [70, 130, 180, 1],\n      tan: [210, 180, 140, 1],\n      teal: [0, 128, 128, 1],\n      thistle: [216, 191, 216, 1],\n      tomato: [255, 99, 71, 1],\n      turquoise: [64, 224, 208, 1],\n      violet: [238, 130, 238, 1],\n      wheat: [245, 222, 179, 1],\n      white: [255, 255, 255, 1],\n      whitesmoke: [245, 245, 245, 1],\n      yellow: [255, 255, 0, 1],\n      yellowgreen: [154, 205, 50, 1]\n    };\n\n    function n(t) {\n      return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;\n    }\n\n    function i(t) {\n      return n(\"%\" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t));\n    }\n\n    function s(t) {\n      return (e = \"%\" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;\n      var e;\n    }\n\n    function o(t, e, r) {\n      return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;\n    }\n\n    try {\n      e.parseCSSColor = function (t) {\n        var e,\n            a = t.replace(/ /g, \"\").toLowerCase();\n        if (a in r) return r[a].slice();\n        if (\"#\" === a[0]) return 4 === a.length ? (e = parseInt(a.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === a.length && (e = parseInt(a.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;\n        var l = a.indexOf(\"(\"),\n            u = a.indexOf(\")\");\n\n        if (-1 !== l && u + 1 === a.length) {\n          var c = a.substr(0, l),\n              h = a.substr(l + 1, u - (l + 1)).split(\",\"),\n              p = 1;\n\n          switch (c) {\n            case \"rgba\":\n              if (4 !== h.length) return null;\n              p = s(h.pop());\n\n            case \"rgb\":\n              return 3 !== h.length ? null : [i(h[0]), i(h[1]), i(h[2]), p];\n\n            case \"hsla\":\n              if (4 !== h.length) return null;\n              p = s(h.pop());\n\n            case \"hsl\":\n              if (3 !== h.length) return null;\n              var f = (parseFloat(h[0]) % 360 + 360) % 360 / 360,\n                  d = s(h[1]),\n                  y = s(h[2]),\n                  m = y <= .5 ? y * (d + 1) : y + d - y * d,\n                  g = 2 * y - m;\n              return [n(255 * o(g, m, f + 1 / 3)), n(255 * o(g, m, f)), n(255 * o(g, m, f - 1 / 3)), p];\n\n            default:\n              return null;\n          }\n        }\n\n        return null;\n      };\n    } catch (t) {}\n  }).parseCSSColor;\n\n  class P {\n    constructor(t, e, r, n = 1) {\n      this.r = t, this.g = e, this.b = r, this.a = n;\n    }\n\n    static parse(t) {\n      if (!t) return;\n      if (t instanceof P) return t;\n      if (\"string\" != typeof t) return;\n      const e = B(t);\n      return e ? new P(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]) : void 0;\n    }\n\n    toString() {\n      const [t, e, r, n] = this.toArray();\n      return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(r)},${n})`;\n    }\n\n    toArray() {\n      const {\n        r: t,\n        g: e,\n        b: r,\n        a: n\n      } = this;\n      return 0 === n ? [0, 0, 0, 0] : [255 * t / n, 255 * e / n, 255 * r / n, n];\n    }\n\n  }\n\n  function C(t, ...e) {\n    for (const r of e) for (const e in r) t[e] = r[e];\n\n    return t;\n  }\n\n  P.black = new P(0, 0, 0, 1), P.white = new P(1, 1, 1, 1), P.transparent = new P(0, 0, 0, 0), P.red = new P(1, 0, 0, 1), P.blue = new P(0, 0, 1, 1);\n\n  class V extends Error {\n    constructor(t, e) {\n      super(e), this.message = e, this.key = t;\n    }\n\n  }\n\n  class T {\n    constructor(t, e = []) {\n      this.parent = t, this.bindings = {};\n\n      for (const [t, r] of e) this.bindings[t] = r;\n    }\n\n    concat(t) {\n      return new T(this, t);\n    }\n\n    get(t) {\n      if (this.bindings[t]) return this.bindings[t];\n      if (this.parent) return this.parent.get(t);\n      throw new Error(`${t} not found in scope.`);\n    }\n\n    has(t) {\n      return !!this.bindings[t] || !!this.parent && this.parent.has(t);\n    }\n\n  }\n\n  const E = {\n    kind: \"null\"\n  },\n        D = {\n    kind: \"number\"\n  },\n        F = {\n    kind: \"string\"\n  },\n        L = {\n    kind: \"boolean\"\n  },\n        O = {\n    kind: \"color\"\n  },\n        $ = {\n    kind: \"object\"\n  },\n        R = {\n    kind: \"value\"\n  },\n        q = {\n    kind: \"collator\"\n  },\n        U = {\n    kind: \"formatted\"\n  },\n        N = {\n    kind: \"resolvedImage\"\n  };\n\n  function j(t, e) {\n    return {\n      kind: \"array\",\n      itemType: t,\n      N: e\n    };\n  }\n\n  function Z(t) {\n    if (\"array\" === t.kind) {\n      const e = Z(t.itemType);\n      return \"number\" == typeof t.N ? `array<${e}, ${t.N}>` : \"value\" === t.itemType.kind ? \"array\" : `array<${e}>`;\n    }\n\n    return t.kind;\n  }\n\n  const G = [E, D, F, L, O, U, $, j(R), N];\n\n  function X(t, e) {\n    if (\"error\" === e.kind) return null;\n\n    if (\"array\" === t.kind) {\n      if (\"array\" === e.kind && (0 === e.N && \"value\" === e.itemType.kind || !X(t.itemType, e.itemType)) && (\"number\" != typeof t.N || t.N === e.N)) return null;\n    } else {\n      if (t.kind === e.kind) return null;\n      if (\"value\" === t.kind) for (const t of G) if (!X(t, e)) return null;\n    }\n\n    return `Expected ${Z(t)} but found ${Z(e)} instead.`;\n  }\n\n  function J(t, e) {\n    return e.some(e => e.kind === t.kind);\n  }\n\n  function Y(t, e) {\n    return e.some(e => \"null\" === e ? null === t : \"array\" === e ? Array.isArray(t) : \"object\" === e ? t && !Array.isArray(t) && \"object\" == typeof t : e === typeof t);\n  }\n\n  class K {\n    constructor(t, e, r) {\n      this.sensitivity = t ? e ? \"variant\" : \"case\" : e ? \"accent\" : \"base\", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n        sensitivity: this.sensitivity,\n        usage: \"search\"\n      });\n    }\n\n    compare(t, e) {\n      return this.collator.compare(t, e);\n    }\n\n    resolvedLocale() {\n      return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n    }\n\n  }\n\n  class H {\n    constructor(t, e, r, n, i) {\n      this.text = t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;\n    }\n\n  }\n\n  class W {\n    constructor(t) {\n      this.sections = t;\n    }\n\n    static fromString(t) {\n      return new W([new H(t, null, null, null, null)]);\n    }\n\n    isEmpty() {\n      return 0 === this.sections.length || !this.sections.some(t => 0 !== t.text.length || t.image && 0 !== t.image.name.length);\n    }\n\n    static factory(t) {\n      return t instanceof W ? t : W.fromString(t);\n    }\n\n    toString() {\n      return 0 === this.sections.length ? \"\" : this.sections.map(t => t.text).join(\"\");\n    }\n\n    serialize() {\n      const t = [\"format\"];\n\n      for (const e of this.sections) {\n        if (e.image) {\n          t.push([\"image\", e.image.name]);\n          continue;\n        }\n\n        t.push(e.text);\n        const r = {};\n        e.fontStack && (r[\"text-font\"] = [\"literal\", e.fontStack.split(\",\")]), e.scale && (r[\"font-scale\"] = e.scale), e.textColor && (r[\"text-color\"] = [\"rgba\"].concat(e.textColor.toArray())), t.push(r);\n      }\n\n      return t;\n    }\n\n  }\n\n  class Q {\n    constructor(t) {\n      this.name = t.name, this.available = t.available;\n    }\n\n    toString() {\n      return this.name;\n    }\n\n    static fromString(t) {\n      return t ? new Q({\n        name: t,\n        available: !1\n      }) : null;\n    }\n\n    serialize() {\n      return [\"image\", this.name];\n    }\n\n  }\n\n  function tt(t, e, r, n) {\n    return \"number\" == typeof t && t >= 0 && t <= 255 && \"number\" == typeof e && e >= 0 && e <= 255 && \"number\" == typeof r && r >= 0 && r <= 255 ? void 0 === n || \"number\" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t, e, r, n].join(\", \")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(\"number\" == typeof n ? [t, e, r, n] : [t, e, r]).join(\", \")}]: 'r', 'g', and 'b' must be between 0 and 255.`;\n  }\n\n  function et(t) {\n    if (null === t) return !0;\n    if (\"string\" == typeof t) return !0;\n    if (\"boolean\" == typeof t) return !0;\n    if (\"number\" == typeof t) return !0;\n    if (t instanceof P) return !0;\n    if (t instanceof K) return !0;\n    if (t instanceof W) return !0;\n    if (t instanceof Q) return !0;\n\n    if (Array.isArray(t)) {\n      for (const e of t) if (!et(e)) return !1;\n\n      return !0;\n    }\n\n    if (\"object\" == typeof t) {\n      for (const e in t) if (!et(t[e])) return !1;\n\n      return !0;\n    }\n\n    return !1;\n  }\n\n  function rt(t) {\n    if (null === t) return E;\n    if (\"string\" == typeof t) return F;\n    if (\"boolean\" == typeof t) return L;\n    if (\"number\" == typeof t) return D;\n    if (t instanceof P) return O;\n    if (t instanceof K) return q;\n    if (t instanceof W) return U;\n    if (t instanceof Q) return N;\n\n    if (Array.isArray(t)) {\n      const e = t.length;\n      let r;\n\n      for (const e of t) {\n        const t = rt(e);\n\n        if (r) {\n          if (r === t) continue;\n          r = R;\n          break;\n        }\n\n        r = t;\n      }\n\n      return j(r || R, e);\n    }\n\n    return $;\n  }\n\n  function nt(t) {\n    const e = typeof t;\n    return null === t ? \"\" : \"string\" === e || \"number\" === e || \"boolean\" === e ? String(t) : t instanceof P || t instanceof W || t instanceof Q ? t.toString() : JSON.stringify(t);\n  }\n\n  class it {\n    constructor(t, e) {\n      this.type = t, this.value = e;\n    }\n\n    static parse(t, e) {\n      if (2 !== t.length) return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);\n      if (!et(t[1])) return e.error(\"invalid value\");\n      const r = t[1];\n      let n = rt(r);\n      const i = e.expectedType;\n      return \"array\" !== n.kind || 0 !== n.N || !i || \"array\" !== i.kind || \"number\" == typeof i.N && 0 !== i.N || (n = i), new it(n, r);\n    }\n\n    evaluate() {\n      return this.value;\n    }\n\n    eachChild() {}\n\n    outputDefined() {\n      return !0;\n    }\n\n    serialize() {\n      return \"array\" === this.type.kind || \"object\" === this.type.kind ? [\"literal\", this.value] : this.value instanceof P ? [\"rgba\"].concat(this.value.toArray()) : this.value instanceof W ? this.value.serialize() : this.value;\n    }\n\n  }\n\n  class st {\n    constructor(t) {\n      this.name = \"ExpressionEvaluationError\", this.message = t;\n    }\n\n    toJSON() {\n      return this.message;\n    }\n\n  }\n\n  const ot = {\n    string: F,\n    number: D,\n    boolean: L,\n    object: $\n  };\n\n  class at {\n    constructor(t, e) {\n      this.type = t, this.args = e;\n    }\n\n    static parse(t, e) {\n      if (t.length < 2) return e.error(\"Expected at least one argument.\");\n      let r,\n          n = 1;\n      const i = t[0];\n\n      if (\"array\" === i) {\n        let i, s;\n\n        if (t.length > 2) {\n          const r = t[1];\n          if (\"string\" != typeof r || !(r in ot) || \"object\" === r) return e.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n          i = ot[r], n++;\n        } else i = R;\n\n        if (t.length > 3) {\n          if (null !== t[2] && (\"number\" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to \"array\" must be a positive integer literal', 2);\n          s = t[2], n++;\n        }\n\n        r = j(i, s);\n      } else r = ot[i];\n\n      const s = [];\n\n      for (; n < t.length; n++) {\n        const r = e.parse(t[n], n, R);\n        if (!r) return null;\n        s.push(r);\n      }\n\n      return new at(r, s);\n    }\n\n    evaluate(t) {\n      for (let e = 0; e < this.args.length; e++) {\n        const r = this.args[e].evaluate(t);\n        if (!X(this.type, rt(r))) return r;\n        if (e === this.args.length - 1) throw new st(`Expected value to be of type ${Z(this.type)}, but found ${Z(rt(r))} instead.`);\n      }\n\n      return null;\n    }\n\n    eachChild(t) {\n      this.args.forEach(t);\n    }\n\n    outputDefined() {\n      return this.args.every(t => t.outputDefined());\n    }\n\n    serialize() {\n      const t = this.type,\n            e = [t.kind];\n\n      if (\"array\" === t.kind) {\n        const r = t.itemType;\n\n        if (\"string\" === r.kind || \"number\" === r.kind || \"boolean\" === r.kind) {\n          e.push(r.kind);\n          const n = t.N;\n          (\"number\" == typeof n || this.args.length > 1) && e.push(n);\n        }\n      }\n\n      return e.concat(this.args.map(t => t.serialize()));\n    }\n\n  }\n\n  class lt {\n    constructor(t) {\n      this.type = U, this.sections = t;\n    }\n\n    static parse(t, e) {\n      if (t.length < 2) return e.error(\"Expected at least one argument.\");\n      const r = t[1];\n      if (!Array.isArray(r) && \"object\" == typeof r) return e.error(\"First argument must be an image or text section.\");\n      const n = [];\n      let i = !1;\n\n      for (let r = 1; r <= t.length - 1; ++r) {\n        const s = t[r];\n\n        if (i && \"object\" == typeof s && !Array.isArray(s)) {\n          i = !1;\n          let t = null;\n          if (s[\"font-scale\"] && (t = e.parse(s[\"font-scale\"], 1, D), !t)) return null;\n          let r = null;\n          if (s[\"text-font\"] && (r = e.parse(s[\"text-font\"], 1, j(F)), !r)) return null;\n          let o = null;\n          if (s[\"text-color\"] && (o = e.parse(s[\"text-color\"], 1, O), !o)) return null;\n          const a = n[n.length - 1];\n          a.scale = t, a.font = r, a.textColor = o;\n        } else {\n          const s = e.parse(t[r], 1, R);\n          if (!s) return null;\n          const o = s.type.kind;\n          if (\"string\" !== o && \"value\" !== o && \"null\" !== o && \"resolvedImage\" !== o) return e.error(\"Formatted text type must be 'string', 'value', 'image' or 'null'.\");\n          i = !0, n.push({\n            content: s,\n            scale: null,\n            font: null,\n            textColor: null\n          });\n        }\n      }\n\n      return new lt(n);\n    }\n\n    evaluate(t) {\n      return new W(this.sections.map(e => {\n        const r = e.content.evaluate(t);\n        return rt(r) === N ? new H(\"\", r, null, null, null) : new H(nt(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(\",\") : null, e.textColor ? e.textColor.evaluate(t) : null);\n      }));\n    }\n\n    eachChild(t) {\n      for (const e of this.sections) t(e.content), e.scale && t(e.scale), e.font && t(e.font), e.textColor && t(e.textColor);\n    }\n\n    outputDefined() {\n      return !1;\n    }\n\n    serialize() {\n      const t = [\"format\"];\n\n      for (const e of this.sections) {\n        t.push(e.content.serialize());\n        const r = {};\n        e.scale && (r[\"font-scale\"] = e.scale.serialize()), e.font && (r[\"text-font\"] = e.font.serialize()), e.textColor && (r[\"text-color\"] = e.textColor.serialize()), t.push(r);\n      }\n\n      return t;\n    }\n\n  }\n\n  class ut {\n    constructor(t) {\n      this.type = N, this.input = t;\n    }\n\n    static parse(t, e) {\n      if (2 !== t.length) return e.error(\"Expected two arguments.\");\n      const r = e.parse(t[1], 1, F);\n      return r ? new ut(r) : e.error(\"No image name provided.\");\n    }\n\n    evaluate(t) {\n      const e = this.input.evaluate(t),\n            r = Q.fromString(e);\n      return r && t.availableImages && (r.available = t.availableImages.indexOf(e) > -1), r;\n    }\n\n    eachChild(t) {\n      t(this.input);\n    }\n\n    outputDefined() {\n      return !1;\n    }\n\n    serialize() {\n      return [\"image\", this.input.serialize()];\n    }\n\n  }\n\n  const ct = {\n    \"to-boolean\": L,\n    \"to-color\": O,\n    \"to-number\": D,\n    \"to-string\": F\n  };\n\n  class ht {\n    constructor(t, e) {\n      this.type = t, this.args = e;\n    }\n\n    static parse(t, e) {\n      if (t.length < 2) return e.error(\"Expected at least one argument.\");\n      const r = t[0];\n      if ((\"to-boolean\" === r || \"to-string\" === r) && 2 !== t.length) return e.error(\"Expected one argument.\");\n      const n = ct[r],\n            i = [];\n\n      for (let r = 1; r < t.length; r++) {\n        const n = e.parse(t[r], r, R);\n        if (!n) return null;\n        i.push(n);\n      }\n\n      return new ht(n, i);\n    }\n\n    evaluate(t) {\n      if (\"boolean\" === this.type.kind) return Boolean(this.args[0].evaluate(t));\n\n      if (\"color\" === this.type.kind) {\n        let e, r;\n\n        for (const n of this.args) {\n          if (e = n.evaluate(t), r = null, e instanceof P) return e;\n\n          if (\"string\" == typeof e) {\n            const r = t.parseColor(e);\n            if (r) return r;\n          } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : tt(e[0], e[1], e[2], e[3]), !r)) return new P(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);\n        }\n\n        throw new st(r || `Could not parse color from value '${\"string\" == typeof e ? e : String(JSON.stringify(e))}'`);\n      }\n\n      if (\"number\" === this.type.kind) {\n        let e = null;\n\n        for (const r of this.args) {\n          if (e = r.evaluate(t), null === e) return 0;\n          const n = Number(e);\n          if (!isNaN(n)) return n;\n        }\n\n        throw new st(`Could not convert ${JSON.stringify(e)} to number.`);\n      }\n\n      return \"formatted\" === this.type.kind ? W.fromString(nt(this.args[0].evaluate(t))) : \"resolvedImage\" === this.type.kind ? Q.fromString(nt(this.args[0].evaluate(t))) : nt(this.args[0].evaluate(t));\n    }\n\n    eachChild(t) {\n      this.args.forEach(t);\n    }\n\n    outputDefined() {\n      return this.args.every(t => t.outputDefined());\n    }\n\n    serialize() {\n      if (\"formatted\" === this.type.kind) return new lt([{\n        content: this.args[0],\n        scale: null,\n        font: null,\n        textColor: null\n      }]).serialize();\n      if (\"resolvedImage\" === this.type.kind) return new ut(this.args[0]).serialize();\n      const t = [`to-${this.type.kind}`];\n      return this.eachChild(e => {\n        t.push(e.serialize());\n      }), t;\n    }\n\n  }\n\n  const pt = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"];\n\n  class ft {\n    constructor() {\n      this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;\n    }\n\n    id() {\n      return this.feature && \"id\" in this.feature ? this.feature.id : null;\n    }\n\n    geometryType() {\n      return this.feature ? \"number\" == typeof this.feature.type ? pt[this.feature.type] : this.feature.type : null;\n    }\n\n    geometry() {\n      return this.feature && \"geometry\" in this.feature ? this.feature.geometry : null;\n    }\n\n    canonicalID() {\n      return this.canonical;\n    }\n\n    properties() {\n      return this.feature && this.feature.properties || {};\n    }\n\n    parseColor(t) {\n      let e = this._parseColorCache[t];\n      return e || (e = this._parseColorCache[t] = P.parse(t)), e;\n    }\n\n  }\n\n  class dt {\n    constructor(t, e, r, n) {\n      this.name = t, this.type = e, this._evaluate = r, this.args = n;\n    }\n\n    evaluate(t) {\n      return this._evaluate(t, this.args);\n    }\n\n    eachChild(t) {\n      this.args.forEach(t);\n    }\n\n    outputDefined() {\n      return !1;\n    }\n\n    serialize() {\n      return [this.name].concat(this.args.map(t => t.serialize()));\n    }\n\n    static parse(t, e) {\n      const r = t[0],\n            n = dt.definitions[r];\n      if (!n) return e.error(`Unknown expression \"${r}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n      const i = Array.isArray(n) ? n[0] : n.type,\n            s = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads,\n            o = s.filter(([e]) => !Array.isArray(e) || e.length === t.length - 1);\n      let a = null;\n\n      for (const [n, s] of o) {\n        a = new Ft(e.registry, e.path, null, e.scope);\n        const o = [];\n        let l = !1;\n\n        for (let e = 1; e < t.length; e++) {\n          const r = t[e],\n                i = Array.isArray(n) ? n[e - 1] : n.type,\n                s = a.parse(r, 1 + o.length, i);\n\n          if (!s) {\n            l = !0;\n            break;\n          }\n\n          o.push(s);\n        }\n\n        if (!l) if (Array.isArray(n) && n.length !== o.length) a.error(`Expected ${n.length} arguments, but found ${o.length} instead.`);else {\n          for (let t = 0; t < o.length; t++) {\n            const e = Array.isArray(n) ? n[t] : n.type,\n                  r = o[t];\n            a.concat(t + 1).checkSubtype(e, r.type);\n          }\n\n          if (0 === a.errors.length) return new dt(r, i, s, o);\n        }\n      }\n\n      if (1 === o.length) e.errors.push(...a.errors);else {\n        const r = (o.length ? o : s).map(([t]) => {\n          return e = t, Array.isArray(e) ? `(${e.map(Z).join(\", \")})` : `(${Z(e.type)}...)`;\n          var e;\n        }).join(\" | \"),\n              n = [];\n\n        for (let r = 1; r < t.length; r++) {\n          const i = e.parse(t[r], 1 + n.length);\n          if (!i) return null;\n          n.push(Z(i.type));\n        }\n\n        e.error(`Expected arguments of type ${r}, but found (${n.join(\", \")}) instead.`);\n      }\n      return null;\n    }\n\n    static register(t, e) {\n      dt.definitions = e;\n\n      for (const r in e) t[r] = dt;\n    }\n\n  }\n\n  class yt {\n    constructor(t, e, r) {\n      this.type = q, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;\n    }\n\n    static parse(t, e) {\n      if (2 !== t.length) return e.error(\"Expected one argument.\");\n      const r = t[1];\n      if (\"object\" != typeof r || Array.isArray(r)) return e.error(\"Collator options argument must be an object.\");\n      const n = e.parse(void 0 !== r[\"case-sensitive\"] && r[\"case-sensitive\"], 1, L);\n      if (!n) return null;\n      const i = e.parse(void 0 !== r[\"diacritic-sensitive\"] && r[\"diacritic-sensitive\"], 1, L);\n      if (!i) return null;\n      let s = null;\n      return r.locale && (s = e.parse(r.locale, 1, F), !s) ? null : new yt(n, i, s);\n    }\n\n    evaluate(t) {\n      return new K(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);\n    }\n\n    eachChild(t) {\n      t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);\n    }\n\n    outputDefined() {\n      return !1;\n    }\n\n    serialize() {\n      const t = {};\n      return t[\"case-sensitive\"] = this.caseSensitive.serialize(), t[\"diacritic-sensitive\"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), [\"collator\", t];\n    }\n\n  }\n\n  function mt(t, e) {\n    t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);\n  }\n\n  function gt(t, e) {\n    return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);\n  }\n\n  function xt(t, e) {\n    const r = (180 + t[0]) / 360,\n          n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360,\n          i = Math.pow(2, e.z);\n    return [Math.round(r * i * 8192), Math.round(n * i * 8192)];\n  }\n\n  function vt(t, e, r) {\n    const n = t[0] - e[0],\n          i = t[1] - e[1],\n          s = t[0] - r[0],\n          o = t[1] - r[1];\n    return n * o - s * i == 0 && n * s <= 0 && i * o <= 0;\n  }\n\n  function bt(t, e) {\n    let r = !1;\n\n    for (let o = 0, a = e.length; o < a; o++) {\n      const a = e[o];\n\n      for (let e = 0, o = a.length; e < o - 1; e++) {\n        if (vt(t, a[e], a[e + 1])) return !1;\n        (i = a[e])[1] > (n = t)[1] != (s = a[e + 1])[1] > n[1] && n[0] < (s[0] - i[0]) * (n[1] - i[1]) / (s[1] - i[1]) + i[0] && (r = !r);\n      }\n    }\n\n    var n, i, s;\n    return r;\n  }\n\n  function wt(t, e) {\n    for (let r = 0; r < e.length; r++) if (bt(t, e[r])) return !0;\n\n    return !1;\n  }\n\n  function _t(t, e, r, n) {\n    const i = n[0] - r[0],\n          s = n[1] - r[1],\n          o = (t[0] - r[0]) * s - i * (t[1] - r[1]),\n          a = (e[0] - r[0]) * s - i * (e[1] - r[1]);\n    return o > 0 && a < 0 || o < 0 && a > 0;\n  }\n\n  function kt(t, e, r) {\n    for (const u of r) for (let r = 0; r < u.length - 1; ++r) if (0 != (a = [(o = u[r + 1])[0] - (s = u[r])[0], o[1] - s[1]])[0] * (l = [(i = e)[0] - (n = t)[0], i[1] - n[1]])[1] - a[1] * l[0] && _t(n, i, s, o) && _t(s, o, n, i)) return !0;\n\n    var n, i, s, o, a, l;\n    return !1;\n  }\n\n  function St(t, e) {\n    for (let r = 0; r < t.length; ++r) if (!bt(t[r], e)) return !1;\n\n    for (let r = 0; r < t.length - 1; ++r) if (kt(t[r], t[r + 1], e)) return !1;\n\n    return !0;\n  }\n\n  function At(t, e) {\n    for (let r = 0; r < e.length; r++) if (St(t, e[r])) return !0;\n\n    return !1;\n  }\n\n  function It(t, e, r) {\n    const n = [];\n\n    for (let i = 0; i < t.length; i++) {\n      const s = [];\n\n      for (let n = 0; n < t[i].length; n++) {\n        const o = xt(t[i][n], r);\n        mt(e, o), s.push(o);\n      }\n\n      n.push(s);\n    }\n\n    return n;\n  }\n\n  function zt(t, e, r) {\n    const n = [];\n\n    for (let i = 0; i < t.length; i++) {\n      const s = It(t[i], e, r);\n      n.push(s);\n    }\n\n    return n;\n  }\n\n  function Mt(t, e, r, n) {\n    if (t[0] < r[0] || t[0] > r[2]) {\n      const e = .5 * n;\n      let i = t[0] - r[0] > e ? -n : r[0] - t[0] > e ? n : 0;\n      0 === i && (i = t[0] - r[2] > e ? -n : r[2] - t[0] > e ? n : 0), t[0] += i;\n    }\n\n    mt(e, t);\n  }\n\n  function Bt(t, e, r, n) {\n    const i = 8192 * Math.pow(2, n.z),\n          s = [8192 * n.x, 8192 * n.y],\n          o = [];\n\n    for (const n of t) for (const t of n) {\n      const n = [t.x + s[0], t.y + s[1]];\n      Mt(n, e, r, i), o.push(n);\n    }\n\n    return o;\n  }\n\n  function Pt(t, e, r, n) {\n    const i = 8192 * Math.pow(2, n.z),\n          s = [8192 * n.x, 8192 * n.y],\n          o = [];\n\n    for (const r of t) {\n      const t = [];\n\n      for (const n of r) {\n        const r = [n.x + s[0], n.y + s[1]];\n        mt(e, r), t.push(r);\n      }\n\n      o.push(t);\n    }\n\n    if (e[2] - e[0] <= i / 2) {\n      (a = e)[0] = a[1] = 1 / 0, a[2] = a[3] = -1 / 0;\n\n      for (const t of o) for (const n of t) Mt(n, e, r, i);\n    }\n\n    var a;\n    return o;\n  }\n\n  class Ct {\n    constructor(t, e) {\n      this.type = L, this.geojson = t, this.geometries = e;\n    }\n\n    static parse(t, e) {\n      if (2 !== t.length) return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);\n\n      if (et(t[1])) {\n        const e = t[1];\n        if (\"FeatureCollection\" === e.type) for (let t = 0; t < e.features.length; ++t) {\n          const r = e.features[t].geometry.type;\n          if (\"Polygon\" === r || \"MultiPolygon\" === r) return new Ct(e, e.features[t].geometry);\n        } else if (\"Feature\" === e.type) {\n          const t = e.geometry.type;\n          if (\"Polygon\" === t || \"MultiPolygon\" === t) return new Ct(e, e.geometry);\n        } else if (\"Polygon\" === e.type || \"MultiPolygon\" === e.type) return new Ct(e, e);\n      }\n\n      return e.error(\"'within' expression requires valid geojson object that contains polygon geometry type.\");\n    }\n\n    evaluate(t) {\n      if (null != t.geometry() && null != t.canonicalID()) {\n        if (\"Point\" === t.geometryType()) return function (t, e) {\n          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n                n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n                i = t.canonicalID();\n\n          if (\"Polygon\" === e.type) {\n            const s = It(e.coordinates, n, i),\n                  o = Bt(t.geometry(), r, n, i);\n            if (!gt(r, n)) return !1;\n\n            for (const t of o) if (!bt(t, s)) return !1;\n          }\n\n          if (\"MultiPolygon\" === e.type) {\n            const s = zt(e.coordinates, n, i),\n                  o = Bt(t.geometry(), r, n, i);\n            if (!gt(r, n)) return !1;\n\n            for (const t of o) if (!wt(t, s)) return !1;\n          }\n\n          return !0;\n        }(t, this.geometries);\n        if (\"LineString\" === t.geometryType()) return function (t, e) {\n          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n                n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n                i = t.canonicalID();\n\n          if (\"Polygon\" === e.type) {\n            const s = It(e.coordinates, n, i),\n                  o = Pt(t.geometry(), r, n, i);\n            if (!gt(r, n)) return !1;\n\n            for (const t of o) if (!St(t, s)) return !1;\n          }\n\n          if (\"MultiPolygon\" === e.type) {\n            const s = zt(e.coordinates, n, i),\n                  o = Pt(t.geometry(), r, n, i);\n            if (!gt(r, n)) return !1;\n\n            for (const t of o) if (!At(t, s)) return !1;\n          }\n\n          return !0;\n        }(t, this.geometries);\n      }\n\n      return !1;\n    }\n\n    eachChild() {}\n\n    outputDefined() {\n      return !0;\n    }\n\n    serialize() {\n      return [\"within\", this.geojson];\n    }\n\n  }\n\n  function Vt(t) {\n    if (t instanceof dt) {\n      if (\"get\" === t.name && 1 === t.args.length) return !1;\n      if (\"feature-state\" === t.name) return !1;\n      if (\"has\" === t.name && 1 === t.args.length) return !1;\n      if (\"properties\" === t.name || \"geometry-type\" === t.name || \"id\" === t.name) return !1;\n      if (/^filter-/.test(t.name)) return !1;\n    }\n\n    if (t instanceof Ct) return !1;\n    let e = !0;\n    return t.eachChild(t => {\n      e && !Vt(t) && (e = !1);\n    }), e;\n  }\n\n  function Tt(t) {\n    if (t instanceof dt && \"feature-state\" === t.name) return !1;\n    let e = !0;\n    return t.eachChild(t => {\n      e && !Tt(t) && (e = !1);\n    }), e;\n  }\n\n  function Et(t, e) {\n    if (t instanceof dt && e.indexOf(t.name) >= 0) return !1;\n    let r = !0;\n    return t.eachChild(t => {\n      r && !Et(t, e) && (r = !1);\n    }), r;\n  }\n\n  class Dt {\n    constructor(t, e) {\n      this.type = e.type, this.name = t, this.boundExpression = e;\n    }\n\n    static parse(t, e) {\n      if (2 !== t.length || \"string\" != typeof t[1]) return e.error(\"'var' expression requires exactly one string literal argument.\");\n      const r = t[1];\n      return e.scope.has(r) ? new Dt(r, e.scope.get(r)) : e.error(`Unknown variable \"${r}\". Make sure \"${r}\" has been bound in an enclosing \"let\" expression before using it.`, 1);\n    }\n\n    evaluate(t) {\n      return this.boundExpression.evaluate(t);\n    }\n\n    eachChild() {}\n\n    outputDefined() {\n      return !1;\n    }\n\n    serialize() {\n      return [\"var\", this.name];\n    }\n\n  }\n\n  class Ft {\n    constructor(t, e = [], r, n = new T(), i = []) {\n      this.registry = t, this.path = e, this.key = e.map(t => `[${t}]`).join(\"\"), this.scope = n, this.errors = i, this.expectedType = r;\n    }\n\n    parse(t, e, r, n, i = {}) {\n      return e ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i);\n    }\n\n    _parse(t, e) {\n      function r(t, e, r) {\n        return \"assert\" === r ? new at(e, [t]) : \"coerce\" === r ? new ht(e, [t]) : t;\n      }\n\n      if (null !== t && \"string\" != typeof t && \"boolean\" != typeof t && \"number\" != typeof t || (t = [\"literal\", t]), Array.isArray(t)) {\n        if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].');\n        const n = t[0];\n        if (\"string\" != typeof n) return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use [\"literal\", [...]].`, 0), null;\n        const i = this.registry[n];\n\n        if (i) {\n          let n = i.parse(t, this);\n          if (!n) return null;\n\n          if (this.expectedType) {\n            const t = this.expectedType,\n                  i = n.type;\n            if (\"string\" !== t.kind && \"number\" !== t.kind && \"boolean\" !== t.kind && \"object\" !== t.kind && \"array\" !== t.kind || \"value\" !== i.kind) {\n              if (\"color\" !== t.kind && \"formatted\" !== t.kind && \"resolvedImage\" !== t.kind || \"value\" !== i.kind && \"string\" !== i.kind) {\n                if (this.checkSubtype(t, i)) return null;\n              } else n = r(n, t, e.typeAnnotation || \"coerce\");\n            } else n = r(n, t, e.typeAnnotation || \"assert\");\n          }\n\n          if (!(n instanceof it) && \"resolvedImage\" !== n.type.kind && function t(e) {\n            if (e instanceof Dt) return t(e.boundExpression);\n            if (e instanceof dt && \"error\" === e.name) return !1;\n            if (e instanceof yt) return !1;\n            if (e instanceof Ct) return !1;\n            const r = e instanceof ht || e instanceof at;\n            let n = !0;\n            return e.eachChild(e => {\n              n = r ? n && t(e) : n && e instanceof it;\n            }), !!n && Vt(e) && Et(e, [\"zoom\", \"heatmap-density\", \"line-progress\", \"sky-radial-progress\", \"accumulated\", \"is-supported-script\"]);\n          }(n)) {\n            const t = new ft();\n\n            try {\n              n = new it(n.type, n.evaluate(t));\n            } catch (t) {\n              return this.error(t.message), null;\n            }\n          }\n\n          return n;\n        }\n\n        return this.error(`Unknown expression \"${n}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n      }\n\n      return this.error(void 0 === t ? \"'undefined' value invalid. Use null instead.\" : \"object\" == typeof t ? 'Bare objects invalid. Use [\"literal\", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);\n    }\n\n    concat(t, e, r) {\n      const n = \"number\" == typeof t ? this.path.concat(t) : this.path,\n            i = r ? this.scope.concat(r) : this.scope;\n      return new Ft(this.registry, n, e || null, i, this.errors);\n    }\n\n    error(t, ...e) {\n      const r = `${this.key}${e.map(t => `[${t}]`).join(\"\")}`;\n      this.errors.push(new V(r, t));\n    }\n\n    checkSubtype(t, e) {\n      const r = X(t, e);\n      return r && this.error(r), r;\n    }\n\n  }\n\n  function Lt(t, e) {\n    const r = t.length - 1;\n    let n,\n        i,\n        s = 0,\n        o = r,\n        a = 0;\n\n    for (; s <= o;) if (a = Math.floor((s + o) / 2), n = t[a], i = t[a + 1], n <= e) {\n      if (a === r || e < i) return a;\n      s = a + 1;\n    } else {\n      if (!(n > e)) throw new st(\"Input is not a number.\");\n      o = a - 1;\n    }\n\n    return 0;\n  }\n\n  class Ot {\n    constructor(t, e, r) {\n      this.type = t, this.input = e, this.labels = [], this.outputs = [];\n\n      for (const [t, e] of r) this.labels.push(t), this.outputs.push(e);\n    }\n\n    static parse(t, e) {\n      if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n      if ((t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n      const r = e.parse(t[1], 1, D);\n      if (!r) return null;\n      const n = [];\n      let i = null;\n      e.expectedType && \"value\" !== e.expectedType.kind && (i = e.expectedType);\n\n      for (let r = 1; r < t.length; r += 2) {\n        const s = 1 === r ? -1 / 0 : t[r],\n              o = t[r + 1],\n              a = r,\n              l = r + 1;\n        if (\"number\" != typeof s) return e.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', a);\n        if (n.length && n[n.length - 1][0] >= s) return e.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', a);\n        const u = e.parse(o, l, i);\n        if (!u) return null;\n        i = i || u.type, n.push([s, u]);\n      }\n\n      return new Ot(i, r, n);\n    }\n\n    evaluate(t) {\n      const e = this.labels,\n            r = this.outputs;\n      if (1 === e.length) return r[0].evaluate(t);\n      const n = this.input.evaluate(t);\n      if (n <= e[0]) return r[0].evaluate(t);\n      const i = e.length;\n      return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[Lt(e, n)].evaluate(t);\n    }\n\n    eachChild(t) {\n      t(this.input);\n\n      for (const e of this.outputs) t(e);\n    }\n\n    outputDefined() {\n      return this.outputs.every(t => t.outputDefined());\n    }\n\n    serialize() {\n      const t = [\"step\", this.input.serialize()];\n\n      for (let e = 0; e < this.labels.length; e++) e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());\n\n      return t;\n    }\n\n  }\n\n  function $t(t, e, r) {\n    return t * (1 - r) + e * r;\n  }\n\n  var Rt = Object.freeze({\n    __proto__: null,\n    number: $t,\n    color: function (t, e, r) {\n      return new P($t(t.r, e.r, r), $t(t.g, e.g, r), $t(t.b, e.b, r), $t(t.a, e.a, r));\n    },\n    array: function (t, e, r) {\n      return t.map((t, n) => $t(t, e[n], r));\n    }\n  });\n  const qt = 6 / 29 * 3 * (6 / 29),\n        Ut = Math.PI / 180,\n        Nt = 180 / Math.PI;\n\n  function jt(t) {\n    return t > .008856451679035631 ? Math.pow(t, 1 / 3) : t / qt + 4 / 29;\n  }\n\n  function Zt(t) {\n    return t > 6 / 29 ? t * t * t : qt * (t - 4 / 29);\n  }\n\n  function Gt(t) {\n    return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);\n  }\n\n  function Xt(t) {\n    return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n  }\n\n  function Jt(t) {\n    const e = Xt(t.r),\n          r = Xt(t.g),\n          n = Xt(t.b),\n          i = jt((.4124564 * e + .3575761 * r + .1804375 * n) / .95047),\n          s = jt((.2126729 * e + .7151522 * r + .072175 * n) / 1);\n    return {\n      l: 116 * s - 16,\n      a: 500 * (i - s),\n      b: 200 * (s - jt((.0193339 * e + .119192 * r + .9503041 * n) / 1.08883)),\n      alpha: t.a\n    };\n  }\n\n  function Yt(t) {\n    let e = (t.l + 16) / 116,\n        r = isNaN(t.a) ? e : e + t.a / 500,\n        n = isNaN(t.b) ? e : e - t.b / 200;\n    return e = 1 * Zt(e), r = .95047 * Zt(r), n = 1.08883 * Zt(n), new P(Gt(3.2404542 * r - 1.5371385 * e - .4985314 * n), Gt(-.969266 * r + 1.8760108 * e + .041556 * n), Gt(.0556434 * r - .2040259 * e + 1.0572252 * n), t.alpha);\n  }\n\n  function Kt(t, e, r) {\n    const n = e - t;\n    return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);\n  }\n\n  const Ht = {\n    forward: Jt,\n    reverse: Yt,\n    interpolate: function (t, e, r) {\n      return {\n        l: $t(t.l, e.l, r),\n        a: $t(t.a, e.a, r),\n        b: $t(t.b, e.b, r),\n        alpha: $t(t.alpha, e.alpha, r)\n      };\n    }\n  },\n        Wt = {\n    forward: function (t) {\n      const {\n        l: e,\n        a: r,\n        b: n\n      } = Jt(t),\n            i = Math.atan2(n, r) * Nt;\n      return {\n        h: i < 0 ? i + 360 : i,\n        c: Math.sqrt(r * r + n * n),\n        l: e,\n        alpha: t.a\n      };\n    },\n    reverse: function (t) {\n      const e = t.h * Ut,\n            r = t.c;\n      return Yt({\n        l: t.l,\n        a: Math.cos(e) * r,\n        b: Math.sin(e) * r,\n        alpha: t.alpha\n      });\n    },\n    interpolate: function (t, e, r) {\n      return {\n        h: Kt(t.h, e.h, r),\n        c: $t(t.c, e.c, r),\n        l: $t(t.l, e.l, r),\n        alpha: $t(t.alpha, e.alpha, r)\n      };\n    }\n  };\n  var Qt = Object.freeze({\n    __proto__: null,\n    lab: Ht,\n    hcl: Wt\n  });\n\n  class te {\n    constructor(t, e, r, n, i) {\n      this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];\n\n      for (const [t, e] of i) this.labels.push(t), this.outputs.push(e);\n    }\n\n    static interpolationFactor(e, r, n, i) {\n      let s = 0;\n      if (\"exponential\" === e.name) s = ee(r, e.base, n, i);else if (\"linear\" === e.name) s = ee(r, 1, n, i);else if (\"cubic-bezier\" === e.name) {\n        const o = e.controlPoints;\n        s = new t(o[0], o[1], o[2], o[3]).solve(ee(r, 1, n, i));\n      }\n      return s;\n    }\n\n    static parse(t, e) {\n      let [r, n, i, ...s] = t;\n      if (!Array.isArray(n) || 0 === n.length) return e.error(\"Expected an interpolation type expression.\", 1);\n      if (\"linear\" === n[0]) n = {\n        name: \"linear\"\n      };else if (\"exponential\" === n[0]) {\n        const t = n[1];\n        if (\"number\" != typeof t) return e.error(\"Exponential interpolation requires a numeric base.\", 1, 1);\n        n = {\n          name: \"exponential\",\n          base: t\n        };\n      } else {\n        if (\"cubic-bezier\" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);\n        {\n          const t = n.slice(1);\n          if (4 !== t.length || t.some(t => \"number\" != typeof t || t < 0 || t > 1)) return e.error(\"Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.\", 1);\n          n = {\n            name: \"cubic-bezier\",\n            controlPoints: t\n          };\n        }\n      }\n      if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n      if ((t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n      if (i = e.parse(i, 2, D), !i) return null;\n      const o = [];\n      let a = null;\n      \"interpolate-hcl\" === r || \"interpolate-lab\" === r ? a = O : e.expectedType && \"value\" !== e.expectedType.kind && (a = e.expectedType);\n\n      for (let t = 0; t < s.length; t += 2) {\n        const r = s[t],\n              n = s[t + 1],\n              i = t + 3,\n              l = t + 4;\n        if (\"number\" != typeof r) return e.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);\n        if (o.length && o[o.length - 1][0] >= r) return e.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', i);\n        const u = e.parse(n, l, a);\n        if (!u) return null;\n        a = a || u.type, o.push([r, u]);\n      }\n\n      return \"number\" === a.kind || \"color\" === a.kind || \"array\" === a.kind && \"number\" === a.itemType.kind && \"number\" == typeof a.N ? new te(a, r, n, i, o) : e.error(`Type ${Z(a)} is not interpolatable.`);\n    }\n\n    evaluate(t) {\n      const e = this.labels,\n            r = this.outputs;\n      if (1 === e.length) return r[0].evaluate(t);\n      const n = this.input.evaluate(t);\n      if (n <= e[0]) return r[0].evaluate(t);\n      const i = e.length;\n      if (n >= e[i - 1]) return r[i - 1].evaluate(t);\n      const s = Lt(e, n),\n            o = te.interpolationFactor(this.interpolation, n, e[s], e[s + 1]),\n            a = r[s].evaluate(t),\n            l = r[s + 1].evaluate(t);\n      return \"interpolate\" === this.operator ? Rt[this.type.kind.toLowerCase()](a, l, o) : \"interpolate-hcl\" === this.operator ? Wt.reverse(Wt.interpolate(Wt.forward(a), Wt.forward(l), o)) : Ht.reverse(Ht.interpolate(Ht.forward(a), Ht.forward(l), o));\n    }\n\n    eachChild(t) {\n      t(this.input);\n\n      for (const e of this.outputs) t(e);\n    }\n\n    outputDefined() {\n      return this.outputs.every(t => t.outputDefined());\n    }\n\n    serialize() {\n      let t;\n      t = \"linear\" === this.interpolation.name ? [\"linear\"] : \"exponential\" === this.interpolation.name ? 1 === this.interpolation.base ? [\"linear\"] : [\"exponential\", this.interpolation.base] : [\"cubic-bezier\"].concat(this.interpolation.controlPoints);\n      const e = [this.operator, t, this.input.serialize()];\n\n      for (let t = 0; t < this.labels.length; t++) e.push(this.labels[t], this.outputs[t].serialize());\n\n      return e;\n    }\n\n  }\n\n  function ee(t, e, r, n) {\n    const i = n - r,\n          s = t - r;\n    return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);\n  }\n\n  class re {\n    constructor(t, e) {\n      this.type = t, this.args = e;\n    }\n\n    static parse(t, e) {\n      if (t.length < 2) return e.error(\"Expectected at least one argument.\");\n      let r = null;\n      const n = e.expectedType;\n      n && \"value\" !== n.kind && (r = n);\n      const i = [];\n\n      for (const n of t.slice(1)) {\n        const t = e.parse(n, 1 + i.length, r, void 0, {\n          typeAnnotation: \"omit\"\n        });\n        if (!t) return null;\n        r = r || t.type, i.push(t);\n      }\n\n      const s = n && i.some(t => X(n, t.type));\n      return new re(s ? R : r, i);\n    }\n\n    evaluate(t) {\n      let e,\n          r = null,\n          n = 0;\n\n      for (const i of this.args) if (n++, r = i.evaluate(t), r && r instanceof Q && !r.available && (e || (e = r.name), r = null, n === this.args.length && (r = e)), null !== r) break;\n\n      return r;\n    }\n\n    eachChild(t) {\n      this.args.forEach(t);\n    }\n\n    outputDefined() {\n      return this.args.every(t => t.outputDefined());\n    }\n\n    serialize() {\n      const t = [\"coalesce\"];\n      return this.eachChild(e => {\n        t.push(e.serialize());\n      }), t;\n    }\n\n  }\n\n  class ne {\n    constructor(t, e) {\n      this.type = e.type, this.bindings = [].concat(t), this.result = e;\n    }\n\n    evaluate(t) {\n      return this.result.evaluate(t);\n    }\n\n    eachChild(t) {\n      for (const e of this.bindings) t(e[1]);\n\n      t(this.result);\n    }\n\n    static parse(t, e) {\n      if (t.length < 4) return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);\n      const r = [];\n\n      for (let n = 1; n < t.length - 1; n += 2) {\n        const i = t[n];\n        if (\"string\" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n);\n        if (/[^a-zA-Z0-9_]/.test(i)) return e.error(\"Variable names must contain only alphanumeric characters or '_'.\", n);\n        const s = e.parse(t[n + 1], n + 1);\n        if (!s) return null;\n        r.push([i, s]);\n      }\n\n      const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);\n      return n ? new ne(r, n) : null;\n    }\n\n    outputDefined() {\n      return this.result.outputDefined();\n    }\n\n    serialize() {\n      const t = [\"let\"];\n\n      for (const [e, r] of this.bindings) t.push(e, r.serialize());\n\n      return t.push(this.result.serialize()), t;\n    }\n\n  }\n\n  class ie {\n    constructor(t, e, r) {\n      this.type = t, this.index = e, this.input = r;\n    }\n\n    static parse(t, e) {\n      if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);\n      const r = e.parse(t[1], 1, D),\n            n = e.parse(t[2], 2, j(e.expectedType || R));\n      return r && n ? new ie(n.type.itemType, r, n) : null;\n    }\n\n    evaluate(t) {\n      const e = this.index.evaluate(t),\n            r = this.input.evaluate(t);\n      if (e < 0) throw new st(`Array index out of bounds: ${e} < 0.`);\n      if (e >= r.length) throw new st(`Array index out of bounds: ${e} > ${r.length - 1}.`);\n      if (e !== Math.floor(e)) throw new st(`Array index must be an integer, but found ${e} instead.`);\n      return r[e];\n    }\n\n    eachChild(t) {\n      t(this.index), t(this.input);\n    }\n\n    outputDefined() {\n      return !1;\n    }\n\n    serialize() {\n      return [\"at\", this.index.serialize(), this.input.serialize()];\n    }\n\n  }\n\n  class se {\n    constructor(t, e) {\n      this.type = L, this.needle = t, this.haystack = e;\n    }\n\n    static parse(t, e) {\n      if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);\n      const r = e.parse(t[1], 1, R),\n            n = e.parse(t[2], 2, R);\n      return r && n ? J(r.type, [L, F, D, E, R]) ? new se(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Z(r.type)} instead`) : null;\n    }\n\n    evaluate(t) {\n      const e = this.needle.evaluate(t),\n            r = this.haystack.evaluate(t);\n      if (!r) return !1;\n      if (!Y(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new st(`Expected first argument to be of type boolean, string, number or null, but found ${Z(rt(e))} instead.`);\n      if (!Y(r, [\"string\", \"array\"])) throw new st(`Expected second argument to be of type array or string, but found ${Z(rt(r))} instead.`);\n      return r.indexOf(e) >= 0;\n    }\n\n    eachChild(t) {\n      t(this.needle), t(this.haystack);\n    }\n\n    outputDefined() {\n      return !0;\n    }\n\n    serialize() {\n      return [\"in\", this.needle.serialize(), this.haystack.serialize()];\n    }\n\n  }\n\n  class oe {\n    constructor(t, e, r) {\n      this.type = D, this.needle = t, this.haystack = e, this.fromIndex = r;\n    }\n\n    static parse(t, e) {\n      if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);\n      const r = e.parse(t[1], 1, R),\n            n = e.parse(t[2], 2, R);\n      if (!r || !n) return null;\n      if (!J(r.type, [L, F, D, E, R])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Z(r.type)} instead`);\n\n      if (4 === t.length) {\n        const i = e.parse(t[3], 3, D);\n        return i ? new oe(r, n, i) : null;\n      }\n\n      return new oe(r, n);\n    }\n\n    evaluate(t) {\n      const e = this.needle.evaluate(t),\n            r = this.haystack.evaluate(t);\n      if (!Y(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new st(`Expected first argument to be of type boolean, string, number or null, but found ${Z(rt(e))} instead.`);\n      if (!Y(r, [\"string\", \"array\"])) throw new st(`Expected second argument to be of type array or string, but found ${Z(rt(r))} instead.`);\n\n      if (this.fromIndex) {\n        const n = this.fromIndex.evaluate(t);\n        return r.indexOf(e, n);\n      }\n\n      return r.indexOf(e);\n    }\n\n    eachChild(t) {\n      t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);\n    }\n\n    outputDefined() {\n      return !1;\n    }\n\n    serialize() {\n      if (null != this.fromIndex && void 0 !== this.fromIndex) {\n        const t = this.fromIndex.serialize();\n        return [\"index-of\", this.needle.serialize(), this.haystack.serialize(), t];\n      }\n\n      return [\"index-of\", this.needle.serialize(), this.haystack.serialize()];\n    }\n\n  }\n\n  class ae {\n    constructor(t, e, r, n, i, s) {\n      this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;\n    }\n\n    static parse(t, e) {\n      if (t.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n      if (t.length % 2 != 1) return e.error(\"Expected an even number of arguments.\");\n      let r, n;\n      e.expectedType && \"value\" !== e.expectedType.kind && (n = e.expectedType);\n      const i = {},\n            s = [];\n\n      for (let o = 2; o < t.length - 1; o += 2) {\n        let a = t[o];\n        const l = t[o + 1];\n        Array.isArray(a) || (a = [a]);\n        const u = e.concat(o);\n        if (0 === a.length) return u.error(\"Expected at least one branch label.\");\n\n        for (const t of a) {\n          if (\"number\" != typeof t && \"string\" != typeof t) return u.error(\"Branch labels must be numbers or strings.\");\n          if (\"number\" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);\n          if (\"number\" == typeof t && Math.floor(t) !== t) return u.error(\"Numeric branch labels must be integer values.\");\n\n          if (r) {\n            if (u.checkSubtype(r, rt(t))) return null;\n          } else r = rt(t);\n\n          if (void 0 !== i[String(t)]) return u.error(\"Branch labels must be unique.\");\n          i[String(t)] = s.length;\n        }\n\n        const c = e.parse(l, o, n);\n        if (!c) return null;\n        n = n || c.type, s.push(c);\n      }\n\n      const o = e.parse(t[1], 1, R);\n      if (!o) return null;\n      const a = e.parse(t[t.length - 1], t.length - 1, n);\n      return a ? \"value\" !== o.type.kind && e.concat(1).checkSubtype(r, o.type) ? null : new ae(r, n, o, i, s, a) : null;\n    }\n\n    evaluate(t) {\n      const e = this.input.evaluate(t);\n      return (rt(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);\n    }\n\n    eachChild(t) {\n      t(this.input), this.outputs.forEach(t), t(this.otherwise);\n    }\n\n    outputDefined() {\n      return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined();\n    }\n\n    serialize() {\n      const t = [\"match\", this.input.serialize()],\n            e = Object.keys(this.cases).sort(),\n            r = [],\n            n = {};\n\n      for (const t of e) {\n        const e = n[this.cases[t]];\n        void 0 === e ? (n[this.cases[t]] = r.length, r.push([this.cases[t], [t]])) : r[e][1].push(t);\n      }\n\n      const i = t => \"number\" === this.inputType.kind ? Number(t) : t;\n\n      for (const [e, n] of r) t.push(1 === n.length ? i(n[0]) : n.map(i)), t.push(this.outputs[e].serialize());\n\n      return t.push(this.otherwise.serialize()), t;\n    }\n\n  }\n\n  class le {\n    constructor(t, e, r) {\n      this.type = t, this.branches = e, this.otherwise = r;\n    }\n\n    static parse(t, e) {\n      if (t.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);\n      if (t.length % 2 != 0) return e.error(\"Expected an odd number of arguments.\");\n      let r;\n      e.expectedType && \"value\" !== e.expectedType.kind && (r = e.expectedType);\n      const n = [];\n\n      for (let i = 1; i < t.length - 1; i += 2) {\n        const s = e.parse(t[i], i, L);\n        if (!s) return null;\n        const o = e.parse(t[i + 1], i + 1, r);\n        if (!o) return null;\n        n.push([s, o]), r = r || o.type;\n      }\n\n      const i = e.parse(t[t.length - 1], t.length - 1, r);\n      return i ? new le(r, n, i) : null;\n    }\n\n    evaluate(t) {\n      for (const [e, r] of this.branches) if (e.evaluate(t)) return r.evaluate(t);\n\n      return this.otherwise.evaluate(t);\n    }\n\n    eachChild(t) {\n      for (const [e, r] of this.branches) t(e), t(r);\n\n      t(this.otherwise);\n    }\n\n    outputDefined() {\n      return this.branches.every(([t, e]) => e.outputDefined()) && this.otherwise.outputDefined();\n    }\n\n    serialize() {\n      const t = [\"case\"];\n      return this.eachChild(e => {\n        t.push(e.serialize());\n      }), t;\n    }\n\n  }\n\n  class ue {\n    constructor(t, e, r, n) {\n      this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;\n    }\n\n    static parse(t, e) {\n      if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);\n      const r = e.parse(t[1], 1, R),\n            n = e.parse(t[2], 2, D);\n      if (!r || !n) return null;\n      if (!J(r.type, [j(R), F, R])) return e.error(`Expected first argument to be of type array or string, but found ${Z(r.type)} instead`);\n\n      if (4 === t.length) {\n        const i = e.parse(t[3], 3, D);\n        return i ? new ue(r.type, r, n, i) : null;\n      }\n\n      return new ue(r.type, r, n);\n    }\n\n    evaluate(t) {\n      const e = this.input.evaluate(t),\n            r = this.beginIndex.evaluate(t);\n      if (!Y(e, [\"string\", \"array\"])) throw new st(`Expected first argument to be of type array or string, but found ${Z(rt(e))} instead.`);\n\n      if (this.endIndex) {\n        const n = this.endIndex.evaluate(t);\n        return e.slice(r, n);\n      }\n\n      return e.slice(r);\n    }\n\n    eachChild(t) {\n      t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);\n    }\n\n    outputDefined() {\n      return !1;\n    }\n\n    serialize() {\n      if (null != this.endIndex && void 0 !== this.endIndex) {\n        const t = this.endIndex.serialize();\n        return [\"slice\", this.input.serialize(), this.beginIndex.serialize(), t];\n      }\n\n      return [\"slice\", this.input.serialize(), this.beginIndex.serialize()];\n    }\n\n  }\n\n  function ce(t, e) {\n    return \"==\" === t || \"!=\" === t ? \"boolean\" === e.kind || \"string\" === e.kind || \"number\" === e.kind || \"null\" === e.kind || \"value\" === e.kind : \"string\" === e.kind || \"number\" === e.kind || \"value\" === e.kind;\n  }\n\n  function he(t, e, r, n) {\n    return 0 === n.compare(e, r);\n  }\n\n  function pe(t, e, r) {\n    const n = \"==\" !== t && \"!=\" !== t;\n    return class i {\n      constructor(t, e, r) {\n        this.type = L, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = \"value\" === t.type.kind || \"value\" === e.type.kind;\n      }\n\n      static parse(t, e) {\n        if (3 !== t.length && 4 !== t.length) return e.error(\"Expected two or three arguments.\");\n        const r = t[0];\n        let s = e.parse(t[1], 1, R);\n        if (!s) return null;\n        if (!ce(r, s.type)) return e.concat(1).error(`\"${r}\" comparisons are not supported for type '${Z(s.type)}'.`);\n        let o = e.parse(t[2], 2, R);\n        if (!o) return null;\n        if (!ce(r, o.type)) return e.concat(2).error(`\"${r}\" comparisons are not supported for type '${Z(o.type)}'.`);\n        if (s.type.kind !== o.type.kind && \"value\" !== s.type.kind && \"value\" !== o.type.kind) return e.error(`Cannot compare types '${Z(s.type)}' and '${Z(o.type)}'.`);\n        n && (\"value\" === s.type.kind && \"value\" !== o.type.kind ? s = new at(o.type, [s]) : \"value\" !== s.type.kind && \"value\" === o.type.kind && (o = new at(s.type, [o])));\n        let a = null;\n\n        if (4 === t.length) {\n          if (\"string\" !== s.type.kind && \"string\" !== o.type.kind && \"value\" !== s.type.kind && \"value\" !== o.type.kind) return e.error(\"Cannot use collator to compare non-string types.\");\n          if (a = e.parse(t[3], 3, q), !a) return null;\n        }\n\n        return new i(s, o, a);\n      }\n\n      evaluate(i) {\n        const s = this.lhs.evaluate(i),\n              o = this.rhs.evaluate(i);\n\n        if (n && this.hasUntypedArgument) {\n          const e = rt(s),\n                r = rt(o);\n          if (e.kind !== r.kind || \"string\" !== e.kind && \"number\" !== e.kind) throw new st(`Expected arguments for \"${t}\" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`);\n        }\n\n        if (this.collator && !n && this.hasUntypedArgument) {\n          const t = rt(s),\n                r = rt(o);\n          if (\"string\" !== t.kind || \"string\" !== r.kind) return e(i, s, o);\n        }\n\n        return this.collator ? r(i, s, o, this.collator.evaluate(i)) : e(i, s, o);\n      }\n\n      eachChild(t) {\n        t(this.lhs), t(this.rhs), this.collator && t(this.collator);\n      }\n\n      outputDefined() {\n        return !0;\n      }\n\n      serialize() {\n        const e = [t];\n        return this.eachChild(t => {\n          e.push(t.serialize());\n        }), e;\n      }\n\n    };\n  }\n\n  const fe = pe(\"==\", function (t, e, r) {\n    return e === r;\n  }, he),\n        de = pe(\"!=\", function (t, e, r) {\n    return e !== r;\n  }, function (t, e, r, n) {\n    return !he(0, e, r, n);\n  }),\n        ye = pe(\"<\", function (t, e, r) {\n    return e < r;\n  }, function (t, e, r, n) {\n    return n.compare(e, r) < 0;\n  }),\n        me = pe(\">\", function (t, e, r) {\n    return e > r;\n  }, function (t, e, r, n) {\n    return n.compare(e, r) > 0;\n  }),\n        ge = pe(\"<=\", function (t, e, r) {\n    return e <= r;\n  }, function (t, e, r, n) {\n    return n.compare(e, r) <= 0;\n  });\n\n  class xe {\n    constructor(t, e, r, n, i) {\n      this.type = F, this.number = t, this.locale = e, this.currency = r, this.minFractionDigits = n, this.maxFractionDigits = i;\n    }\n\n    static parse(t, e) {\n      if (3 !== t.length) return e.error(\"Expected two arguments.\");\n      const r = e.parse(t[1], 1, D);\n      if (!r) return null;\n      const n = t[2];\n      if (\"object\" != typeof n || Array.isArray(n)) return e.error(\"NumberFormat options argument must be an object.\");\n      let i = null;\n      if (n.locale && (i = e.parse(n.locale, 1, F), !i)) return null;\n      let s = null;\n      if (n.currency && (s = e.parse(n.currency, 1, F), !s)) return null;\n      let o = null;\n      if (n[\"min-fraction-digits\"] && (o = e.parse(n[\"min-fraction-digits\"], 1, D), !o)) return null;\n      let a = null;\n      return n[\"max-fraction-digits\"] && (a = e.parse(n[\"max-fraction-digits\"], 1, D), !a) ? null : new xe(r, i, s, o, a);\n    }\n\n    evaluate(t) {\n      return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {\n        style: this.currency ? \"currency\" : \"decimal\",\n        currency: this.currency ? this.currency.evaluate(t) : void 0,\n        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,\n        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0\n      }).format(this.number.evaluate(t));\n    }\n\n    eachChild(t) {\n      t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);\n    }\n\n    outputDefined() {\n      return !1;\n    }\n\n    serialize() {\n      const t = {};\n      return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.minFractionDigits && (t[\"min-fraction-digits\"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t[\"max-fraction-digits\"] = this.maxFractionDigits.serialize()), [\"number-format\", this.number.serialize(), t];\n    }\n\n  }\n\n  class ve {\n    constructor(t) {\n      this.type = D, this.input = t;\n    }\n\n    static parse(t, e) {\n      if (2 !== t.length) return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);\n      const r = e.parse(t[1], 1);\n      return r ? \"array\" !== r.type.kind && \"string\" !== r.type.kind && \"value\" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${Z(r.type)} instead.`) : new ve(r) : null;\n    }\n\n    evaluate(t) {\n      const e = this.input.evaluate(t);\n      if (\"string\" == typeof e) return e.length;\n      if (Array.isArray(e)) return e.length;\n      throw new st(`Expected value to be of type string or array, but found ${Z(rt(e))} instead.`);\n    }\n\n    eachChild(t) {\n      t(this.input);\n    }\n\n    outputDefined() {\n      return !1;\n    }\n\n    serialize() {\n      const t = [\"length\"];\n      return this.eachChild(e => {\n        t.push(e.serialize());\n      }), t;\n    }\n\n  }\n\n  const be = {\n    \"==\": fe,\n    \"!=\": de,\n    \">\": me,\n    \"<\": ye,\n    \">=\": pe(\">=\", function (t, e, r) {\n      return e >= r;\n    }, function (t, e, r, n) {\n      return n.compare(e, r) >= 0;\n    }),\n    \"<=\": ge,\n    array: at,\n    at: ie,\n    boolean: at,\n    case: le,\n    coalesce: re,\n    collator: yt,\n    format: lt,\n    image: ut,\n    in: se,\n    \"index-of\": oe,\n    interpolate: te,\n    \"interpolate-hcl\": te,\n    \"interpolate-lab\": te,\n    length: ve,\n    let: ne,\n    literal: it,\n    match: ae,\n    number: at,\n    \"number-format\": xe,\n    object: at,\n    slice: ue,\n    step: Ot,\n    string: at,\n    \"to-boolean\": ht,\n    \"to-color\": ht,\n    \"to-number\": ht,\n    \"to-string\": ht,\n    var: Dt,\n    within: Ct\n  };\n\n  function we(t, [e, r, n, i]) {\n    e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t);\n    const s = i ? i.evaluate(t) : 1,\n          o = tt(e, r, n, s);\n    if (o) throw new st(o);\n    return new P(e / 255 * s, r / 255 * s, n / 255 * s, s);\n  }\n\n  function _e(t, e) {\n    return t in e;\n  }\n\n  function ke(t, e) {\n    const r = e[t];\n    return void 0 === r ? null : r;\n  }\n\n  function Se(t) {\n    return {\n      type: t\n    };\n  }\n\n  function Ae(t) {\n    return {\n      result: \"success\",\n      value: t\n    };\n  }\n\n  function Ie(t) {\n    return {\n      result: \"error\",\n      value: t\n    };\n  }\n\n  function ze(t) {\n    return \"data-driven\" === t[\"property-type\"] || \"cross-faded-data-driven\" === t[\"property-type\"];\n  }\n\n  function Me(t) {\n    return !!t.expression && t.expression.parameters.indexOf(\"zoom\") > -1;\n  }\n\n  function Be(t) {\n    return !!t.expression && t.expression.interpolated;\n  }\n\n  function Pe(t) {\n    return t instanceof Number ? \"number\" : t instanceof String ? \"string\" : t instanceof Boolean ? \"boolean\" : Array.isArray(t) ? \"array\" : null === t ? \"null\" : typeof t;\n  }\n\n  function Ce(t) {\n    return \"object\" == typeof t && null !== t && !Array.isArray(t);\n  }\n\n  function Ve(t) {\n    return t;\n  }\n\n  function Te(t, e, r) {\n    return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0;\n  }\n\n  function Ee(t, e, r, n, i) {\n    return Te(typeof r === i ? n[r] : void 0, t.default, e.default);\n  }\n\n  function De(t, e, r) {\n    if (\"number\" !== Pe(r)) return Te(t.default, e.default);\n    const n = t.stops.length;\n    if (1 === n) return t.stops[0][1];\n    if (r <= t.stops[0][0]) return t.stops[0][1];\n    if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1];\n    const i = Lt(t.stops.map(t => t[0]), r);\n    return t.stops[i][1];\n  }\n\n  function Fe(t, e, r) {\n    const n = void 0 !== t.base ? t.base : 1;\n    if (\"number\" !== Pe(r)) return Te(t.default, e.default);\n    const i = t.stops.length;\n    if (1 === i) return t.stops[0][1];\n    if (r <= t.stops[0][0]) return t.stops[0][1];\n    if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1];\n\n    const s = Lt(t.stops.map(t => t[0]), r),\n          o = function (t, e, r, n) {\n      const i = n - r,\n            s = t - r;\n      return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);\n    }(r, n, t.stops[s][0], t.stops[s + 1][0]),\n          a = t.stops[s][1],\n          l = t.stops[s + 1][1];\n\n    let u = Rt[e.type] || Ve;\n\n    if (t.colorSpace && \"rgb\" !== t.colorSpace) {\n      const e = Qt[t.colorSpace];\n\n      u = (t, r) => e.reverse(e.interpolate(e.forward(t), e.forward(r), o));\n    }\n\n    return \"function\" == typeof a.evaluate ? {\n      evaluate(...t) {\n        const e = a.evaluate.apply(void 0, t),\n              r = l.evaluate.apply(void 0, t);\n        if (void 0 !== e && void 0 !== r) return u(e, r, o);\n      }\n\n    } : u(a, l, o);\n  }\n\n  function Le(t, e, r) {\n    return \"color\" === e.type ? r = P.parse(r) : \"formatted\" === e.type ? r = W.fromString(r.toString()) : \"resolvedImage\" === e.type ? r = Q.fromString(r.toString()) : Pe(r) === e.type || \"enum\" === e.type && e.values[r] || (r = void 0), Te(r, t.default, e.default);\n  }\n\n  dt.register(be, {\n    error: [{\n      kind: \"error\"\n    }, [F], (t, [e]) => {\n      throw new st(e.evaluate(t));\n    }],\n    typeof: [F, [R], (t, [e]) => Z(rt(e.evaluate(t)))],\n    \"to-rgba\": [j(D, 4), [O], (t, [e]) => e.evaluate(t).toArray()],\n    rgb: [O, [D, D, D], we],\n    rgba: [O, [D, D, D, D], we],\n    has: {\n      type: L,\n      overloads: [[[F], (t, [e]) => _e(e.evaluate(t), t.properties())], [[F, $], (t, [e, r]) => _e(e.evaluate(t), r.evaluate(t))]]\n    },\n    get: {\n      type: R,\n      overloads: [[[F], (t, [e]) => ke(e.evaluate(t), t.properties())], [[F, $], (t, [e, r]) => ke(e.evaluate(t), r.evaluate(t))]]\n    },\n    \"feature-state\": [R, [F], (t, [e]) => ke(e.evaluate(t), t.featureState || {})],\n    properties: [$, [], t => t.properties()],\n    \"geometry-type\": [F, [], t => t.geometryType()],\n    id: [R, [], t => t.id()],\n    zoom: [D, [], t => t.globals.zoom],\n    \"heatmap-density\": [D, [], t => t.globals.heatmapDensity || 0],\n    \"line-progress\": [D, [], t => t.globals.lineProgress || 0],\n    \"sky-radial-progress\": [D, [], t => t.globals.skyRadialProgress || 0],\n    accumulated: [R, [], t => void 0 === t.globals.accumulated ? null : t.globals.accumulated],\n    \"+\": [D, Se(D), (t, e) => {\n      let r = 0;\n\n      for (const n of e) r += n.evaluate(t);\n\n      return r;\n    }],\n    \"*\": [D, Se(D), (t, e) => {\n      let r = 1;\n\n      for (const n of e) r *= n.evaluate(t);\n\n      return r;\n    }],\n    \"-\": {\n      type: D,\n      overloads: [[[D, D], (t, [e, r]) => e.evaluate(t) - r.evaluate(t)], [[D], (t, [e]) => -e.evaluate(t)]]\n    },\n    \"/\": [D, [D, D], (t, [e, r]) => e.evaluate(t) / r.evaluate(t)],\n    \"%\": [D, [D, D], (t, [e, r]) => e.evaluate(t) % r.evaluate(t)],\n    ln2: [D, [], () => Math.LN2],\n    pi: [D, [], () => Math.PI],\n    e: [D, [], () => Math.E],\n    \"^\": [D, [D, D], (t, [e, r]) => Math.pow(e.evaluate(t), r.evaluate(t))],\n    sqrt: [D, [D], (t, [e]) => Math.sqrt(e.evaluate(t))],\n    log10: [D, [D], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10],\n    ln: [D, [D], (t, [e]) => Math.log(e.evaluate(t))],\n    log2: [D, [D], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2],\n    sin: [D, [D], (t, [e]) => Math.sin(e.evaluate(t))],\n    cos: [D, [D], (t, [e]) => Math.cos(e.evaluate(t))],\n    tan: [D, [D], (t, [e]) => Math.tan(e.evaluate(t))],\n    asin: [D, [D], (t, [e]) => Math.asin(e.evaluate(t))],\n    acos: [D, [D], (t, [e]) => Math.acos(e.evaluate(t))],\n    atan: [D, [D], (t, [e]) => Math.atan(e.evaluate(t))],\n    min: [D, Se(D), (t, e) => Math.min(...e.map(e => e.evaluate(t)))],\n    max: [D, Se(D), (t, e) => Math.max(...e.map(e => e.evaluate(t)))],\n    abs: [D, [D], (t, [e]) => Math.abs(e.evaluate(t))],\n    round: [D, [D], (t, [e]) => {\n      const r = e.evaluate(t);\n      return r < 0 ? -Math.round(-r) : Math.round(r);\n    }],\n    floor: [D, [D], (t, [e]) => Math.floor(e.evaluate(t))],\n    ceil: [D, [D], (t, [e]) => Math.ceil(e.evaluate(t))],\n    \"filter-==\": [L, [F, R], (t, [e, r]) => t.properties()[e.value] === r.value],\n    \"filter-id-==\": [L, [R], (t, [e]) => t.id() === e.value],\n    \"filter-type-==\": [L, [F], (t, [e]) => t.geometryType() === e.value],\n    \"filter-<\": [L, [F, R], (t, [e, r]) => {\n      const n = t.properties()[e.value],\n            i = r.value;\n      return typeof n == typeof i && n < i;\n    }],\n    \"filter-id-<\": [L, [R], (t, [e]) => {\n      const r = t.id(),\n            n = e.value;\n      return typeof r == typeof n && r < n;\n    }],\n    \"filter->\": [L, [F, R], (t, [e, r]) => {\n      const n = t.properties()[e.value],\n            i = r.value;\n      return typeof n == typeof i && n > i;\n    }],\n    \"filter-id->\": [L, [R], (t, [e]) => {\n      const r = t.id(),\n            n = e.value;\n      return typeof r == typeof n && r > n;\n    }],\n    \"filter-<=\": [L, [F, R], (t, [e, r]) => {\n      const n = t.properties()[e.value],\n            i = r.value;\n      return typeof n == typeof i && n <= i;\n    }],\n    \"filter-id-<=\": [L, [R], (t, [e]) => {\n      const r = t.id(),\n            n = e.value;\n      return typeof r == typeof n && r <= n;\n    }],\n    \"filter->=\": [L, [F, R], (t, [e, r]) => {\n      const n = t.properties()[e.value],\n            i = r.value;\n      return typeof n == typeof i && n >= i;\n    }],\n    \"filter-id->=\": [L, [R], (t, [e]) => {\n      const r = t.id(),\n            n = e.value;\n      return typeof r == typeof n && r >= n;\n    }],\n    \"filter-has\": [L, [R], (t, [e]) => e.value in t.properties()],\n    \"filter-has-id\": [L, [], t => null !== t.id() && void 0 !== t.id()],\n    \"filter-type-in\": [L, [j(F)], (t, [e]) => e.value.indexOf(t.geometryType()) >= 0],\n    \"filter-id-in\": [L, [j(R)], (t, [e]) => e.value.indexOf(t.id()) >= 0],\n    \"filter-in-small\": [L, [F, j(R)], (t, [e, r]) => r.value.indexOf(t.properties()[e.value]) >= 0],\n    \"filter-in-large\": [L, [F, j(R)], (t, [e, r]) => function (t, e, r, n) {\n      for (; r <= n;) {\n        const i = r + n >> 1;\n        if (e[i] === t) return !0;\n        e[i] > t ? n = i - 1 : r = i + 1;\n      }\n\n      return !1;\n    }(t.properties()[e.value], r.value, 0, r.value.length - 1)],\n    all: {\n      type: L,\n      overloads: [[[L, L], (t, [e, r]) => e.evaluate(t) && r.evaluate(t)], [Se(L), (t, e) => {\n        for (const r of e) if (!r.evaluate(t)) return !1;\n\n        return !0;\n      }]]\n    },\n    any: {\n      type: L,\n      overloads: [[[L, L], (t, [e, r]) => e.evaluate(t) || r.evaluate(t)], [Se(L), (t, e) => {\n        for (const r of e) if (r.evaluate(t)) return !0;\n\n        return !1;\n      }]]\n    },\n    \"!\": [L, [L], (t, [e]) => !e.evaluate(t)],\n    \"is-supported-script\": [L, [F], (t, [e]) => {\n      const r = t.globals && t.globals.isSupportedScript;\n      return !r || r(e.evaluate(t));\n    }],\n    upcase: [F, [F], (t, [e]) => e.evaluate(t).toUpperCase()],\n    downcase: [F, [F], (t, [e]) => e.evaluate(t).toLowerCase()],\n    concat: [F, Se(R), (t, e) => e.map(e => nt(e.evaluate(t))).join(\"\")],\n    \"resolved-locale\": [F, [q], (t, [e]) => e.evaluate(t).resolvedLocale()]\n  });\n\n  class Oe {\n    constructor(t, e) {\n      this.expression = t, this._warningHistory = {}, this._evaluator = new ft(), this._defaultValue = e ? function (t) {\n        return \"color\" === t.type && Ce(t.default) ? new P(0, 0, 0, 0) : \"color\" === t.type ? P.parse(t.default) || null : void 0 === t.default ? null : t.default;\n      }(e) : null, this._enumValues = e && \"enum\" === e.type ? e.values : null;\n    }\n\n    evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n      return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this.expression.evaluate(this._evaluator);\n    }\n\n    evaluate(t, e, r, n, i, s) {\n      this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null;\n\n      try {\n        const t = this.expression.evaluate(this._evaluator);\n        if (null == t || \"number\" == typeof t && t != t) return this._defaultValue;\n        if (this._enumValues && !(t in this._enumValues)) throw new st(`Expected value to be one of ${Object.keys(this._enumValues).map(t => JSON.stringify(t)).join(\", \")}, but found ${JSON.stringify(t)} instead.`);\n        return t;\n      } catch (t) {\n        return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, \"undefined\" != typeof console && console.warn(t.message)), this._defaultValue;\n      }\n    }\n\n  }\n\n  function $e(t) {\n    return Array.isArray(t) && t.length > 0 && \"string\" == typeof t[0] && t[0] in be;\n  }\n\n  function Re(t, e) {\n    const r = new Ft(be, [], e ? function (t) {\n      const e = {\n        color: O,\n        string: F,\n        number: D,\n        enum: F,\n        boolean: L,\n        formatted: U,\n        resolvedImage: N\n      };\n      return \"array\" === t.type ? j(e[t.value] || R, t.length) : e[t.type];\n    }(e) : void 0),\n          n = r.parse(t, void 0, void 0, void 0, e && \"string\" === e.type ? {\n      typeAnnotation: \"coerce\"\n    } : void 0);\n    return n ? Ae(new Oe(n, e)) : Ie(r.errors);\n  }\n\n  class qe {\n    constructor(t, e) {\n      this.kind = t, this._styleExpression = e, this.isStateDependent = \"constant\" !== t && !Tt(e.expression);\n    }\n\n    evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n      return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);\n    }\n\n    evaluate(t, e, r, n, i, s) {\n      return this._styleExpression.evaluate(t, e, r, n, i, s);\n    }\n\n  }\n\n  class Ue {\n    constructor(t, e, r, n) {\n      this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = \"camera\" !== t && !Tt(e.expression), this.interpolationType = n;\n    }\n\n    evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n      return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);\n    }\n\n    evaluate(t, e, r, n, i, s) {\n      return this._styleExpression.evaluate(t, e, r, n, i, s);\n    }\n\n    interpolationFactor(t, e, r) {\n      return this.interpolationType ? te.interpolationFactor(this.interpolationType, t, e, r) : 0;\n    }\n\n  }\n\n  function Ne(t, e) {\n    if (\"error\" === (t = Re(t, e)).result) return t;\n    const r = t.value.expression,\n          n = Vt(r);\n    if (!n && !ze(e)) return Ie([new V(\"\", \"data expressions not supported\")]);\n    const i = Et(r, [\"zoom\"]);\n    if (!i && !Me(e)) return Ie([new V(\"\", \"zoom expressions not supported\")]);\n\n    const s = function t(e) {\n      let r = null;\n      if (e instanceof ne) r = t(e.result);else if (e instanceof re) {\n        for (const n of e.args) if (r = t(n), r) break;\n      } else (e instanceof Ot || e instanceof te) && e.input instanceof dt && \"zoom\" === e.input.name && (r = e);\n      return r instanceof V || e.eachChild(e => {\n        const n = t(e);\n        n instanceof V ? r = n : !r && n ? r = new V(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.') : r && n && r !== n && (r = new V(\"\", 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.'));\n      }), r;\n    }(r);\n\n    return s || i ? s instanceof V ? Ie([s]) : s instanceof te && !Be(e) ? Ie([new V(\"\", '\"interpolate\" expressions cannot be used with this property')]) : Ae(s ? new Ue(n ? \"camera\" : \"composite\", t.value, s.labels, s instanceof te ? s.interpolation : void 0) : new qe(n ? \"constant\" : \"source\", t.value)) : Ie([new V(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.')]);\n  }\n\n  class je {\n    constructor(t, e) {\n      this._parameters = t, this._specification = e, C(this, function t(e, r) {\n        const n = \"color\" === r.type,\n              i = e.stops && \"object\" == typeof e.stops[0][0],\n              s = i || !(i || void 0 !== e.property),\n              o = e.type || (Be(r) ? \"exponential\" : \"interval\");\n        if (n && ((e = C({}, e)).stops && (e.stops = e.stops.map(t => [t[0], P.parse(t[1])])), e.default = P.parse(e.default ? e.default : r.default)), e.colorSpace && \"rgb\" !== e.colorSpace && !Qt[e.colorSpace]) throw new Error(`Unknown color space: ${e.colorSpace}`);\n        let a, l, u;\n        if (\"exponential\" === o) a = Fe;else if (\"interval\" === o) a = De;else if (\"categorical\" === o) {\n          a = Ee, l = Object.create(null);\n\n          for (const t of e.stops) l[t[0]] = t[1];\n\n          u = typeof e.stops[0][0];\n        } else {\n          if (\"identity\" !== o) throw new Error(`Unknown function type \"${o}\"`);\n          a = Le;\n        }\n\n        if (i) {\n          const n = {},\n                i = [];\n\n          for (let t = 0; t < e.stops.length; t++) {\n            const r = e.stops[t],\n                  s = r[0].zoom;\n            void 0 === n[s] && (n[s] = {\n              zoom: s,\n              type: e.type,\n              property: e.property,\n              default: e.default,\n              stops: []\n            }, i.push(s)), n[s].stops.push([r[0].value, r[1]]);\n          }\n\n          const s = [];\n\n          for (const e of i) s.push([n[e].zoom, t(n[e], r)]);\n\n          const o = {\n            name: \"linear\"\n          };\n          return {\n            kind: \"composite\",\n            interpolationType: o,\n            interpolationFactor: te.interpolationFactor.bind(void 0, o),\n            zoomStops: s.map(t => t[0]),\n            evaluate: ({\n              zoom: t\n            }, n) => Fe({\n              stops: s,\n              base: e.base\n            }, r, t).evaluate(t, n)\n          };\n        }\n\n        if (s) {\n          const t = \"exponential\" === o ? {\n            name: \"exponential\",\n            base: void 0 !== e.base ? e.base : 1\n          } : null;\n          return {\n            kind: \"camera\",\n            interpolationType: t,\n            interpolationFactor: te.interpolationFactor.bind(void 0, t),\n            zoomStops: e.stops.map(t => t[0]),\n            evaluate: ({\n              zoom: t\n            }) => a(e, r, t, l, u)\n          };\n        }\n\n        return {\n          kind: \"source\",\n\n          evaluate(t, n) {\n            const i = n && n.properties ? n.properties[e.property] : void 0;\n            return void 0 === i ? Te(e.default, r.default) : a(e, r, i, l, u);\n          }\n\n        };\n      }(this._parameters, this._specification));\n    }\n\n    static deserialize(t) {\n      return new je(t._parameters, t._specification);\n    }\n\n    static serialize(t) {\n      return {\n        _parameters: t._parameters,\n        _specification: t._specification\n      };\n    }\n\n  }\n\n  const {\n    ImageData: Ze,\n    ImageBitmap: Ge\n  } = i,\n        Xe = {};\n\n  function Je(t, e, r = {}) {\n    Object.defineProperty(e, \"_classRegistryKey\", {\n      value: t,\n      writeable: !1\n    }), Xe[t] = {\n      klass: e,\n      omit: r.omit || [],\n      shallow: r.shallow || []\n    };\n  }\n\n  Je(\"Object\", Object), I.serialize = function (t, e) {\n    const r = t.toArrayBuffer();\n    return e && e.push(r), {\n      buffer: r\n    };\n  }, I.deserialize = function (t) {\n    return new I(t.buffer);\n  }, Je(\"Grid\", I), Je(\"Color\", P), Je(\"Error\", Error), Je(\"ResolvedImage\", Q), Je(\"StylePropertyFunction\", je), Je(\"StyleExpression\", Oe, {\n    omit: [\"_evaluator\"]\n  }), Je(\"ZoomDependentExpression\", Ue), Je(\"ZoomConstantExpression\", qe), Je(\"CompoundExpression\", dt, {\n    omit: [\"_evaluate\"]\n  });\n\n  for (const t in be) be[t]._classRegistryKey || Je(`Expression_${t}`, be[t]);\n\n  function Ye(t) {\n    return t && \"undefined\" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && \"ArrayBuffer\" === t.constructor.name);\n  }\n\n  function Ke(t) {\n    return Ge && t instanceof Ge;\n  }\n\n  function He(t, e) {\n    if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t;\n    if (Ye(t) || Ke(t)) return e && e.push(t), t;\n\n    if (ArrayBuffer.isView(t)) {\n      const r = t;\n      return e && e.push(r.buffer), r;\n    }\n\n    if (t instanceof Ze) return e && e.push(t.data.buffer), t;\n\n    if (Array.isArray(t)) {\n      const r = [];\n\n      for (const n of t) r.push(He(n, e));\n\n      return r;\n    }\n\n    if (\"object\" == typeof t) {\n      const r = t.constructor,\n            n = r._classRegistryKey;\n      if (!n) throw new Error(\"can't serialize object of unregistered class\");\n      const i = r.serialize ? r.serialize(t, e) : {};\n\n      if (!r.serialize) {\n        for (const r in t) {\n          if (!t.hasOwnProperty(r)) continue;\n          if (Xe[n].omit.indexOf(r) >= 0) continue;\n          const s = t[r];\n          i[r] = Xe[n].shallow.indexOf(r) >= 0 ? s : He(s, e);\n        }\n\n        t instanceof Error && (i.message = t.message);\n      }\n\n      if (i.$name) throw new Error(\"$name property is reserved for worker serialization logic.\");\n      return \"Object\" !== n && (i.$name = n), i;\n    }\n\n    throw new Error(`can't serialize object of type ${typeof t}`);\n  }\n\n  function We(t) {\n    if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || Ye(t) || Ke(t) || ArrayBuffer.isView(t) || t instanceof Ze) return t;\n    if (Array.isArray(t)) return t.map(We);\n\n    if (\"object\" == typeof t) {\n      const e = t.$name || \"Object\",\n            {\n        klass: r\n      } = Xe[e];\n      if (!r) throw new Error(`can't deserialize unregistered class ${e}`);\n      if (r.deserialize) return r.deserialize(t);\n      const n = Object.create(r.prototype);\n\n      for (const r of Object.keys(t)) {\n        if (\"$name\" === r) continue;\n        const i = t[r];\n        n[r] = Xe[e].shallow.indexOf(r) >= 0 ? i : We(i);\n      }\n\n      return n;\n    }\n\n    throw new Error(`can't deserialize object of type ${typeof t}`);\n  }\n\n  class Qe {\n    constructor(t) {\n      this._callback = t, this._triggered = !1, \"undefined\" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {\n        this._triggered = !1, this._callback();\n      });\n    }\n\n    trigger() {\n      this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {\n        this._triggered = !1, this._callback();\n      }, 0));\n    }\n\n    remove() {\n      delete this._channel, this._callback = () => {};\n    }\n\n  }\n\n  const tr = i.performance;\n\n  class er {\n    constructor(t) {\n      this._marks = {\n        start: [t.url, \"start\"].join(\"#\"),\n        end: [t.url, \"end\"].join(\"#\"),\n        measure: t.url.toString()\n      }, tr.mark(this._marks.start);\n    }\n\n    finish() {\n      tr.mark(this._marks.end);\n      let t = tr.getEntriesByName(this._marks.measure);\n      return 0 === t.length && (tr.measure(this._marks.measure, this._marks.start, this._marks.end), t = tr.getEntriesByName(this._marks.measure), tr.clearMarks(this._marks.start), tr.clearMarks(this._marks.end), tr.clearMeasures(this._marks.measure)), t;\n    }\n\n  }\n\n  class rr {\n    constructor() {\n      this.tasks = {}, this.taskQueue = [], f([\"process\"], this), this.invoker = new Qe(this.process), this.nextId = 0;\n    }\n\n    add(t, e) {\n      const r = this.nextId++;\n      return this.tasks[r] = {\n        fn: t,\n        metadata: e,\n        priority: nr(e),\n        id: r\n      }, this.taskQueue.push(r), this.invoker.trigger(), {\n        cancel: () => {\n          delete this.tasks[r];\n        }\n      };\n    }\n\n    process() {\n      w();\n\n      try {\n        if (this.taskQueue = this.taskQueue.filter(t => !!this.tasks[t]), !this.taskQueue.length) return;\n        const t = this.pick();\n        if (null === t) return;\n        const e = this.tasks[t];\n        if (delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), !e) return;\n        e.fn();\n      } finally {}\n    }\n\n    pick() {\n      let t = null,\n          e = 1 / 0;\n\n      for (let r = 0; r < this.taskQueue.length; r++) {\n        const n = this.tasks[this.taskQueue[r]];\n        n.priority < e && (e = n.priority, t = r);\n      }\n\n      if (null === t) return null;\n      const r = this.taskQueue[t];\n      return this.taskQueue.splice(t, 1), r;\n    }\n\n    remove() {\n      this.invoker.remove();\n    }\n\n  }\n\n  function nr({\n    type: t,\n    isSymbolTile: e,\n    zoom: r\n  }) {\n    return r = r || 0, \"message\" === t ? 0 : \"maybePrepare\" !== t || e ? \"parseTile\" !== t || e ? \"parseTile\" === t && e ? 300 - r : \"maybePrepare\" === t && e ? 400 - r : 500 : 200 - r : 100 - r;\n  }\n\n  class ir {\n    constructor(t, e, r) {\n      this.target = t, this.parent = e, this.mapId = r, this.callbacks = {}, this.cancelCallbacks = {}, f([\"receive\"], this), this.target.addEventListener(\"message\", this.receive, !1), this.globalScope = w() ? t : i, this.scheduler = new rr();\n    }\n\n    send(t, e, r, n, i = !1, s) {\n      const o = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);\n      r && (r.metadata = s, this.callbacks[o] = r);\n      const a = S(this.globalScope) ? void 0 : [];\n      return this.target.postMessage({\n        id: o,\n        type: t,\n        hasCallback: !!r,\n        targetMapId: n,\n        mustQueue: i,\n        sourceMapId: this.mapId,\n        data: He(e, a)\n      }, a), {\n        cancel: () => {\n          r && delete this.callbacks[o], this.target.postMessage({\n            id: o,\n            type: \"<cancel>\",\n            targetMapId: n,\n            sourceMapId: this.mapId\n          });\n        }\n      };\n    }\n\n    receive(t) {\n      const e = t.data,\n            r = e.id;\n      if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if (\"<cancel>\" === e.type) {\n        const t = this.cancelCallbacks[r];\n        delete this.cancelCallbacks[r], t && t.cancel();\n      } else if (w() || e.mustQueue) {\n        const t = this.callbacks[r];\n        this.cancelCallbacks[r] = this.scheduler.add(() => this.processTask(r, e), t && t.metadata || {\n          type: \"message\"\n        });\n      } else this.processTask(r, e);\n    }\n\n    processTask(t, e) {\n      if (\"<response>\" === e.type) {\n        const r = this.callbacks[t];\n        delete this.callbacks[t], r && (e.error ? r(We(e.error)) : r(null, We(e.data)));\n      } else {\n        const r = S(this.globalScope) ? void 0 : [],\n              n = e.hasCallback ? (e, n) => {\n          delete this.cancelCallbacks[t], this.target.postMessage({\n            id: t,\n            type: \"<response>\",\n            sourceMapId: this.mapId,\n            error: e ? He(e) : null,\n            data: He(n, r)\n          }, r);\n        } : t => {},\n              i = We(e.data);\n        if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i, n);else if (this.parent.getWorkerSource) {\n          const t = e.type.split(\".\");\n          this.parent.getWorkerSource(e.sourceMapId, t[0], i.source)[t[1]](i, n);\n        } else n(new Error(`Could not find function ${e.type}`));\n      }\n    }\n\n    remove() {\n      this.scheduler.remove(), this.target.removeEventListener(\"message\", this.receive, !1);\n    }\n\n  }\n\n  var sr = {\n    $version: 8,\n    $root: {\n      version: {\n        required: !0,\n        type: \"enum\",\n        values: [8]\n      },\n      name: {\n        type: \"string\"\n      },\n      metadata: {\n        type: \"*\"\n      },\n      center: {\n        type: \"array\",\n        value: \"number\"\n      },\n      zoom: {\n        type: \"number\"\n      },\n      bearing: {\n        type: \"number\",\n        default: 0,\n        period: 360,\n        units: \"degrees\"\n      },\n      pitch: {\n        type: \"number\",\n        default: 0,\n        units: \"degrees\"\n      },\n      light: {\n        type: \"light\"\n      },\n      terrain: {\n        type: \"terrain\"\n      },\n      sources: {\n        required: !0,\n        type: \"sources\"\n      },\n      sprite: {\n        type: \"string\"\n      },\n      glyphs: {\n        type: \"string\"\n      },\n      transition: {\n        type: \"transition\"\n      },\n      layers: {\n        required: !0,\n        type: \"array\",\n        value: \"layer\"\n      }\n    },\n    sources: {\n      \"*\": {\n        type: \"source\"\n      }\n    },\n    source: [\"source_vector\", \"source_raster\", \"source_raster_dem\", \"source_geojson\", \"source_video\", \"source_image\"],\n    source_vector: {\n      type: {\n        required: !0,\n        type: \"enum\",\n        values: {\n          vector: {}\n        }\n      },\n      url: {\n        type: \"string\"\n      },\n      tiles: {\n        type: \"array\",\n        value: \"string\"\n      },\n      bounds: {\n        type: \"array\",\n        value: \"number\",\n        length: 4,\n        default: [-180, -85.051129, 180, 85.051129]\n      },\n      scheme: {\n        type: \"enum\",\n        values: {\n          xyz: {},\n          tms: {}\n        },\n        default: \"xyz\"\n      },\n      minzoom: {\n        type: \"number\",\n        default: 0\n      },\n      maxzoom: {\n        type: \"number\",\n        default: 22\n      },\n      attribution: {\n        type: \"string\"\n      },\n      promoteId: {\n        type: \"promoteId\"\n      },\n      volatile: {\n        type: \"boolean\",\n        default: !1\n      },\n      \"*\": {\n        type: \"*\"\n      }\n    },\n    source_raster: {\n      type: {\n        required: !0,\n        type: \"enum\",\n        values: {\n          raster: {}\n        }\n      },\n      url: {\n        type: \"string\"\n      },\n      tiles: {\n        type: \"array\",\n        value: \"string\"\n      },\n      bounds: {\n        type: \"array\",\n        value: \"number\",\n        length: 4,\n        default: [-180, -85.051129, 180, 85.051129]\n      },\n      minzoom: {\n        type: \"number\",\n        default: 0\n      },\n      maxzoom: {\n        type: \"number\",\n        default: 22\n      },\n      tileSize: {\n        type: \"number\",\n        default: 512,\n        units: \"pixels\"\n      },\n      scheme: {\n        type: \"enum\",\n        values: {\n          xyz: {},\n          tms: {}\n        },\n        default: \"xyz\"\n      },\n      attribution: {\n        type: \"string\"\n      },\n      volatile: {\n        type: \"boolean\",\n        default: !1\n      },\n      \"*\": {\n        type: \"*\"\n      }\n    },\n    source_raster_dem: {\n      type: {\n        required: !0,\n        type: \"enum\",\n        values: {\n          \"raster-dem\": {}\n        }\n      },\n      url: {\n        type: \"string\"\n      },\n      tiles: {\n        type: \"array\",\n        value: \"string\"\n      },\n      bounds: {\n        type: \"array\",\n        value: \"number\",\n        length: 4,\n        default: [-180, -85.051129, 180, 85.051129]\n      },\n      minzoom: {\n        type: \"number\",\n        default: 0\n      },\n      maxzoom: {\n        type: \"number\",\n        default: 22\n      },\n      tileSize: {\n        type: \"number\",\n        default: 512,\n        units: \"pixels\"\n      },\n      attribution: {\n        type: \"string\"\n      },\n      encoding: {\n        type: \"enum\",\n        values: {\n          terrarium: {},\n          mapbox: {}\n        },\n        default: \"mapbox\"\n      },\n      volatile: {\n        type: \"boolean\",\n        default: !1\n      },\n      \"*\": {\n        type: \"*\"\n      }\n    },\n    source_geojson: {\n      type: {\n        required: !0,\n        type: \"enum\",\n        values: {\n          geojson: {}\n        }\n      },\n      data: {\n        type: \"*\"\n      },\n      maxzoom: {\n        type: \"number\",\n        default: 18\n      },\n      attribution: {\n        type: \"string\"\n      },\n      buffer: {\n        type: \"number\",\n        default: 128,\n        maximum: 512,\n        minimum: 0\n      },\n      filter: {\n        type: \"*\"\n      },\n      tolerance: {\n        type: \"number\",\n        default: .375\n      },\n      cluster: {\n        type: \"boolean\",\n        default: !1\n      },\n      clusterRadius: {\n        type: \"number\",\n        default: 50,\n        minimum: 0\n      },\n      clusterMaxZoom: {\n        type: \"number\"\n      },\n      clusterMinPoints: {\n        type: \"number\"\n      },\n      clusterProperties: {\n        type: \"*\"\n      },\n      lineMetrics: {\n        type: \"boolean\",\n        default: !1\n      },\n      generateId: {\n        type: \"boolean\",\n        default: !1\n      },\n      promoteId: {\n        type: \"promoteId\"\n      }\n    },\n    source_video: {\n      type: {\n        required: !0,\n        type: \"enum\",\n        values: {\n          video: {}\n        }\n      },\n      urls: {\n        required: !0,\n        type: \"array\",\n        value: \"string\"\n      },\n      coordinates: {\n        required: !0,\n        type: \"array\",\n        length: 4,\n        value: {\n          type: \"array\",\n          length: 2,\n          value: \"number\"\n        }\n      }\n    },\n    source_image: {\n      type: {\n        required: !0,\n        type: \"enum\",\n        values: {\n          image: {}\n        }\n      },\n      url: {\n        required: !0,\n        type: \"string\"\n      },\n      coordinates: {\n        required: !0,\n        type: \"array\",\n        length: 4,\n        value: {\n          type: \"array\",\n          length: 2,\n          value: \"number\"\n        }\n      }\n    },\n    layer: {\n      id: {\n        type: \"string\",\n        required: !0\n      },\n      type: {\n        type: \"enum\",\n        values: {\n          fill: {},\n          line: {},\n          symbol: {},\n          circle: {},\n          heatmap: {},\n          \"fill-extrusion\": {},\n          raster: {},\n          hillshade: {},\n          background: {},\n          sky: {}\n        },\n        required: !0\n      },\n      metadata: {\n        type: \"*\"\n      },\n      source: {\n        type: \"string\"\n      },\n      \"source-layer\": {\n        type: \"string\"\n      },\n      minzoom: {\n        type: \"number\",\n        minimum: 0,\n        maximum: 24\n      },\n      maxzoom: {\n        type: \"number\",\n        minimum: 0,\n        maximum: 24\n      },\n      filter: {\n        type: \"filter\"\n      },\n      layout: {\n        type: \"layout\"\n      },\n      paint: {\n        type: \"paint\"\n      }\n    },\n    layout: [\"layout_fill\", \"layout_line\", \"layout_circle\", \"layout_heatmap\", \"layout_fill-extrusion\", \"layout_symbol\", \"layout_raster\", \"layout_hillshade\", \"layout_background\", \"layout_sky\"],\n    layout_background: {\n      visibility: {\n        type: \"enum\",\n        values: {\n          visible: {},\n          none: {}\n        },\n        default: \"visible\",\n        \"property-type\": \"constant\"\n      }\n    },\n    layout_sky: {\n      visibility: {\n        type: \"enum\",\n        values: {\n          visible: {},\n          none: {}\n        },\n        default: \"visible\",\n        \"property-type\": \"constant\"\n      }\n    },\n    layout_fill: {\n      \"fill-sort-key\": {\n        type: \"number\",\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      visibility: {\n        type: \"enum\",\n        values: {\n          visible: {},\n          none: {}\n        },\n        default: \"visible\",\n        \"property-type\": \"constant\"\n      }\n    },\n    layout_circle: {\n      \"circle-sort-key\": {\n        type: \"number\",\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      visibility: {\n        type: \"enum\",\n        values: {\n          visible: {},\n          none: {}\n        },\n        default: \"visible\",\n        \"property-type\": \"constant\"\n      }\n    },\n    layout_heatmap: {\n      visibility: {\n        type: \"enum\",\n        values: {\n          visible: {},\n          none: {}\n        },\n        default: \"visible\",\n        \"property-type\": \"constant\"\n      }\n    },\n    \"layout_fill-extrusion\": {\n      visibility: {\n        type: \"enum\",\n        values: {\n          visible: {},\n          none: {}\n        },\n        default: \"visible\",\n        \"property-type\": \"constant\"\n      }\n    },\n    layout_line: {\n      \"line-cap\": {\n        type: \"enum\",\n        values: {\n          butt: {},\n          round: {},\n          square: {}\n        },\n        default: \"butt\",\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"line-join\": {\n        type: \"enum\",\n        values: {\n          bevel: {},\n          round: {},\n          miter: {}\n        },\n        default: \"miter\",\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"line-miter-limit\": {\n        type: \"number\",\n        default: 2,\n        requires: [{\n          \"line-join\": \"miter\"\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"line-round-limit\": {\n        type: \"number\",\n        default: 1.05,\n        requires: [{\n          \"line-join\": \"round\"\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"line-sort-key\": {\n        type: \"number\",\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      visibility: {\n        type: \"enum\",\n        values: {\n          visible: {},\n          none: {}\n        },\n        default: \"visible\",\n        \"property-type\": \"constant\"\n      }\n    },\n    layout_symbol: {\n      \"symbol-placement\": {\n        type: \"enum\",\n        values: {\n          point: {},\n          line: {},\n          \"line-center\": {}\n        },\n        default: \"point\",\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"symbol-spacing\": {\n        type: \"number\",\n        default: 250,\n        minimum: 1,\n        units: \"pixels\",\n        requires: [{\n          \"symbol-placement\": \"line\"\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"symbol-avoid-edges\": {\n        type: \"boolean\",\n        default: !1,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"symbol-sort-key\": {\n        type: \"number\",\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"symbol-z-order\": {\n        type: \"enum\",\n        values: {\n          auto: {},\n          \"viewport-y\": {},\n          source: {}\n        },\n        default: \"auto\",\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"icon-allow-overlap\": {\n        type: \"boolean\",\n        default: !1,\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"icon-ignore-placement\": {\n        type: \"boolean\",\n        default: !1,\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"icon-optional\": {\n        type: \"boolean\",\n        default: !1,\n        requires: [\"icon-image\", \"text-field\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"icon-rotation-alignment\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {},\n          auto: {}\n        },\n        default: \"auto\",\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"icon-size\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        units: \"factor of the original icon size\",\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"icon-text-fit\": {\n        type: \"enum\",\n        values: {\n          none: {},\n          width: {},\n          height: {},\n          both: {}\n        },\n        default: \"none\",\n        requires: [\"icon-image\", \"text-field\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"icon-text-fit-padding\": {\n        type: \"array\",\n        value: \"number\",\n        length: 4,\n        default: [0, 0, 0, 0],\n        units: \"pixels\",\n        requires: [\"icon-image\", \"text-field\", {\n          \"icon-text-fit\": [\"both\", \"width\", \"height\"]\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"icon-image\": {\n        type: \"resolvedImage\",\n        tokens: !0,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"icon-rotate\": {\n        type: \"number\",\n        default: 0,\n        period: 360,\n        units: \"degrees\",\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"icon-padding\": {\n        type: \"number\",\n        default: 2,\n        minimum: 0,\n        units: \"pixels\",\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"icon-keep-upright\": {\n        type: \"boolean\",\n        default: !1,\n        requires: [\"icon-image\", {\n          \"icon-rotation-alignment\": \"map\"\n        }, {\n          \"symbol-placement\": [\"line\", \"line-center\"]\n        }],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"icon-offset\": {\n        type: \"array\",\n        value: \"number\",\n        length: 2,\n        default: [0, 0],\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"icon-anchor\": {\n        type: \"enum\",\n        values: {\n          center: {},\n          left: {},\n          right: {},\n          top: {},\n          bottom: {},\n          \"top-left\": {},\n          \"top-right\": {},\n          \"bottom-left\": {},\n          \"bottom-right\": {}\n        },\n        default: \"center\",\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"icon-pitch-alignment\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {},\n          auto: {}\n        },\n        default: \"auto\",\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"text-pitch-alignment\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {},\n          auto: {}\n        },\n        default: \"auto\",\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"text-rotation-alignment\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {},\n          auto: {}\n        },\n        default: \"auto\",\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"text-field\": {\n        type: \"formatted\",\n        default: \"\",\n        tokens: !0,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-font\": {\n        type: \"array\",\n        value: \"string\",\n        default: [\"Open Sans Regular\", \"Arial Unicode MS Regular\"],\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-size\": {\n        type: \"number\",\n        default: 16,\n        minimum: 0,\n        units: \"pixels\",\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-max-width\": {\n        type: \"number\",\n        default: 10,\n        minimum: 0,\n        units: \"ems\",\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-line-height\": {\n        type: \"number\",\n        default: 1.2,\n        units: \"ems\",\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"text-letter-spacing\": {\n        type: \"number\",\n        default: 0,\n        units: \"ems\",\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-justify\": {\n        type: \"enum\",\n        values: {\n          auto: {},\n          left: {},\n          center: {},\n          right: {}\n        },\n        default: \"center\",\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-radial-offset\": {\n        type: \"number\",\n        units: \"ems\",\n        default: 0,\n        requires: [\"text-field\"],\n        \"property-type\": \"data-driven\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\"]\n        }\n      },\n      \"text-variable-anchor\": {\n        type: \"array\",\n        value: \"enum\",\n        values: {\n          center: {},\n          left: {},\n          right: {},\n          top: {},\n          bottom: {},\n          \"top-left\": {},\n          \"top-right\": {},\n          \"bottom-left\": {},\n          \"bottom-right\": {}\n        },\n        requires: [\"text-field\", {\n          \"symbol-placement\": [\"point\"]\n        }],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"text-anchor\": {\n        type: \"enum\",\n        values: {\n          center: {},\n          left: {},\n          right: {},\n          top: {},\n          bottom: {},\n          \"top-left\": {},\n          \"top-right\": {},\n          \"bottom-left\": {},\n          \"bottom-right\": {}\n        },\n        default: \"center\",\n        requires: [\"text-field\", {\n          \"!\": \"text-variable-anchor\"\n        }],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-max-angle\": {\n        type: \"number\",\n        default: 45,\n        units: \"degrees\",\n        requires: [\"text-field\", {\n          \"symbol-placement\": [\"line\", \"line-center\"]\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"text-writing-mode\": {\n        type: \"array\",\n        value: \"enum\",\n        values: {\n          horizontal: {},\n          vertical: {}\n        },\n        requires: [\"text-field\", {\n          \"symbol-placement\": [\"point\"]\n        }],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"text-rotate\": {\n        type: \"number\",\n        default: 0,\n        period: 360,\n        units: \"degrees\",\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-padding\": {\n        type: \"number\",\n        default: 2,\n        minimum: 0,\n        units: \"pixels\",\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"text-keep-upright\": {\n        type: \"boolean\",\n        default: !0,\n        requires: [\"text-field\", {\n          \"text-rotation-alignment\": \"map\"\n        }, {\n          \"symbol-placement\": [\"line\", \"line-center\"]\n        }],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"text-transform\": {\n        type: \"enum\",\n        values: {\n          none: {},\n          uppercase: {},\n          lowercase: {}\n        },\n        default: \"none\",\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-offset\": {\n        type: \"array\",\n        value: \"number\",\n        units: \"ems\",\n        length: 2,\n        default: [0, 0],\n        requires: [\"text-field\", {\n          \"!\": \"text-radial-offset\"\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-allow-overlap\": {\n        type: \"boolean\",\n        default: !1,\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"text-ignore-placement\": {\n        type: \"boolean\",\n        default: !1,\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"text-optional\": {\n        type: \"boolean\",\n        default: !1,\n        requires: [\"text-field\", \"icon-image\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      visibility: {\n        type: \"enum\",\n        values: {\n          visible: {},\n          none: {}\n        },\n        default: \"visible\",\n        \"property-type\": \"constant\"\n      }\n    },\n    layout_raster: {\n      visibility: {\n        type: \"enum\",\n        values: {\n          visible: {},\n          none: {}\n        },\n        default: \"visible\",\n        \"property-type\": \"constant\"\n      }\n    },\n    layout_hillshade: {\n      visibility: {\n        type: \"enum\",\n        values: {\n          visible: {},\n          none: {}\n        },\n        default: \"visible\",\n        \"property-type\": \"constant\"\n      }\n    },\n    filter: {\n      type: \"array\",\n      value: \"*\"\n    },\n    filter_operator: {\n      type: \"enum\",\n      values: {\n        \"==\": {},\n        \"!=\": {},\n        \">\": {},\n        \">=\": {},\n        \"<\": {},\n        \"<=\": {},\n        in: {},\n        \"!in\": {},\n        all: {},\n        any: {},\n        none: {},\n        has: {},\n        \"!has\": {},\n        within: {}\n      }\n    },\n    geometry_type: {\n      type: \"enum\",\n      values: {\n        Point: {},\n        LineString: {},\n        Polygon: {}\n      }\n    },\n    function: {\n      expression: {\n        type: \"expression\"\n      },\n      stops: {\n        type: \"array\",\n        value: \"function_stop\"\n      },\n      base: {\n        type: \"number\",\n        default: 1,\n        minimum: 0\n      },\n      property: {\n        type: \"string\",\n        default: \"$zoom\"\n      },\n      type: {\n        type: \"enum\",\n        values: {\n          identity: {},\n          exponential: {},\n          interval: {},\n          categorical: {}\n        },\n        default: \"exponential\"\n      },\n      colorSpace: {\n        type: \"enum\",\n        values: {\n          rgb: {},\n          lab: {},\n          hcl: {}\n        },\n        default: \"rgb\"\n      },\n      default: {\n        type: \"*\",\n        required: !1\n      }\n    },\n    function_stop: {\n      type: \"array\",\n      minimum: 0,\n      maximum: 24,\n      value: [\"number\", \"color\"],\n      length: 2\n    },\n    expression: {\n      type: \"array\",\n      value: \"*\",\n      minimum: 1\n    },\n    light: {\n      anchor: {\n        type: \"enum\",\n        default: \"viewport\",\n        values: {\n          map: {},\n          viewport: {}\n        },\n        \"property-type\": \"data-constant\",\n        transition: !1,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        }\n      },\n      position: {\n        type: \"array\",\n        default: [1.15, 210, 30],\n        length: 3,\n        value: \"number\",\n        \"property-type\": \"data-constant\",\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        }\n      },\n      color: {\n        type: \"color\",\n        \"property-type\": \"data-constant\",\n        default: \"#ffffff\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        transition: !0\n      },\n      intensity: {\n        type: \"number\",\n        \"property-type\": \"data-constant\",\n        default: .5,\n        minimum: 0,\n        maximum: 1,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        transition: !0\n      }\n    },\n    terrain: {\n      source: {\n        type: \"string\",\n        required: !0\n      },\n      exaggeration: {\n        type: \"number\",\n        \"property-type\": \"data-constant\",\n        default: 1,\n        minimum: 0,\n        maximum: 1e3,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        transition: !0\n      }\n    },\n    paint: [\"paint_fill\", \"paint_line\", \"paint_circle\", \"paint_heatmap\", \"paint_fill-extrusion\", \"paint_symbol\", \"paint_raster\", \"paint_hillshade\", \"paint_background\", \"paint_sky\"],\n    paint_fill: {\n      \"fill-antialias\": {\n        type: \"boolean\",\n        default: !0,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"fill-opacity\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"fill-color\": {\n        type: \"color\",\n        default: \"#000000\",\n        transition: !0,\n        requires: [{\n          \"!\": \"fill-pattern\"\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"fill-outline-color\": {\n        type: \"color\",\n        transition: !0,\n        requires: [{\n          \"!\": \"fill-pattern\"\n        }, {\n          \"fill-antialias\": !0\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"fill-translate\": {\n        type: \"array\",\n        value: \"number\",\n        length: 2,\n        default: [0, 0],\n        transition: !0,\n        units: \"pixels\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"fill-translate-anchor\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {}\n        },\n        default: \"map\",\n        requires: [\"fill-translate\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"fill-pattern\": {\n        type: \"resolvedImage\",\n        transition: !0,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"cross-faded-data-driven\"\n      }\n    },\n    \"paint_fill-extrusion\": {\n      \"fill-extrusion-opacity\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"fill-extrusion-color\": {\n        type: \"color\",\n        default: \"#000000\",\n        transition: !0,\n        requires: [{\n          \"!\": \"fill-extrusion-pattern\"\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"fill-extrusion-translate\": {\n        type: \"array\",\n        value: \"number\",\n        length: 2,\n        default: [0, 0],\n        transition: !0,\n        units: \"pixels\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"fill-extrusion-translate-anchor\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {}\n        },\n        default: \"map\",\n        requires: [\"fill-extrusion-translate\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"fill-extrusion-pattern\": {\n        type: \"resolvedImage\",\n        transition: !0,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"cross-faded-data-driven\"\n      },\n      \"fill-extrusion-height\": {\n        type: \"number\",\n        default: 0,\n        minimum: 0,\n        units: \"meters\",\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"fill-extrusion-base\": {\n        type: \"number\",\n        default: 0,\n        minimum: 0,\n        units: \"meters\",\n        transition: !0,\n        requires: [\"fill-extrusion-height\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"fill-extrusion-vertical-gradient\": {\n        type: \"boolean\",\n        default: !0,\n        transition: !1,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      }\n    },\n    paint_line: {\n      \"line-opacity\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"line-color\": {\n        type: \"color\",\n        default: \"#000000\",\n        transition: !0,\n        requires: [{\n          \"!\": \"line-pattern\"\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"line-translate\": {\n        type: \"array\",\n        value: \"number\",\n        length: 2,\n        default: [0, 0],\n        transition: !0,\n        units: \"pixels\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"line-translate-anchor\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {}\n        },\n        default: \"map\",\n        requires: [\"line-translate\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"line-width\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        transition: !0,\n        units: \"pixels\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"line-gap-width\": {\n        type: \"number\",\n        default: 0,\n        minimum: 0,\n        transition: !0,\n        units: \"pixels\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"line-offset\": {\n        type: \"number\",\n        default: 0,\n        transition: !0,\n        units: \"pixels\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"line-blur\": {\n        type: \"number\",\n        default: 0,\n        minimum: 0,\n        transition: !0,\n        units: \"pixels\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"line-dasharray\": {\n        type: \"array\",\n        value: \"number\",\n        minimum: 0,\n        transition: !0,\n        units: \"line widths\",\n        requires: [{\n          \"!\": \"line-pattern\"\n        }],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"cross-faded\"\n      },\n      \"line-pattern\": {\n        type: \"resolvedImage\",\n        transition: !0,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"cross-faded-data-driven\"\n      },\n      \"line-gradient\": {\n        type: \"color\",\n        transition: !1,\n        requires: [{\n          \"!\": \"line-dasharray\"\n        }, {\n          \"!\": \"line-pattern\"\n        }, {\n          source: \"geojson\",\n          has: {\n            lineMetrics: !0\n          }\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"line-progress\"]\n        },\n        \"property-type\": \"color-ramp\"\n      }\n    },\n    paint_circle: {\n      \"circle-radius\": {\n        type: \"number\",\n        default: 5,\n        minimum: 0,\n        transition: !0,\n        units: \"pixels\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"circle-color\": {\n        type: \"color\",\n        default: \"#000000\",\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"circle-blur\": {\n        type: \"number\",\n        default: 0,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"circle-opacity\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"circle-translate\": {\n        type: \"array\",\n        value: \"number\",\n        length: 2,\n        default: [0, 0],\n        transition: !0,\n        units: \"pixels\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"circle-translate-anchor\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {}\n        },\n        default: \"map\",\n        requires: [\"circle-translate\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"circle-pitch-scale\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {}\n        },\n        default: \"map\",\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"circle-pitch-alignment\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {}\n        },\n        default: \"viewport\",\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"circle-stroke-width\": {\n        type: \"number\",\n        default: 0,\n        minimum: 0,\n        transition: !0,\n        units: \"pixels\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"circle-stroke-color\": {\n        type: \"color\",\n        default: \"#000000\",\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"circle-stroke-opacity\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      }\n    },\n    paint_heatmap: {\n      \"heatmap-radius\": {\n        type: \"number\",\n        default: 30,\n        minimum: 1,\n        transition: !0,\n        units: \"pixels\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"heatmap-weight\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        transition: !1,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"heatmap-intensity\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"heatmap-color\": {\n        type: \"color\",\n        default: [\"interpolate\", [\"linear\"], [\"heatmap-density\"], 0, \"rgba(0, 0, 255, 0)\", .1, \"royalblue\", .3, \"cyan\", .5, \"lime\", .7, \"yellow\", 1, \"red\"],\n        transition: !1,\n        expression: {\n          interpolated: !0,\n          parameters: [\"heatmap-density\"]\n        },\n        \"property-type\": \"color-ramp\"\n      },\n      \"heatmap-opacity\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      }\n    },\n    paint_symbol: {\n      \"icon-opacity\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"icon-color\": {\n        type: \"color\",\n        default: \"#000000\",\n        transition: !0,\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"icon-halo-color\": {\n        type: \"color\",\n        default: \"rgba(0, 0, 0, 0)\",\n        transition: !0,\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"icon-halo-width\": {\n        type: \"number\",\n        default: 0,\n        minimum: 0,\n        transition: !0,\n        units: \"pixels\",\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"icon-halo-blur\": {\n        type: \"number\",\n        default: 0,\n        minimum: 0,\n        transition: !0,\n        units: \"pixels\",\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"icon-translate\": {\n        type: \"array\",\n        value: \"number\",\n        length: 2,\n        default: [0, 0],\n        transition: !0,\n        units: \"pixels\",\n        requires: [\"icon-image\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"icon-translate-anchor\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {}\n        },\n        default: \"map\",\n        requires: [\"icon-image\", \"icon-translate\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"text-opacity\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-color\": {\n        type: \"color\",\n        default: \"#000000\",\n        transition: !0,\n        overridable: !0,\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-halo-color\": {\n        type: \"color\",\n        default: \"rgba(0, 0, 0, 0)\",\n        transition: !0,\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-halo-width\": {\n        type: \"number\",\n        default: 0,\n        minimum: 0,\n        transition: !0,\n        units: \"pixels\",\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-halo-blur\": {\n        type: \"number\",\n        default: 0,\n        minimum: 0,\n        transition: !0,\n        units: \"pixels\",\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"text-translate\": {\n        type: \"array\",\n        value: \"number\",\n        length: 2,\n        default: [0, 0],\n        transition: !0,\n        units: \"pixels\",\n        requires: [\"text-field\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"text-translate-anchor\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {}\n        },\n        default: \"map\",\n        requires: [\"text-field\", \"text-translate\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      }\n    },\n    paint_raster: {\n      \"raster-opacity\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"raster-hue-rotate\": {\n        type: \"number\",\n        default: 0,\n        period: 360,\n        transition: !0,\n        units: \"degrees\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"raster-brightness-min\": {\n        type: \"number\",\n        default: 0,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"raster-brightness-max\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"raster-saturation\": {\n        type: \"number\",\n        default: 0,\n        minimum: -1,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"raster-contrast\": {\n        type: \"number\",\n        default: 0,\n        minimum: -1,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"raster-resampling\": {\n        type: \"enum\",\n        values: {\n          linear: {},\n          nearest: {}\n        },\n        default: \"linear\",\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"raster-fade-duration\": {\n        type: \"number\",\n        default: 300,\n        minimum: 0,\n        transition: !1,\n        units: \"milliseconds\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      }\n    },\n    paint_hillshade: {\n      \"hillshade-illumination-direction\": {\n        type: \"number\",\n        default: 335,\n        minimum: 0,\n        maximum: 359,\n        transition: !1,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"hillshade-illumination-anchor\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {}\n        },\n        default: \"viewport\",\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"hillshade-exaggeration\": {\n        type: \"number\",\n        default: .5,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"hillshade-shadow-color\": {\n        type: \"color\",\n        default: \"#000000\",\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"hillshade-highlight-color\": {\n        type: \"color\",\n        default: \"#FFFFFF\",\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"hillshade-accent-color\": {\n        type: \"color\",\n        default: \"#000000\",\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      }\n    },\n    paint_background: {\n      \"background-color\": {\n        type: \"color\",\n        default: \"#000000\",\n        transition: !0,\n        requires: [{\n          \"!\": \"background-pattern\"\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"background-pattern\": {\n        type: \"resolvedImage\",\n        transition: !0,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"cross-faded\"\n      },\n      \"background-opacity\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      }\n    },\n    paint_sky: {\n      \"sky-type\": {\n        type: \"enum\",\n        values: {\n          gradient: {},\n          atmosphere: {}\n        },\n        default: \"atmosphere\",\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"sky-atmosphere-sun\": {\n        type: \"array\",\n        value: \"number\",\n        length: 2,\n        units: \"degrees\",\n        minimum: [0, 0],\n        maximum: [360, 180],\n        transition: !1,\n        requires: [{\n          \"sky-type\": \"atmosphere\"\n        }],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"sky-atmosphere-sun-intensity\": {\n        type: \"number\",\n        requires: [{\n          \"sky-type\": \"atmosphere\"\n        }],\n        default: 10,\n        minimum: 0,\n        maximum: 100,\n        transition: !1,\n        \"property-type\": \"data-constant\"\n      },\n      \"sky-gradient-center\": {\n        type: \"array\",\n        requires: [{\n          \"sky-type\": \"gradient\"\n        }],\n        value: \"number\",\n        default: [0, 0],\n        length: 2,\n        units: \"degrees\",\n        minimum: [0, 0],\n        maximum: [360, 180],\n        transition: !1,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"sky-gradient-radius\": {\n        type: \"number\",\n        requires: [{\n          \"sky-type\": \"gradient\"\n        }],\n        default: 90,\n        minimum: 0,\n        maximum: 180,\n        transition: !1,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"sky-gradient\": {\n        type: \"color\",\n        default: [\"interpolate\", [\"linear\"], [\"sky-radial-progress\"], .8, \"#87ceeb\", 1, \"white\"],\n        transition: !1,\n        requires: [{\n          \"sky-type\": \"gradient\"\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"sky-radial-progress\"]\n        },\n        \"property-type\": \"color-ramp\"\n      },\n      \"sky-atmosphere-halo-color\": {\n        type: \"color\",\n        default: \"white\",\n        transition: !1,\n        requires: [{\n          \"sky-type\": \"atmosphere\"\n        }],\n        \"property-type\": \"data-constant\"\n      },\n      \"sky-atmosphere-color\": {\n        type: \"color\",\n        default: \"white\",\n        transition: !1,\n        requires: [{\n          \"sky-type\": \"atmosphere\"\n        }],\n        \"property-type\": \"data-constant\"\n      },\n      \"sky-opacity\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      }\n    },\n    transition: {\n      duration: {\n        type: \"number\",\n        default: 300,\n        minimum: 0,\n        units: \"milliseconds\"\n      },\n      delay: {\n        type: \"number\",\n        default: 0,\n        minimum: 0,\n        units: \"milliseconds\"\n      }\n    },\n    \"property-type\": {\n      \"data-driven\": {\n        type: \"property-type\"\n      },\n      \"cross-faded\": {\n        type: \"property-type\"\n      },\n      \"cross-faded-data-driven\": {\n        type: \"property-type\"\n      },\n      \"color-ramp\": {\n        type: \"property-type\"\n      },\n      \"data-constant\": {\n        type: \"property-type\"\n      },\n      constant: {\n        type: \"property-type\"\n      }\n    },\n    promoteId: {\n      \"*\": {\n        type: \"string\"\n      }\n    }\n  };\n\n  class or {\n    constructor(t, e, r, n) {\n      this.message = (t ? `${t}: ` : \"\") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);\n    }\n\n  }\n\n  function ar(t) {\n    const e = t.value;\n    return e ? [new or(t.key, e, \"constants have been deprecated as of v8\")] : [];\n  }\n\n  function lr(t) {\n    return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;\n  }\n\n  function ur(t) {\n    if (Array.isArray(t)) return t.map(ur);\n\n    if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {\n      const e = {};\n\n      for (const r in t) e[r] = ur(t[r]);\n\n      return e;\n    }\n\n    return lr(t);\n  }\n\n  function cr(t) {\n    const e = t.key,\n          r = t.value,\n          n = t.valueSpec || {},\n          i = t.objectElementValidators || {},\n          s = t.style,\n          o = t.styleSpec;\n    let a = [];\n    const l = Pe(r);\n    if (\"object\" !== l) return [new or(e, r, `object expected, ${l} found`)];\n\n    for (const t in r) {\n      const l = t.split(\".\")[0],\n            u = n[l] || n[\"*\"];\n      let c;\n      if (i[l]) c = i[l];else if (n[l]) c = Fr;else if (i[\"*\"]) c = i[\"*\"];else {\n        if (!n[\"*\"]) {\n          a.push(new or(e, r[t], `unknown property \"${t}\"`));\n          continue;\n        }\n\n        c = Fr;\n      }\n      a = a.concat(c({\n        key: (e ? `${e}.` : e) + t,\n        value: r[t],\n        valueSpec: u,\n        style: s,\n        styleSpec: o,\n        object: r,\n        objectKey: t\n      }, r));\n    }\n\n    for (const t in n) i[t] || n[t].required && void 0 === n[t].default && void 0 === r[t] && a.push(new or(e, r, `missing required property \"${t}\"`));\n\n    return a;\n  }\n\n  function hr(t) {\n    const e = t.value,\n          r = t.valueSpec,\n          n = t.style,\n          i = t.styleSpec,\n          s = t.key,\n          o = t.arrayElementValidator || Fr;\n    if (\"array\" !== Pe(e)) return [new or(s, e, `array expected, ${Pe(e)} found`)];\n    if (r.length && e.length !== r.length) return [new or(s, e, `array length ${r.length} expected, length ${e.length} found`)];\n    if (r[\"min-length\"] && e.length < r[\"min-length\"]) return [new or(s, e, `array length at least ${r[\"min-length\"]} expected, length ${e.length} found`)];\n    let a = {\n      type: r.value,\n      values: r.values,\n      minimum: r.minimum,\n      maximum: r.maximum\n    };\n    i.$version < 7 && (a.function = r.function), \"object\" === Pe(r.value) && (a = r.value);\n    let l = [];\n\n    for (let t = 0; t < e.length; t++) l = l.concat(o({\n      array: e,\n      arrayIndex: t,\n      value: e[t],\n      valueSpec: a,\n      style: n,\n      styleSpec: i,\n      key: `${s}[${t}]`\n    }));\n\n    return l;\n  }\n\n  function pr(t) {\n    const e = t.key,\n          r = t.value,\n          n = t.valueSpec;\n    let i = Pe(r);\n    if (\"number\" === i && r != r && (i = \"NaN\"), \"number\" !== i) return [new or(e, r, `number expected, ${i} found`)];\n\n    if (\"minimum\" in n) {\n      let i = n.minimum;\n      if (\"array\" === Pe(n.minimum) && (i = n.minimum[t.arrayIndex]), r < i) return [new or(e, r, `${r} is less than the minimum value ${i}`)];\n    }\n\n    if (\"maximum\" in n) {\n      let i = n.maximum;\n      if (\"array\" === Pe(n.maximum) && (i = n.maximum[t.arrayIndex]), r > i) return [new or(e, r, `${r} is greater than the maximum value ${i}`)];\n    }\n\n    return [];\n  }\n\n  function fr(t) {\n    const e = t.valueSpec,\n          r = lr(t.value.type);\n    let n,\n        i,\n        s,\n        o = {};\n    const a = \"categorical\" !== r && void 0 === t.value.property,\n          l = !a,\n          u = \"array\" === Pe(t.value.stops) && \"array\" === Pe(t.value.stops[0]) && \"object\" === Pe(t.value.stops[0][0]),\n          c = cr({\n      key: t.key,\n      value: t.value,\n      valueSpec: t.styleSpec.function,\n      style: t.style,\n      styleSpec: t.styleSpec,\n      objectElementValidators: {\n        stops: function (t) {\n          if (\"identity\" === r) return [new or(t.key, t.value, 'identity function may not have a \"stops\" property')];\n          let e = [];\n          const n = t.value;\n          return e = e.concat(hr({\n            key: t.key,\n            value: n,\n            valueSpec: t.valueSpec,\n            style: t.style,\n            styleSpec: t.styleSpec,\n            arrayElementValidator: h\n          })), \"array\" === Pe(n) && 0 === n.length && e.push(new or(t.key, n, \"array must have at least one stop\")), e;\n        },\n        default: function (t) {\n          return Fr({\n            key: t.key,\n            value: t.value,\n            valueSpec: e,\n            style: t.style,\n            styleSpec: t.styleSpec\n          });\n        }\n      }\n    });\n    return \"identity\" === r && a && c.push(new or(t.key, t.value, 'missing required property \"property\"')), \"identity\" === r || t.value.stops || c.push(new or(t.key, t.value, 'missing required property \"stops\"')), \"exponential\" === r && t.valueSpec.expression && !Be(t.valueSpec) && c.push(new or(t.key, t.value, \"exponential functions not supported\")), t.styleSpec.$version >= 8 && (l && !ze(t.valueSpec) ? c.push(new or(t.key, t.value, \"property functions not supported\")) : a && !Me(t.valueSpec) && c.push(new or(t.key, t.value, \"zoom functions not supported\"))), \"categorical\" !== r && !u || void 0 !== t.value.property || c.push(new or(t.key, t.value, '\"property\" property is required')), c;\n\n    function h(t) {\n      let r = [];\n      const n = t.value,\n            a = t.key;\n      if (\"array\" !== Pe(n)) return [new or(a, n, `array expected, ${Pe(n)} found`)];\n      if (2 !== n.length) return [new or(a, n, `array length 2 expected, length ${n.length} found`)];\n\n      if (u) {\n        if (\"object\" !== Pe(n[0])) return [new or(a, n, `object expected, ${Pe(n[0])} found`)];\n        if (void 0 === n[0].zoom) return [new or(a, n, \"object stop key must have zoom\")];\n        if (void 0 === n[0].value) return [new or(a, n, \"object stop key must have value\")];\n        if (s && s > lr(n[0].zoom)) return [new or(a, n[0].zoom, \"stop zoom values must appear in ascending order\")];\n        lr(n[0].zoom) !== s && (s = lr(n[0].zoom), i = void 0, o = {}), r = r.concat(cr({\n          key: `${a}[0]`,\n          value: n[0],\n          valueSpec: {\n            zoom: {}\n          },\n          style: t.style,\n          styleSpec: t.styleSpec,\n          objectElementValidators: {\n            zoom: pr,\n            value: p\n          }\n        }));\n      } else r = r.concat(p({\n        key: `${a}[0]`,\n        value: n[0],\n        valueSpec: {},\n        style: t.style,\n        styleSpec: t.styleSpec\n      }, n));\n\n      return $e(ur(n[1])) ? r.concat([new or(`${a}[1]`, n[1], \"expressions are not allowed in function stops.\")]) : r.concat(Fr({\n        key: `${a}[1]`,\n        value: n[1],\n        valueSpec: e,\n        style: t.style,\n        styleSpec: t.styleSpec\n      }));\n    }\n\n    function p(t, s) {\n      const a = Pe(t.value),\n            l = lr(t.value),\n            u = null !== t.value ? t.value : s;\n\n      if (n) {\n        if (a !== n) return [new or(t.key, u, `${a} stop domain type must match previous stop domain type ${n}`)];\n      } else n = a;\n\n      if (\"number\" !== a && \"string\" !== a && \"boolean\" !== a) return [new or(t.key, u, \"stop domain value must be a number, string, or boolean\")];\n\n      if (\"number\" !== a && \"categorical\" !== r) {\n        let n = `number expected, ${a} found`;\n        return ze(e) && void 0 === r && (n += '\\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`.'), [new or(t.key, u, n)];\n      }\n\n      return \"categorical\" !== r || \"number\" !== a || isFinite(l) && Math.floor(l) === l ? \"categorical\" !== r && \"number\" === a && void 0 !== i && l < i ? [new or(t.key, u, \"stop domain values must appear in ascending order\")] : (i = l, \"categorical\" === r && l in o ? [new or(t.key, u, \"stop domain values must be unique\")] : (o[l] = !0, [])) : [new or(t.key, u, `integer expected, found ${l}`)];\n    }\n  }\n\n  function dr(t) {\n    const e = (\"property\" === t.expressionContext ? Ne : Re)(ur(t.value), t.valueSpec);\n    if (\"error\" === e.result) return e.value.map(e => new or(`${t.key}${e.key}`, t.value, e.message));\n    const r = e.value.expression || e.value._styleExpression.expression;\n    if (\"property\" === t.expressionContext && \"text-font\" === t.propertyKey && !r.outputDefined()) return [new or(t.key, t.value, `Invalid data expression for \"${t.propertyKey}\". Output values must be contained as literals within the expression.`)];\n    if (\"property\" === t.expressionContext && \"layout\" === t.propertyType && !Tt(r)) return [new or(t.key, t.value, '\"feature-state\" data expressions are not supported with layout properties.')];\n    if (\"filter\" === t.expressionContext && !Tt(r)) return [new or(t.key, t.value, '\"feature-state\" data expressions are not supported with filters.')];\n\n    if (t.expressionContext && 0 === t.expressionContext.indexOf(\"cluster\")) {\n      if (!Et(r, [\"zoom\", \"feature-state\"])) return [new or(t.key, t.value, '\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.')];\n      if (\"cluster-initial\" === t.expressionContext && !Vt(r)) return [new or(t.key, t.value, \"Feature data expressions are not supported with initial expression part of cluster properties.\")];\n    }\n\n    return [];\n  }\n\n  function yr(t) {\n    const e = t.key,\n          r = t.value,\n          n = t.valueSpec,\n          i = [];\n    return Array.isArray(n.values) ? -1 === n.values.indexOf(lr(r)) && i.push(new or(e, r, `expected one of [${n.values.join(\", \")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(n.values).indexOf(lr(r)) && i.push(new or(e, r, `expected one of [${Object.keys(n.values).join(\", \")}], ${JSON.stringify(r)} found`)), i;\n  }\n\n  function mr(t) {\n    if (!0 === t || !1 === t) return !0;\n    if (!Array.isArray(t) || 0 === t.length) return !1;\n\n    switch (t[0]) {\n      case \"has\":\n        return t.length >= 2 && \"$id\" !== t[1] && \"$type\" !== t[1];\n\n      case \"in\":\n        return t.length >= 3 && (\"string\" != typeof t[1] || Array.isArray(t[2]));\n\n      case \"!in\":\n      case \"!has\":\n      case \"none\":\n        return !1;\n\n      case \"==\":\n      case \"!=\":\n      case \">\":\n      case \">=\":\n      case \"<\":\n      case \"<=\":\n        return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);\n\n      case \"any\":\n      case \"all\":\n        for (const e of t.slice(1)) if (!mr(e) && \"boolean\" != typeof e) return !1;\n\n        return !0;\n\n      default:\n        return !0;\n    }\n  }\n\n  const gr = {\n    type: \"boolean\",\n    default: !1,\n    transition: !1,\n    \"property-type\": \"data-driven\",\n    expression: {\n      interpolated: !1,\n      parameters: [\"zoom\", \"feature\"]\n    }\n  };\n\n  function xr(t) {\n    if (null == t) return {\n      filter: () => !0,\n      needGeometry: !1\n    };\n    mr(t) || (t = br(t));\n    const e = Re(t, gr);\n    if (\"error\" === e.result) throw new Error(e.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n    return {\n      filter: (t, r, n) => e.value.evaluate(t, r, {}, n),\n      needGeometry: function t(e) {\n        if (!Array.isArray(e)) return !1;\n        if (\"within\" === e[0]) return !0;\n\n        for (let r = 1; r < e.length; r++) if (t(e[r])) return !0;\n\n        return !1;\n      }(t)\n    };\n  }\n\n  function vr(t, e) {\n    return t < e ? -1 : t > e ? 1 : 0;\n  }\n\n  function br(t) {\n    if (!t) return !0;\n    const e = t[0];\n    return t.length <= 1 ? \"any\" !== e : \"==\" === e ? wr(t[1], t[2], \"==\") : \"!=\" === e ? Sr(wr(t[1], t[2], \"==\")) : \"<\" === e || \">\" === e || \"<=\" === e || \">=\" === e ? wr(t[1], t[2], e) : \"any\" === e ? (r = t.slice(1), [\"any\"].concat(r.map(br))) : \"all\" === e ? [\"all\"].concat(t.slice(1).map(br)) : \"none\" === e ? [\"all\"].concat(t.slice(1).map(br).map(Sr)) : \"in\" === e ? _r(t[1], t.slice(2)) : \"!in\" === e ? Sr(_r(t[1], t.slice(2))) : \"has\" === e ? kr(t[1]) : \"!has\" === e ? Sr(kr(t[1])) : \"within\" !== e || t;\n    var r;\n  }\n\n  function wr(t, e, r) {\n    switch (t) {\n      case \"$type\":\n        return [`filter-type-${r}`, e];\n\n      case \"$id\":\n        return [`filter-id-${r}`, e];\n\n      default:\n        return [`filter-${r}`, t, e];\n    }\n  }\n\n  function _r(t, e) {\n    if (0 === e.length) return !1;\n\n    switch (t) {\n      case \"$type\":\n        return [\"filter-type-in\", [\"literal\", e]];\n\n      case \"$id\":\n        return [\"filter-id-in\", [\"literal\", e]];\n\n      default:\n        return e.length > 200 && !e.some(t => typeof t != typeof e[0]) ? [\"filter-in-large\", t, [\"literal\", e.sort(vr)]] : [\"filter-in-small\", t, [\"literal\", e]];\n    }\n  }\n\n  function kr(t) {\n    switch (t) {\n      case \"$type\":\n        return !0;\n\n      case \"$id\":\n        return [\"filter-has-id\"];\n\n      default:\n        return [\"filter-has\", t];\n    }\n  }\n\n  function Sr(t) {\n    return [\"!\", t];\n  }\n\n  function Ar(t) {\n    return mr(ur(t.value)) ? dr(C({}, t, {\n      expressionContext: \"filter\",\n      valueSpec: {\n        value: \"boolean\"\n      }\n    })) : function t(e) {\n      const r = e.value,\n            n = e.key;\n      if (\"array\" !== Pe(r)) return [new or(n, r, `array expected, ${Pe(r)} found`)];\n      const i = e.styleSpec;\n      let s,\n          o = [];\n      if (r.length < 1) return [new or(n, r, \"filter array must have at least 1 element\")];\n\n      switch (o = o.concat(yr({\n        key: `${n}[0]`,\n        value: r[0],\n        valueSpec: i.filter_operator,\n        style: e.style,\n        styleSpec: e.styleSpec\n      })), lr(r[0])) {\n        case \"<\":\n        case \"<=\":\n        case \">\":\n        case \">=\":\n          r.length >= 2 && \"$type\" === lr(r[1]) && o.push(new or(n, r, `\"$type\" cannot be use with operator \"${r[0]}\"`));\n\n        case \"==\":\n        case \"!=\":\n          3 !== r.length && o.push(new or(n, r, `filter array for operator \"${r[0]}\" must have 3 elements`));\n\n        case \"in\":\n        case \"!in\":\n          r.length >= 2 && (s = Pe(r[1]), \"string\" !== s && o.push(new or(`${n}[1]`, r[1], `string expected, ${s} found`)));\n\n          for (let t = 2; t < r.length; t++) s = Pe(r[t]), \"$type\" === lr(r[1]) ? o = o.concat(yr({\n            key: `${n}[${t}]`,\n            value: r[t],\n            valueSpec: i.geometry_type,\n            style: e.style,\n            styleSpec: e.styleSpec\n          })) : \"string\" !== s && \"number\" !== s && \"boolean\" !== s && o.push(new or(`${n}[${t}]`, r[t], `string, number, or boolean expected, ${s} found`));\n\n          break;\n\n        case \"any\":\n        case \"all\":\n        case \"none\":\n          for (let i = 1; i < r.length; i++) o = o.concat(t({\n            key: `${n}[${i}]`,\n            value: r[i],\n            style: e.style,\n            styleSpec: e.styleSpec\n          }));\n\n          break;\n\n        case \"has\":\n        case \"!has\":\n          s = Pe(r[1]), 2 !== r.length ? o.push(new or(n, r, `filter array for \"${r[0]}\" operator must have 2 elements`)) : \"string\" !== s && o.push(new or(`${n}[1]`, r[1], `string expected, ${s} found`));\n          break;\n\n        case \"within\":\n          s = Pe(r[1]), 2 !== r.length ? o.push(new or(n, r, `filter array for \"${r[0]}\" operator must have 2 elements`)) : \"object\" !== s && o.push(new or(`${n}[1]`, r[1], `object expected, ${s} found`));\n      }\n\n      return o;\n    }(t);\n  }\n\n  function Ir(t, e) {\n    const r = t.key,\n          n = t.style,\n          i = t.styleSpec,\n          s = t.value,\n          o = t.objectKey,\n          a = i[`${e}_${t.layerType}`];\n    if (!a) return [];\n    const l = o.match(/^(.*)-transition$/);\n    if (\"paint\" === e && l && a[l[1]] && a[l[1]].transition) return Fr({\n      key: r,\n      value: s,\n      valueSpec: i.transition,\n      style: n,\n      styleSpec: i\n    });\n    const u = t.valueSpec || a[o];\n    if (!u) return [new or(r, s, `unknown property \"${o}\"`)];\n    let c;\n    if (\"string\" === Pe(s) && ze(u) && !u.tokens && (c = /^{([^}]+)}$/.exec(s))) return [new or(r, s, `\"${o}\" does not support interpolation syntax\\n` + `Use an identity property function instead: \\`{ \"type\": \"identity\", \"property\": ${JSON.stringify(c[1])} }\\`.`)];\n    const h = [];\n    return \"symbol\" === t.layerType && (\"text-field\" === o && n && !n.glyphs && h.push(new or(r, s, 'use of \"text-field\" requires a style \"glyphs\" property')), \"text-font\" === o && Ce(ur(s)) && \"identity\" === lr(s.type) && h.push(new or(r, s, '\"text-font\" does not support identity functions'))), h.concat(Fr({\n      key: t.key,\n      value: s,\n      valueSpec: u,\n      style: n,\n      styleSpec: i,\n      expressionContext: \"property\",\n      propertyType: e,\n      propertyKey: o\n    }));\n  }\n\n  function zr(t) {\n    return Ir(t, \"paint\");\n  }\n\n  function Mr(t) {\n    return Ir(t, \"layout\");\n  }\n\n  function Br(t) {\n    let e = [];\n    const r = t.value,\n          n = t.key,\n          i = t.style,\n          s = t.styleSpec;\n    r.type || r.ref || e.push(new or(n, r, 'either \"type\" or \"ref\" is required'));\n    let o = lr(r.type);\n    const a = lr(r.ref);\n\n    if (r.id) {\n      const s = lr(r.id);\n\n      for (let o = 0; o < t.arrayIndex; o++) {\n        const t = i.layers[o];\n        lr(t.id) === s && e.push(new or(n, r.id, `duplicate layer id \"${r.id}\", previously used at line ${t.id.__line__}`));\n      }\n    }\n\n    if (\"ref\" in r) {\n      let t;\n      [\"type\", \"source\", \"source-layer\", \"filter\", \"layout\"].forEach(t => {\n        t in r && e.push(new or(n, r[t], `\"${t}\" is prohibited for ref layers`));\n      }), i.layers.forEach(e => {\n        lr(e.id) === a && (t = e);\n      }), t ? t.ref ? e.push(new or(n, r.ref, \"ref cannot reference another ref layer\")) : o = lr(t.type) : e.push(new or(n, r.ref, `ref layer \"${a}\" not found`));\n    } else if (\"background\" !== o && \"sky\" !== o) if (r.source) {\n      const t = i.sources && i.sources[r.source],\n            s = t && lr(t.type);\n      t ? \"vector\" === s && \"raster\" === o ? e.push(new or(n, r.source, `layer \"${r.id}\" requires a raster source`)) : \"raster\" === s && \"raster\" !== o ? e.push(new or(n, r.source, `layer \"${r.id}\" requires a vector source`)) : \"vector\" !== s || r[\"source-layer\"] ? \"raster-dem\" === s && \"hillshade\" !== o ? e.push(new or(n, r.source, \"raster-dem source can only be used with layer type 'hillshade'.\")) : \"line\" !== o || !r.paint || !r.paint[\"line-gradient\"] || \"geojson\" === s && t.lineMetrics || e.push(new or(n, r, `layer \"${r.id}\" specifies a line-gradient, which requires a GeoJSON source with \\`lineMetrics\\` enabled.`)) : e.push(new or(n, r, `layer \"${r.id}\" must specify a \"source-layer\"`)) : e.push(new or(n, r.source, `source \"${r.source}\" not found`));\n    } else e.push(new or(n, r, 'missing required property \"source\"'));\n\n    return e = e.concat(cr({\n      key: n,\n      value: r,\n      valueSpec: s.layer,\n      style: t.style,\n      styleSpec: t.styleSpec,\n      objectElementValidators: {\n        \"*\": () => [],\n        type: () => Fr({\n          key: `${n}.type`,\n          value: r.type,\n          valueSpec: s.layer.type,\n          style: t.style,\n          styleSpec: t.styleSpec,\n          object: r,\n          objectKey: \"type\"\n        }),\n        filter: Ar,\n        layout: t => cr({\n          layer: r,\n          key: t.key,\n          value: t.value,\n          style: t.style,\n          styleSpec: t.styleSpec,\n          objectElementValidators: {\n            \"*\": t => Mr(C({\n              layerType: o\n            }, t))\n          }\n        }),\n        paint: t => cr({\n          layer: r,\n          key: t.key,\n          value: t.value,\n          style: t.style,\n          styleSpec: t.styleSpec,\n          objectElementValidators: {\n            \"*\": t => zr(C({\n              layerType: o\n            }, t))\n          }\n        })\n      }\n    })), e;\n  }\n\n  function Pr(t) {\n    const e = t.value,\n          r = t.key,\n          n = Pe(e);\n    return \"string\" !== n ? [new or(r, e, `string expected, ${n} found`)] : [];\n  }\n\n  const Cr = {\n    promoteId: function ({\n      key: t,\n      value: e\n    }) {\n      if (\"string\" === Pe(e)) return Pr({\n        key: t,\n        value: e\n      });\n      {\n        const r = [];\n\n        for (const n in e) r.push(...Pr({\n          key: `${t}.${n}`,\n          value: e[n]\n        }));\n\n        return r;\n      }\n    }\n  };\n\n  function Vr(t) {\n    const e = t.value,\n          r = t.key,\n          n = t.styleSpec,\n          i = t.style;\n    if (!e.type) return [new or(r, e, '\"type\" is required')];\n    const s = lr(e.type);\n    let o;\n\n    switch (s) {\n      case \"vector\":\n      case \"raster\":\n      case \"raster-dem\":\n        return o = cr({\n          key: r,\n          value: e,\n          valueSpec: n[`source_${s.replace(\"-\", \"_\")}`],\n          style: t.style,\n          styleSpec: n,\n          objectElementValidators: Cr\n        }), o;\n\n      case \"geojson\":\n        if (o = cr({\n          key: r,\n          value: e,\n          valueSpec: n.source_geojson,\n          style: i,\n          styleSpec: n,\n          objectElementValidators: Cr\n        }), e.cluster) for (const t in e.clusterProperties) {\n          const [n, i] = e.clusterProperties[t],\n                s = \"string\" == typeof n ? [n, [\"accumulated\"], [\"get\", t]] : n;\n          o.push(...dr({\n            key: `${r}.${t}.map`,\n            value: i,\n            expressionContext: \"cluster-map\"\n          })), o.push(...dr({\n            key: `${r}.${t}.reduce`,\n            value: s,\n            expressionContext: \"cluster-reduce\"\n          }));\n        }\n        return o;\n\n      case \"video\":\n        return cr({\n          key: r,\n          value: e,\n          valueSpec: n.source_video,\n          style: i,\n          styleSpec: n\n        });\n\n      case \"image\":\n        return cr({\n          key: r,\n          value: e,\n          valueSpec: n.source_image,\n          style: i,\n          styleSpec: n\n        });\n\n      case \"canvas\":\n        return [new or(r, null, \"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.\", \"source.canvas\")];\n\n      default:\n        return yr({\n          key: `${r}.type`,\n          value: e.type,\n          valueSpec: {\n            values: [\"vector\", \"raster\", \"raster-dem\", \"geojson\", \"video\", \"image\"]\n          },\n          style: i,\n          styleSpec: n\n        });\n    }\n  }\n\n  function Tr(t) {\n    const e = t.value,\n          r = t.styleSpec,\n          n = r.light,\n          i = t.style;\n    let s = [];\n    const o = Pe(e);\n    if (void 0 === e) return s;\n    if (\"object\" !== o) return s = s.concat([new or(\"light\", e, `object expected, ${o} found`)]), s;\n\n    for (const t in e) {\n      const o = t.match(/^(.*)-transition$/);\n      s = s.concat(o && n[o[1]] && n[o[1]].transition ? Fr({\n        key: t,\n        value: e[t],\n        valueSpec: r.transition,\n        style: i,\n        styleSpec: r\n      }) : n[t] ? Fr({\n        key: t,\n        value: e[t],\n        valueSpec: n[t],\n        style: i,\n        styleSpec: r\n      }) : [new or(t, e[t], `unknown property \"${t}\"`)]);\n    }\n\n    return s;\n  }\n\n  function Er(t) {\n    const e = t.value,\n          r = t.key,\n          n = t.style,\n          i = t.styleSpec,\n          s = i.terrain;\n    let o = [];\n    const a = Pe(e);\n    if (void 0 === e) return o;\n    if (\"object\" !== a) return o = o.concat([new or(\"terrain\", e, `object expected, ${a} found`)]), o;\n\n    for (const t in e) {\n      const r = t.match(/^(.*)-transition$/);\n      o = o.concat(r && s[r[1]] && s[r[1]].transition ? Fr({\n        key: t,\n        value: e[t],\n        valueSpec: i.transition,\n        style: n,\n        styleSpec: i\n      }) : s[t] ? Fr({\n        key: t,\n        value: e[t],\n        valueSpec: s[t],\n        style: n,\n        styleSpec: i\n      }) : [new or(t, e[t], `unknown property \"${t}\"`)]);\n    }\n\n    if (e.source) {\n      const t = n.sources && n.sources[e.source],\n            i = t && lr(t.type);\n      t ? \"raster-dem\" !== i && o.push(new or(r, e.source, `terrain cannot be used with a source of type ${i}, it only be used with a \"raster-dem\" source type`)) : o.push(new or(r, e.source, `source \"${e.source}\" not found`));\n    } else o.push(new or(r, e, 'terrain is missing required property \"source\"'));\n\n    return o;\n  }\n\n  const Dr = {\n    \"*\": () => [],\n    array: hr,\n    boolean: function (t) {\n      const e = t.value,\n            r = t.key,\n            n = Pe(e);\n      return \"boolean\" !== n ? [new or(r, e, `boolean expected, ${n} found`)] : [];\n    },\n    number: pr,\n    color: function (t) {\n      const e = t.key,\n            r = t.value,\n            n = Pe(r);\n      return \"string\" !== n ? [new or(e, r, `color expected, ${n} found`)] : null === B(r) ? [new or(e, r, `color expected, \"${r}\" found`)] : [];\n    },\n    constants: ar,\n    enum: yr,\n    filter: Ar,\n    function: fr,\n    layer: Br,\n    object: cr,\n    source: Vr,\n    light: Tr,\n    terrain: Er,\n    string: Pr,\n    formatted: function (t) {\n      return 0 === Pr(t).length ? [] : dr(t);\n    },\n    resolvedImage: function (t) {\n      return 0 === Pr(t).length ? [] : dr(t);\n    }\n  };\n\n  function Fr(t) {\n    const e = t.value,\n          r = t.valueSpec,\n          n = t.styleSpec;\n    return r.expression && Ce(lr(e)) ? fr(t) : r.expression && $e(ur(e)) ? dr(t) : r.type && Dr[r.type] ? Dr[r.type](t) : cr(C({}, t, {\n      valueSpec: r.type ? n[r.type] : r\n    }));\n  }\n\n  function Lr(t) {\n    const e = t.value,\n          r = t.key,\n          n = Pr(t);\n    return n.length || (-1 === e.indexOf(\"{fontstack}\") && n.push(new or(r, e, '\"glyphs\" url must include a \"{fontstack}\" token')), -1 === e.indexOf(\"{range}\") && n.push(new or(r, e, '\"glyphs\" url must include a \"{range}\" token'))), n;\n  }\n\n  function Or(t, e = sr) {\n    let r = [];\n    return r = r.concat(Fr({\n      key: \"\",\n      value: t,\n      valueSpec: e.$root,\n      styleSpec: e,\n      style: t,\n      objectElementValidators: {\n        glyphs: Lr,\n        \"*\": () => []\n      }\n    })), t.constants && (r = r.concat(ar({\n      key: \"constants\",\n      value: t.constants,\n      style: t,\n      styleSpec: e\n    }))), $r(r);\n  }\n\n  function $r(t) {\n    return [].concat(t).sort((t, e) => t.line - e.line);\n  }\n\n  function Rr(t) {\n    return function (...e) {\n      return $r(t.apply(this, e));\n    };\n  }\n\n  function qr(t, e, r) {\n    r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e));\n  }\n\n  function Ur(t, e, r) {\n    if (r && r[t]) {\n      const n = r[t].indexOf(e);\n      -1 !== n && r[t].splice(n, 1);\n    }\n  }\n\n  Or.source = Rr(Vr), Or.light = Rr(Tr), Or.terrain = Rr(Er), Or.layer = Rr(Br), Or.filter = Rr(Ar), Or.paintProperty = Rr(zr), Or.layoutProperty = Rr(Mr);\n\n  class Nr {\n    constructor(t, e = {}) {\n      c(this, e), this.type = t;\n    }\n\n  }\n\n  class jr extends Nr {\n    constructor(t, e = {}) {\n      super(\"error\", c({\n        error: t\n      }, e));\n    }\n\n  }\n\n  class Zr {\n    on(t, e) {\n      return this._listeners = this._listeners || {}, qr(t, e, this._listeners), this;\n    }\n\n    off(t, e) {\n      return Ur(t, e, this._listeners), Ur(t, e, this._oneTimeListeners), this;\n    }\n\n    once(t, e) {\n      return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, qr(t, e, this._oneTimeListeners), this) : new Promise(e => this.once(t, e));\n    }\n\n    fire(t, e) {\n      \"string\" == typeof t && (t = new Nr(t, e || {}));\n      const r = t.type;\n\n      if (this.listens(r)) {\n        t.target = this;\n        const e = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];\n\n        for (const r of e) r.call(this, t);\n\n        const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];\n\n        for (const e of n) Ur(r, e, this._oneTimeListeners), e.call(this, t);\n\n        const i = this._eventedParent;\n        i && (c(t, \"function\" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(t));\n      } else t instanceof jr && console.error(t.error);\n\n      return this;\n    }\n\n    listens(t) {\n      return !!(this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t));\n    }\n\n    setEventedParent(t, e) {\n      return this._eventedParent = t, this._eventedParentData = e, this;\n    }\n\n  }\n\n  const Gr = Or,\n        Xr = Gr.paintProperty,\n        Jr = Gr.layoutProperty;\n\n  class Yr {\n    constructor() {\n      this.first = !0;\n    }\n\n    update(t, e) {\n      const r = Math.floor(t);\n      return this.first ? (this.first = !1, this.lastIntegerZoom = r, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = r, !0) : (this.lastFloorZoom > r ? (this.lastIntegerZoom = r + 1, this.lastIntegerZoomTime = e) : this.lastFloorZoom < r && (this.lastIntegerZoom = r, this.lastIntegerZoomTime = e), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = r, !0));\n    }\n\n  }\n\n  const Kr = t => t >= 1536 && t <= 1791,\n        Hr = t => t >= 1872 && t <= 1919,\n        Wr = t => t >= 2208 && t <= 2303,\n        Qr = t => t >= 11904 && t <= 12031,\n        tn = t => t >= 12032 && t <= 12255,\n        en = t => t >= 12272 && t <= 12287,\n        rn = t => t >= 12288 && t <= 12351,\n        nn = t => t >= 12352 && t <= 12447,\n        sn = t => t >= 12448 && t <= 12543,\n        on = t => t >= 12544 && t <= 12591,\n        an = t => t >= 12704 && t <= 12735,\n        ln = t => t >= 12736 && t <= 12783,\n        un = t => t >= 12784 && t <= 12799,\n        cn = t => t >= 12800 && t <= 13055,\n        hn = t => t >= 13056 && t <= 13311,\n        pn = t => t >= 13312 && t <= 19903,\n        fn = t => t >= 19968 && t <= 40959,\n        dn = t => t >= 40960 && t <= 42127,\n        yn = t => t >= 42128 && t <= 42191,\n        mn = t => t >= 63744 && t <= 64255,\n        gn = t => t >= 64336 && t <= 65023,\n        xn = t => t >= 65040 && t <= 65055,\n        vn = t => t >= 65072 && t <= 65103,\n        bn = t => t >= 65104 && t <= 65135,\n        wn = t => t >= 65136 && t <= 65279,\n        _n = t => t >= 65280 && t <= 65519;\n\n  function kn(t) {\n    for (const e of t) if (In(e.charCodeAt(0))) return !0;\n\n    return !1;\n  }\n\n  function Sn(t) {\n    for (const e of t) if (!An(e.charCodeAt(0))) return !1;\n\n    return !0;\n  }\n\n  function An(t) {\n    return !(Kr(t) || Hr(t) || Wr(t) || gn(t) || wn(t));\n  }\n\n  function In(t) {\n    return !(746 !== t && 747 !== t && (t < 4352 || !(an(t) || on(t) || vn(t) && !(t >= 65097 && t <= 65103) || mn(t) || hn(t) || Qr(t) || ln(t) || !(!rn(t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || pn(t) || fn(t) || cn(t) || (t => t >= 12592 && t <= 12687)(t) || (t => t >= 43360 && t <= 43391)(t) || (t => t >= 55216 && t <= 55295)(t) || (t => t >= 4352 && t <= 4607)(t) || (t => t >= 44032 && t <= 55215)(t) || nn(t) || en(t) || (t => t >= 12688 && t <= 12703)(t) || tn(t) || un(t) || sn(t) && 12540 !== t || !(!_n(t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!bn(t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || (t => t >= 5120 && t <= 5759)(t) || (t => t >= 6320 && t <= 6399)(t) || xn(t) || (t => t >= 19904 && t <= 19967)(t) || dn(t) || yn(t))));\n  }\n\n  function zn(t) {\n    return !(In(t) || function (t) {\n      return !!((t => t >= 128 && t <= 255)(t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || (t => t >= 8192 && t <= 8303)(t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || (t => t >= 8448 && t <= 8527)(t) || (t => t >= 8528 && t <= 8591)(t) || (t => t >= 8960 && t <= 9215)(t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || (t => t >= 9216 && t <= 9279)(t) && 9251 !== t || (t => t >= 9280 && t <= 9311)(t) || (t => t >= 9312 && t <= 9471)(t) || (t => t >= 9632 && t <= 9727)(t) || (t => t >= 9728 && t <= 9983)(t) && !(t >= 9754 && t <= 9759) || (t => t >= 11008 && t <= 11263)(t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || rn(t) || sn(t) || (t => t >= 57344 && t <= 63743)(t) || vn(t) || bn(t) || _n(t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t);\n    }(t));\n  }\n\n  function Mn(t) {\n    return t >= 1424 && t <= 2303 || gn(t) || wn(t);\n  }\n\n  function Bn(t, e) {\n    return !(!e && Mn(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || (t => t >= 6016 && t <= 6143)(t));\n  }\n\n  function Pn(t) {\n    for (const e of t) if (Mn(e.charCodeAt(0))) return !0;\n\n    return !1;\n  }\n\n  let Cn;\n  const Vn = {\n    API_URL: \"https://api.mapbox.com\",\n\n    get API_URL_REGEX() {\n      if (null == Cn) {\n        const t = /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/|\\?|$)/i;\n\n        try {\n          Cn = null != process.env.API_URL_REGEX ? new RegExp(process.env.API_URL_REGEX) : t;\n        } catch (e) {\n          Cn = t;\n        }\n      }\n\n      return Cn;\n    },\n\n    get EVENTS_URL() {\n      return this.API_URL ? 0 === this.API_URL.indexOf(\"https://api.mapbox.cn\") ? \"https://events.mapbox.cn/events/v2\" : 0 === this.API_URL.indexOf(\"https://api.mapbox.com\") ? \"https://events.mapbox.com/events/v2\" : null : null;\n    },\n\n    SESSION_PATH: \"/map-sessions/v1\",\n    FEEDBACK_URL: \"https://apps.mapbox.com/feedback\",\n    TILE_URL_VERSION: \"v4\",\n    RASTER_URL_PREFIX: \"raster/v1\",\n    REQUIRE_ACCESS_TOKEN: !0,\n    ACCESS_TOKEN: null,\n    MAX_PARALLEL_IMAGE_REQUESTS: 16\n  },\n        Tn = {\n    supported: !1,\n    testSupport: function (t) {\n      !Fn && Dn && (Ln ? On(t) : En = t);\n    }\n  };\n  let En,\n      Dn,\n      Fn = !1,\n      Ln = !1;\n\n  function On(t) {\n    const e = t.createTexture();\n    t.bindTexture(t.TEXTURE_2D, e);\n\n    try {\n      if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, Dn), t.isContextLost()) return;\n      Tn.supported = !0;\n    } catch (t) {}\n\n    t.deleteTexture(e), Fn = !0;\n  }\n\n  function $n(t) {\n    return Vn.API_URL_REGEX.test(t);\n  }\n\n  i.document && (Dn = i.document.createElement(\"img\"), Dn.onload = function () {\n    En && On(En), En = null, Ln = !0;\n  }, Dn.onerror = function () {\n    Fn = !0, En = null;\n  }, Dn.src = \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=\");\n  const Rn = /^(\\w+):\\/\\/([^/?]*)(\\/[^?]+)?\\??(.+)?/;\n\n  function qn(t) {\n    const e = t.match(Rn);\n    if (!e) throw new Error(\"Unable to parse URL object\");\n    return {\n      protocol: e[1],\n      authority: e[2],\n      path: e[3] || \"/\",\n      params: e[4] ? e[4].split(\"&\") : []\n    };\n  }\n\n  function Un(t) {\n    const e = t.params.length ? `?${t.params.join(\"&\")}` : \"\";\n    return `${t.protocol}://${t.authority}${t.path}${e}`;\n  }\n\n  function Nn(t) {\n    if (!t) return null;\n    const e = t.split(\".\");\n    if (!e || 3 !== e.length) return null;\n\n    try {\n      return JSON.parse(decodeURIComponent(i.atob(e[1]).split(\"\").map(t => \"%\" + (\"00\" + t.charCodeAt(0).toString(16)).slice(-2)).join(\"\")));\n    } catch (t) {\n      return null;\n    }\n  }\n\n  class jn {\n    constructor(t) {\n      this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;\n    }\n\n    getStorageKey(t) {\n      const e = Nn(Vn.ACCESS_TOKEN);\n      let r = \"\";\n      return r = e && e.u ? i.btoa(encodeURIComponent(e.u).replace(/%([0-9A-F]{2})/g, (t, e) => String.fromCharCode(Number(\"0x\" + e)))) : \"\", t ? `mapbox.eventData.${t}:${r}` : `mapbox.eventData:${r}`;\n    }\n\n    fetchEventData() {\n      const t = A(\"localStorage\"),\n            e = this.getStorageKey(),\n            r = this.getStorageKey(\"uuid\");\n      if (t) try {\n        const t = i.localStorage.getItem(e);\n        t && (this.eventData = JSON.parse(t));\n        const n = i.localStorage.getItem(r);\n        n && (this.anonId = n);\n      } catch (t) {\n        x(\"Unable to read from LocalStorage\");\n      }\n    }\n\n    saveEventData() {\n      const t = A(\"localStorage\"),\n            e = this.getStorageKey(),\n            r = this.getStorageKey(\"uuid\");\n      if (t) try {\n        i.localStorage.setItem(r, this.anonId), Object.keys(this.eventData).length >= 1 && i.localStorage.setItem(e, JSON.stringify(this.eventData));\n      } catch (t) {\n        x(\"Unable to write to LocalStorage\");\n      }\n    }\n\n    processRequests(t) {}\n\n    postEvent(t, e, r, n) {\n      if (!Vn.EVENTS_URL) return;\n      const i = qn(Vn.EVENTS_URL);\n      i.params.push(`access_token=${n || Vn.ACCESS_TOKEN || \"\"}`);\n      const s = {\n        event: this.type,\n        created: new Date(t).toISOString(),\n        sdkIdentifier: \"mapbox-gl-js\",\n        sdkVersion: \"2.1.1\",\n        skuId: \"01\",\n        userId: this.anonId\n      },\n            o = e ? c(s, e) : s,\n            a = {\n        url: Un(i),\n        headers: {\n          \"Content-Type\": \"text/plain\"\n        },\n        body: JSON.stringify([o])\n      };\n      this.pendingRequest = ei(a, t => {\n        this.pendingRequest = null, r(t), this.saveEventData(), this.processRequests(n);\n      });\n    }\n\n    queueRequest(t, e) {\n      this.queue.push(t), this.processRequests(e);\n    }\n\n  }\n\n  const Zn = new class extends jn {\n    constructor(t) {\n      super(\"appUserTurnstile\"), this._customAccessToken = t;\n    }\n\n    postTurnstileEvent(t, e) {\n      Vn.EVENTS_URL && Vn.ACCESS_TOKEN && Array.isArray(t) && t.some(t => function (t) {\n        return 0 === t.indexOf(\"mapbox:\");\n      }(t) || $n(t)) && this.queueRequest(Date.now(), e);\n    }\n\n    processRequests(t) {\n      if (this.pendingRequest || 0 === this.queue.length) return;\n      this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();\n      const e = Nn(Vn.ACCESS_TOKEN),\n            r = e ? e.u : Vn.ACCESS_TOKEN;\n      let n = r !== this.eventData.tokenU;\n      p(this.anonId) || (this.anonId = h(), n = !0);\n      const i = this.queue.shift();\n\n      if (this.eventData.lastSuccess) {\n        const t = new Date(this.eventData.lastSuccess),\n              e = new Date(i),\n              r = (i - this.eventData.lastSuccess) / 864e5;\n        n = n || r >= 1 || r < -1 || t.getDate() !== e.getDate();\n      } else n = !0;\n\n      if (!n) return this.processRequests();\n      this.postEvent(i, {\n        \"enabled.telemetry\": !1\n      }, t => {\n        t || (this.eventData.lastSuccess = i, this.eventData.tokenU = r);\n      }, t);\n    }\n\n  }(),\n        Gn = (Zn.postTurnstileEvent.bind(Zn), new class extends jn {\n    constructor() {\n      super(\"map.load\"), this.success = {}, this.skuToken = \"\";\n    }\n\n    postMapLoadEvent(t, e, r, n) {\n      this.skuToken = e, this.errorCb = n, Vn.EVENTS_URL && (r || Vn.ACCESS_TOKEN ? this.queueRequest({\n        id: t,\n        timestamp: Date.now()\n      }, r) : this.errorCb(new Error(\"A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/\")));\n    }\n\n    processRequests(t) {\n      if (this.pendingRequest || 0 === this.queue.length) return;\n      const {\n        id: e,\n        timestamp: r\n      } = this.queue.shift();\n      e && this.success[e] || (this.anonId || this.fetchEventData(), p(this.anonId) || (this.anonId = h()), this.postEvent(r, {\n        skuToken: this.skuToken\n      }, t => {\n        t ? this.errorCb(t) : e && (this.success[e] = !0);\n      }, t));\n    }\n\n  }()),\n        Xn = (Gn.postMapLoadEvent.bind(Gn), new class extends jn {\n    constructor() {\n      super(\"map.auth\"), this.success = {}, this.skuToken = \"\";\n    }\n\n    getSession(t, e, r, n) {\n      const i = qn(Vn.API_URL + Vn.SESSION_PATH);\n      i.params.push(`sku=${e || \"\"}`), i.params.push(`access_token=${n || Vn.ACCESS_TOKEN || \"\"}`);\n      const s = {\n        url: Un(i),\n        headers: {\n          \"Content-Type\": \"text/plain\"\n        }\n      };\n      this.pendingRequest = ri(s, t => {\n        this.pendingRequest = null, r(t), this.saveEventData(), this.processRequests(n);\n      });\n    }\n\n    getSessionAPI(t, e, r, n) {\n      this.skuToken = e, this.errorCb = n, r || Vn.ACCESS_TOKEN ? this.queueRequest({\n        id: t,\n        timestamp: Date.now()\n      }, r) : this.errorCb(new Error(\"NO_ACCESS_TOKEN\"));\n    }\n\n    processRequests(t) {\n      if (this.pendingRequest || 0 === this.queue.length) return;\n      const {\n        id: e,\n        timestamp: r\n      } = this.queue.shift();\n      e && this.success[e] || this.getSession(r, this.skuToken, t => {\n        t ? this.errorCb(t) : e && (this.success[e] = !0);\n      }, t);\n    }\n\n  }());\n  let Jn, Yn;\n\n  function Kn() {\n    i.caches && !Jn && (Jn = i.caches.open(\"mapbox-tiles\"));\n  }\n\n  function Hn(t) {\n    const e = t.indexOf(\"?\");\n    return e < 0 ? t : t.slice(0, e);\n  }\n\n  Xn.getSessionAPI.bind(Xn), \"function\" == typeof Object.freeze && Object.freeze({\n    Unknown: \"Unknown\",\n    Style: \"Style\",\n    Source: \"Source\",\n    Tile: \"Tile\",\n    Glyphs: \"Glyphs\",\n    SpriteImage: \"SpriteImage\",\n    SpriteJSON: \"SpriteJSON\",\n    Image: \"Image\"\n  });\n\n  class Wn extends Error {\n    constructor(t, e, r) {\n      401 === e && $n(r) && (t += \": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes\"), super(t), this.status = e, this.url = r;\n    }\n\n    toString() {\n      return `${this.name}: ${this.message} (${this.status}): ${this.url}`;\n    }\n\n  }\n\n  const Qn = w() ? () => self.worker && self.worker.referrer : () => (\"blob:\" === i.location.protocol ? i.parent : i).location.href;\n\n  const ti = function (t, e) {\n    if (!(/^file:/.test(r = t.url) || /^file:/.test(Qn()) && !/^\\w+:/.test(r))) {\n      if (i.fetch && i.Request && i.AbortController && i.Request.prototype.hasOwnProperty(\"signal\")) return function (t, e) {\n        const r = new i.AbortController(),\n              n = new i.Request(t.url, {\n          method: t.method || \"GET\",\n          body: t.body,\n          credentials: t.credentials,\n          headers: t.headers,\n          referrer: Qn(),\n          signal: r.signal\n        });\n        let s = !1,\n            o = !1;\n        const a = (l = n.url).indexOf(\"sku=\") > 0 && $n(l);\n        var l;\n        \"json\" === t.type && n.headers.set(\"Accept\", \"application/json\");\n\n        const u = (r, s, l) => {\n          if (o) return;\n          if (r && \"SecurityError\" !== r.message && x(r), s && l) return c(s);\n          const u = Date.now();\n          i.fetch(n).then(r => {\n            if (r.ok) {\n              const t = a ? r.clone() : null;\n              return c(r, t, u);\n            }\n\n            return e(new Wn(r.statusText, r.status, t.url));\n          }).catch(t => {\n            20 !== t.code && e(new Error(t.message));\n          });\n        },\n              c = (r, a, l) => {\n          (\"arrayBuffer\" === t.type ? r.arrayBuffer() : \"json\" === t.type ? r.json() : r.text()).then(t => {\n            o || (a && l && function (t, e, r) {\n              if (Kn(), !Jn) return;\n              const n = {\n                status: e.status,\n                statusText: e.statusText,\n                headers: new i.Headers()\n              };\n              e.headers.forEach((t, e) => n.headers.set(e, t));\n\n              const s = _(e.headers.get(\"Cache-Control\") || \"\");\n\n              s[\"no-store\"] || (s[\"max-age\"] && n.headers.set(\"Expires\", new Date(r + 1e3 * s[\"max-age\"]).toUTCString()), new Date(n.headers.get(\"Expires\")).getTime() - r < 42e4 || function (t, e) {\n                if (void 0 === Yn) try {\n                  new Response(new ReadableStream()), Yn = !0;\n                } catch (t) {\n                  Yn = !1;\n                }\n                Yn ? e(t.body) : t.blob().then(e);\n              }(e, e => {\n                const r = new i.Response(e, n);\n                Kn(), Jn && Jn.then(e => e.put(Hn(t.url), r)).catch(t => x(t.message));\n              }));\n            }(n, a, l), s = !0, e(null, t, r.headers.get(\"Cache-Control\"), r.headers.get(\"Expires\")));\n          }).catch(t => {\n            o || e(new Error(t.message));\n          });\n        };\n\n        return a ? function (t, e) {\n          if (Kn(), !Jn) return e(null);\n          const r = Hn(t.url);\n          Jn.then(t => {\n            t.match(r).then(n => {\n              const i = function (t) {\n                if (!t) return !1;\n\n                const e = new Date(t.headers.get(\"Expires\") || 0),\n                      r = _(t.headers.get(\"Cache-Control\") || \"\");\n\n                return e > Date.now() && !r[\"no-cache\"];\n              }(n);\n\n              t.delete(r), i && t.put(r, n.clone()), e(null, n, i);\n            }).catch(e);\n          }).catch(e);\n        }(n, u) : u(null, null), {\n          cancel: () => {\n            o = !0, s || r.abort();\n          }\n        };\n      }(t, e);\n      if (w() && self.worker && self.worker.actor) return self.worker.actor.send(\"getResource\", t, e, void 0, !0);\n    }\n\n    var r;\n    return function (t, e) {\n      const r = new i.XMLHttpRequest();\n      r.open(t.method || \"GET\", t.url, !0), \"arrayBuffer\" === t.type && (r.responseType = \"arraybuffer\");\n\n      for (const e in t.headers) r.setRequestHeader(e, t.headers[e]);\n\n      return \"json\" === t.type && (r.responseType = \"text\", r.setRequestHeader(\"Accept\", \"application/json\")), r.withCredentials = \"include\" === t.credentials, r.onerror = () => {\n        e(new Error(r.statusText));\n      }, r.onload = () => {\n        if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {\n          let n = r.response;\n          if (\"json\" === t.type) try {\n            n = JSON.parse(r.response);\n          } catch (t) {\n            return e(t);\n          }\n          e(null, n, r.getResponseHeader(\"Cache-Control\"), r.getResponseHeader(\"Expires\"));\n        } else e(new Wn(r.statusText, r.status, t.url));\n      }, r.send(t.body), {\n        cancel: () => r.abort()\n      };\n    }(t, e);\n  },\n        ei = function (t, e) {\n    return ti(c(t, {\n      method: \"POST\"\n    }), e);\n  },\n        ri = function (t, e) {\n    return ti(c(t, {\n      method: \"GET\"\n    }), e);\n  };\n\n  let ni = \"unavailable\",\n      ii = null;\n  const si = {\n    applyArabicShaping: null,\n    processBidirectionalText: null,\n    processStyledBidirectionalText: null,\n    isLoaded: () => \"loaded\" === ni || null != si.applyArabicShaping,\n    isLoading: () => \"loading\" === ni,\n\n    setState(t) {\n      ni = t.pluginStatus, ii = t.pluginURL;\n    },\n\n    isParsed: () => null != si.applyArabicShaping && null != si.processBidirectionalText && null != si.processStyledBidirectionalText,\n    getPluginURL: () => ii\n  };\n\n  class oi {\n    constructor(t, e) {\n      this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.zoomHistory = e.zoomHistory, this.transition = e.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Yr(), this.transition = {});\n    }\n\n    isSupportedScript(t) {\n      return function (t, e) {\n        for (const r of t) if (!Bn(r.charCodeAt(0), e)) return !1;\n\n        return !0;\n      }(t, si.isLoaded());\n    }\n\n    crossFadingFactor() {\n      return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);\n    }\n\n    getCrossfadeParameters() {\n      const t = this.zoom,\n            e = t - Math.floor(t),\n            r = this.crossFadingFactor();\n      return t > this.zoomHistory.lastIntegerZoom ? {\n        fromScale: 2,\n        toScale: 1,\n        t: e + (1 - e) * r\n      } : {\n        fromScale: .5,\n        toScale: 1,\n        t: 1 - (1 - r) * e\n      };\n    }\n\n  }\n\n  class ai {\n    constructor(t, e) {\n      this.property = t, this.value = e, this.expression = function (t, e) {\n        if (Ce(t)) return new je(t, e);\n\n        if ($e(t)) {\n          const r = Ne(t, e);\n          if (\"error\" === r.result) throw new Error(r.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n          return r.value;\n        }\n\n        {\n          let r = t;\n          return \"string\" == typeof t && \"color\" === e.type && (r = P.parse(t)), {\n            kind: \"constant\",\n            evaluate: () => r\n          };\n        }\n      }(void 0 === e ? t.specification.default : e, t.specification);\n    }\n\n    isDataDriven() {\n      return \"source\" === this.expression.kind || \"composite\" === this.expression.kind;\n    }\n\n    possiblyEvaluate(t, e, r) {\n      return this.property.possiblyEvaluate(this, t, e, r);\n    }\n\n  }\n\n  class li {\n    constructor(t) {\n      this.property = t, this.value = new ai(t, void 0);\n    }\n\n    transitioned(t, e) {\n      return new ci(this.property, this.value, e, c({}, t.transition, this.transition), t.now);\n    }\n\n    untransitioned() {\n      return new ci(this.property, this.value, null, {}, 0);\n    }\n\n  }\n\n  class ui {\n    constructor(t) {\n      this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);\n    }\n\n    getValue(t) {\n      return m(this._values[t].value.value);\n    }\n\n    setValue(t, e) {\n      this._values.hasOwnProperty(t) || (this._values[t] = new li(this._values[t].property)), this._values[t].value = new ai(this._values[t].property, null === e ? void 0 : m(e));\n    }\n\n    getTransition(t) {\n      return m(this._values[t].transition);\n    }\n\n    setTransition(t, e) {\n      this._values.hasOwnProperty(t) || (this._values[t] = new li(this._values[t].property)), this._values[t].transition = m(e) || void 0;\n    }\n\n    serialize() {\n      const t = {};\n\n      for (const e of Object.keys(this._values)) {\n        const r = this.getValue(e);\n        void 0 !== r && (t[e] = r);\n        const n = this.getTransition(e);\n        void 0 !== n && (t[`${e}-transition`] = n);\n      }\n\n      return t;\n    }\n\n    transitioned(t, e) {\n      const r = new hi(this._properties);\n\n      for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(t, e._values[n]);\n\n      return r;\n    }\n\n    untransitioned() {\n      const t = new hi(this._properties);\n\n      for (const e of Object.keys(this._values)) t._values[e] = this._values[e].untransitioned();\n\n      return t;\n    }\n\n  }\n\n  class ci {\n    constructor(t, e, r, n, i) {\n      this.property = t, this.value = e, this.begin = i + n.delay || 0, this.end = this.begin + n.duration || 0, t.specification.transition && (n.delay || n.duration) && (this.prior = r);\n    }\n\n    possiblyEvaluate(t, e, r) {\n      const n = t.now || 0,\n            i = this.value.possiblyEvaluate(t, e, r),\n            s = this.prior;\n\n      if (s) {\n        if (n > this.end) return this.prior = null, i;\n        if (this.value.isDataDriven()) return this.prior = null, i;\n        if (n < this.begin) return s.possiblyEvaluate(t, e, r);\n        {\n          const o = (n - this.begin) / (this.end - this.begin);\n          return this.property.interpolate(s.possiblyEvaluate(t, e, r), i, function (t) {\n            if (t <= 0) return 0;\n            if (t >= 1) return 1;\n            const e = t * t,\n                  r = e * t;\n            return 4 * (t < .5 ? r : 3 * (t - e) + r - .75);\n          }(o));\n        }\n      }\n\n      return i;\n    }\n\n  }\n\n  class hi {\n    constructor(t) {\n      this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);\n    }\n\n    possiblyEvaluate(t, e, r) {\n      const n = new di(this._properties);\n\n      for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);\n\n      return n;\n    }\n\n    hasTransition() {\n      for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;\n\n      return !1;\n    }\n\n  }\n\n  class pi {\n    constructor(t) {\n      this._properties = t, this._values = Object.create(t.defaultPropertyValues);\n    }\n\n    getValue(t) {\n      return m(this._values[t].value);\n    }\n\n    setValue(t, e) {\n      this._values[t] = new ai(this._values[t].property, null === e ? void 0 : m(e));\n    }\n\n    serialize() {\n      const t = {};\n\n      for (const e of Object.keys(this._values)) {\n        const r = this.getValue(e);\n        void 0 !== r && (t[e] = r);\n      }\n\n      return t;\n    }\n\n    possiblyEvaluate(t, e, r) {\n      const n = new di(this._properties);\n\n      for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);\n\n      return n;\n    }\n\n  }\n\n  class fi {\n    constructor(t, e, r) {\n      this.property = t, this.value = e, this.parameters = r;\n    }\n\n    isConstant() {\n      return \"constant\" === this.value.kind;\n    }\n\n    constantOr(t) {\n      return \"constant\" === this.value.kind ? this.value.value : t;\n    }\n\n    evaluate(t, e, r, n) {\n      return this.property.evaluate(this.value, this.parameters, t, e, r, n);\n    }\n\n  }\n\n  class di {\n    constructor(t) {\n      this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);\n    }\n\n    get(t) {\n      return this._values[t];\n    }\n\n  }\n\n  class yi {\n    constructor(t) {\n      this.specification = t;\n    }\n\n    possiblyEvaluate(t, e) {\n      return t.expression.evaluate(e);\n    }\n\n    interpolate(t, e, r) {\n      const n = Rt[this.specification.type];\n      return n ? n(t, e, r) : t;\n    }\n\n  }\n\n  class mi {\n    constructor(t, e) {\n      this.specification = t, this.overrides = e;\n    }\n\n    possiblyEvaluate(t, e, r, n) {\n      return new fi(this, \"constant\" === t.expression.kind || \"camera\" === t.expression.kind ? {\n        kind: \"constant\",\n        value: t.expression.evaluate(e, null, {}, r, n)\n      } : t.expression, e);\n    }\n\n    interpolate(t, e, r) {\n      if (\"constant\" !== t.value.kind || \"constant\" !== e.value.kind) return t;\n      if (void 0 === t.value.value || void 0 === e.value.value) return new fi(this, {\n        kind: \"constant\",\n        value: void 0\n      }, t.parameters);\n      const n = Rt[this.specification.type];\n      return n ? new fi(this, {\n        kind: \"constant\",\n        value: n(t.value.value, e.value.value, r)\n      }, t.parameters) : t;\n    }\n\n    evaluate(t, e, r, n, i, s) {\n      return \"constant\" === t.kind ? t.value : t.evaluate(e, r, n, i, s);\n    }\n\n  }\n\n  class gi extends mi {\n    possiblyEvaluate(t, e, r, n) {\n      if (void 0 === t.value) return new fi(this, {\n        kind: \"constant\",\n        value: void 0\n      }, e);\n\n      if (\"constant\" === t.expression.kind) {\n        const i = t.expression.evaluate(e, null, {}, r, n),\n              s = \"resolvedImage\" === t.property.specification.type && \"string\" != typeof i ? i.name : i,\n              o = this._calculate(s, s, s, e);\n\n        return new fi(this, {\n          kind: \"constant\",\n          value: o\n        }, e);\n      }\n\n      if (\"camera\" === t.expression.kind) {\n        const r = this._calculate(t.expression.evaluate({\n          zoom: e.zoom - 1\n        }), t.expression.evaluate({\n          zoom: e.zoom\n        }), t.expression.evaluate({\n          zoom: e.zoom + 1\n        }), e);\n\n        return new fi(this, {\n          kind: \"constant\",\n          value: r\n        }, e);\n      }\n\n      return new fi(this, t.expression, e);\n    }\n\n    evaluate(t, e, r, n, i, s) {\n      if (\"source\" === t.kind) {\n        const o = t.evaluate(e, r, n, i, s);\n        return this._calculate(o, o, o, e);\n      }\n\n      return \"composite\" === t.kind ? this._calculate(t.evaluate({\n        zoom: Math.floor(e.zoom) - 1\n      }, r, n), t.evaluate({\n        zoom: Math.floor(e.zoom)\n      }, r, n), t.evaluate({\n        zoom: Math.floor(e.zoom) + 1\n      }, r, n), e) : t.value;\n    }\n\n    _calculate(t, e, r, n) {\n      return n.zoom > n.zoomHistory.lastIntegerZoom ? {\n        from: t,\n        to: e\n      } : {\n        from: r,\n        to: e\n      };\n    }\n\n    interpolate(t) {\n      return t;\n    }\n\n  }\n\n  class xi {\n    constructor(t) {\n      this.specification = t;\n    }\n\n    possiblyEvaluate(t, e, r, n) {\n      if (void 0 !== t.value) {\n        if (\"constant\" === t.expression.kind) {\n          const i = t.expression.evaluate(e, null, {}, r, n);\n          return this._calculate(i, i, i, e);\n        }\n\n        return this._calculate(t.expression.evaluate(new oi(Math.floor(e.zoom - 1), e)), t.expression.evaluate(new oi(Math.floor(e.zoom), e)), t.expression.evaluate(new oi(Math.floor(e.zoom + 1), e)), e);\n      }\n    }\n\n    _calculate(t, e, r, n) {\n      return n.zoom > n.zoomHistory.lastIntegerZoom ? {\n        from: t,\n        to: e\n      } : {\n        from: r,\n        to: e\n      };\n    }\n\n    interpolate(t) {\n      return t;\n    }\n\n  }\n\n  class vi {\n    constructor(t) {\n      this.specification = t;\n    }\n\n    possiblyEvaluate(t, e, r, n) {\n      return !!t.expression.evaluate(e, null, {}, r, n);\n    }\n\n    interpolate() {\n      return !1;\n    }\n\n  }\n\n  class bi {\n    constructor(t) {\n      this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];\n\n      for (const e in t) {\n        const r = t[e];\n        r.specification.overridable && this.overridableProperties.push(e);\n        const n = this.defaultPropertyValues[e] = new ai(r, void 0),\n              i = this.defaultTransitionablePropertyValues[e] = new li(r);\n        this.defaultTransitioningPropertyValues[e] = i.untransitioned(), this.defaultPossiblyEvaluatedValues[e] = n.possiblyEvaluate({});\n      }\n    }\n\n  }\n\n  function wi(t, e) {\n    return 256 * (t = l(Math.floor(t), 0, 255)) + l(Math.floor(e), 0, 255);\n  }\n\n  Je(\"DataDrivenProperty\", mi), Je(\"DataConstantProperty\", yi), Je(\"CrossFadedDataDrivenProperty\", gi), Je(\"CrossFadedProperty\", xi), Je(\"ColorRampProperty\", vi);\n  const _i = {\n    Int8: Int8Array,\n    Uint8: Uint8Array,\n    Int16: Int16Array,\n    Uint16: Uint16Array,\n    Int32: Int32Array,\n    Uint32: Uint32Array,\n    Float32: Float32Array\n  };\n\n  class ki {\n    constructor(t, e) {\n      this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;\n    }\n\n  }\n\n  class Si {\n    constructor() {\n      this.isTransferred = !1, this.capacity = -1, this.resize(0);\n    }\n\n    static serialize(t, e) {\n      return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), {\n        length: t.length,\n        arrayBuffer: t.arrayBuffer\n      };\n    }\n\n    static deserialize(t) {\n      const e = Object.create(this.prototype);\n      return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;\n    }\n\n    _trim() {\n      this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());\n    }\n\n    clear() {\n      this.length = 0;\n    }\n\n    resize(t) {\n      this.reserve(t), this.length = t;\n    }\n\n    reserve(t) {\n      if (t > this.capacity) {\n        this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);\n        const e = this.uint8;\n        this._refreshViews(), e && this.uint8.set(e);\n      }\n    }\n\n    _refreshViews() {\n      throw new Error(\"_refreshViews() must be implemented by each concrete StructArray layout\");\n    }\n\n  }\n\n  function Ai(t, e = 1) {\n    let r = 0,\n        n = 0;\n    return {\n      members: t.map(t => {\n        const i = _i[t.type].BYTES_PER_ELEMENT,\n              s = r = Ii(r, Math.max(e, i)),\n              o = t.components || 1;\n        return n = Math.max(n, i), r += i * o, {\n          name: t.name,\n          type: t.type,\n          components: o,\n          offset: s\n        };\n      }),\n      size: Ii(r, Math.max(n, e)),\n      alignment: e\n    };\n  }\n\n  function Ii(t, e) {\n    return Math.ceil(t / e) * e;\n  }\n\n  class zi extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e) {\n      const r = this.length;\n      return this.resize(r + 1), this.emplace(r, t, e);\n    }\n\n    emplace(t, e, r) {\n      const n = 2 * t;\n      return this.int16[n + 0] = e, this.int16[n + 1] = r, t;\n    }\n\n  }\n\n  zi.prototype.bytesPerElement = 4, Je(\"StructArrayLayout2i4\", zi);\n\n  class Mi extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r, n) {\n      const i = this.length;\n      return this.resize(i + 1), this.emplace(i, t, e, r, n);\n    }\n\n    emplace(t, e, r, n, i) {\n      const s = 4 * t;\n      return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t;\n    }\n\n  }\n\n  Mi.prototype.bytesPerElement = 8, Je(\"StructArrayLayout4i8\", Mi);\n\n  class Bi extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r, n, i, s, o) {\n      const a = this.length;\n      return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s, o);\n    }\n\n    emplace(t, e, r, n, i, s, o, a) {\n      const l = 6 * t,\n            u = 12 * t,\n            c = 3 * t;\n      return this.int16[l + 0] = e, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = s, this.uint8[u + 7] = o, this.float32[c + 2] = a, t;\n    }\n\n  }\n\n  Bi.prototype.bytesPerElement = 12, Je(\"StructArrayLayout2i4ub1f12\", Bi);\n\n  class Pi extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e) {\n      const r = this.length;\n      return this.resize(r + 1), this.emplace(r, t, e);\n    }\n\n    emplace(t, e, r) {\n      const n = 2 * t;\n      return this.float32[n + 0] = e, this.float32[n + 1] = r, t;\n    }\n\n  }\n\n  Pi.prototype.bytesPerElement = 8, Je(\"StructArrayLayout2f8\", Pi);\n\n  class Ci extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r, n, i, s, o, a, l, u) {\n      const c = this.length;\n      return this.resize(c + 1), this.emplace(c, t, e, r, n, i, s, o, a, l, u);\n    }\n\n    emplace(t, e, r, n, i, s, o, a, l, u, c) {\n      const h = 10 * t;\n      return this.uint16[h + 0] = e, this.uint16[h + 1] = r, this.uint16[h + 2] = n, this.uint16[h + 3] = i, this.uint16[h + 4] = s, this.uint16[h + 5] = o, this.uint16[h + 6] = a, this.uint16[h + 7] = l, this.uint16[h + 8] = u, this.uint16[h + 9] = c, t;\n    }\n\n  }\n\n  Ci.prototype.bytesPerElement = 20, Je(\"StructArrayLayout10ui20\", Ci);\n\n  class Vi extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r, n, i, s, o, a, l, u, c, h) {\n      const p = this.length;\n      return this.resize(p + 1), this.emplace(p, t, e, r, n, i, s, o, a, l, u, c, h);\n    }\n\n    emplace(t, e, r, n, i, s, o, a, l, u, c, h, p) {\n      const f = 12 * t;\n      return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = s, this.uint16[f + 5] = o, this.uint16[f + 6] = a, this.uint16[f + 7] = l, this.int16[f + 8] = u, this.int16[f + 9] = c, this.int16[f + 10] = h, this.int16[f + 11] = p, t;\n    }\n\n  }\n\n  Vi.prototype.bytesPerElement = 24, Je(\"StructArrayLayout4i4ui4i24\", Vi);\n\n  class Ti extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r) {\n      const n = this.length;\n      return this.resize(n + 1), this.emplace(n, t, e, r);\n    }\n\n    emplace(t, e, r, n) {\n      const i = 3 * t;\n      return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t;\n    }\n\n  }\n\n  Ti.prototype.bytesPerElement = 12, Je(\"StructArrayLayout3f12\", Ti);\n\n  class Ei extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t) {\n      const e = this.length;\n      return this.resize(e + 1), this.emplace(e, t);\n    }\n\n    emplace(t, e) {\n      return this.uint32[1 * t + 0] = e, t;\n    }\n\n  }\n\n  Ei.prototype.bytesPerElement = 4, Je(\"StructArrayLayout1ul4\", Ei);\n\n  class Di extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r, n, i, s, o, a, l, u) {\n      const c = this.length;\n      return this.resize(c + 1), this.emplace(c, t, e, r, n, i, s, o, a, l, u);\n    }\n\n    emplace(t, e, r, n, i, s, o, a, l, u, c) {\n      const h = 16 * t,\n            p = 8 * t;\n      return this.int16[h + 0] = e, this.int16[h + 1] = r, this.float32[p + 1] = n, this.float32[p + 2] = i, this.float32[p + 3] = s, this.float32[p + 4] = o, this.int16[h + 10] = a, this.uint32[p + 6] = l, this.uint16[h + 14] = u, this.uint16[h + 15] = c, t;\n    }\n\n  }\n\n  Di.prototype.bytesPerElement = 32, Je(\"StructArrayLayout2i4f1i1ul2ui32\", Di);\n\n  class Fi extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r, n, i, s) {\n      const o = this.length;\n      return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s);\n    }\n\n    emplace(t, e, r, n, i, s, o) {\n      const a = 6 * t;\n      return this.int16[a + 0] = e, this.int16[a + 1] = r, this.int16[a + 2] = n, this.int16[a + 3] = i, this.int16[a + 4] = s, this.int16[a + 5] = o, t;\n    }\n\n  }\n\n  Fi.prototype.bytesPerElement = 12, Je(\"StructArrayLayout2i2i2i12\", Fi);\n\n  class Li extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r, n, i) {\n      const s = this.length;\n      return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n    }\n\n    emplace(t, e, r, n, i, s) {\n      const o = 4 * t,\n            a = 8 * t;\n      return this.float32[o + 0] = e, this.float32[o + 1] = r, this.float32[o + 2] = n, this.int16[a + 6] = i, this.int16[a + 7] = s, t;\n    }\n\n  }\n\n  Li.prototype.bytesPerElement = 16, Je(\"StructArrayLayout2f1f2i16\", Li);\n\n  class Oi extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r, n) {\n      const i = this.length;\n      return this.resize(i + 1), this.emplace(i, t, e, r, n);\n    }\n\n    emplace(t, e, r, n, i) {\n      const s = 12 * t,\n            o = 3 * t;\n      return this.uint8[s + 0] = e, this.uint8[s + 1] = r, this.float32[o + 1] = n, this.float32[o + 2] = i, t;\n    }\n\n  }\n\n  Oi.prototype.bytesPerElement = 12, Je(\"StructArrayLayout2ub2f12\", Oi);\n\n  class $i extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r) {\n      const n = this.length;\n      return this.resize(n + 1), this.emplace(n, t, e, r);\n    }\n\n    emplace(t, e, r, n) {\n      const i = 3 * t;\n      return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t;\n    }\n\n  }\n\n  $i.prototype.bytesPerElement = 6, Je(\"StructArrayLayout3ui6\", $i);\n\n  class Ri extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r, n, i, s, o, a, l, u, c, h, p, f, d, y, m) {\n      const g = this.length;\n      return this.resize(g + 1), this.emplace(g, t, e, r, n, i, s, o, a, l, u, c, h, p, f, d, y, m);\n    }\n\n    emplace(t, e, r, n, i, s, o, a, l, u, c, h, p, f, d, y, m, g) {\n      const x = 24 * t,\n            v = 12 * t,\n            b = 48 * t;\n      return this.int16[x + 0] = e, this.int16[x + 1] = r, this.uint16[x + 2] = n, this.uint16[x + 3] = i, this.uint32[v + 2] = s, this.uint32[v + 3] = o, this.uint32[v + 4] = a, this.uint16[x + 10] = l, this.uint16[x + 11] = u, this.uint16[x + 12] = c, this.float32[v + 7] = h, this.float32[v + 8] = p, this.uint8[b + 36] = f, this.uint8[b + 37] = d, this.uint8[b + 38] = y, this.uint32[v + 10] = m, this.int16[x + 22] = g, t;\n    }\n\n  }\n\n  Ri.prototype.bytesPerElement = 48, Je(\"StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48\", Ri);\n\n  class qi extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r, n, i, s, o, a, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, k, S, A, I, z) {\n      const M = this.length;\n      return this.resize(M + 1), this.emplace(M, t, e, r, n, i, s, o, a, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, k, S, A, I, z);\n    }\n\n    emplace(t, e, r, n, i, s, o, a, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, k, S, A, I, z, M) {\n      const B = 34 * t,\n            P = 17 * t;\n      return this.int16[B + 0] = e, this.int16[B + 1] = r, this.int16[B + 2] = n, this.int16[B + 3] = i, this.int16[B + 4] = s, this.int16[B + 5] = o, this.int16[B + 6] = a, this.int16[B + 7] = l, this.uint16[B + 8] = u, this.uint16[B + 9] = c, this.uint16[B + 10] = h, this.uint16[B + 11] = p, this.uint16[B + 12] = f, this.uint16[B + 13] = d, this.uint16[B + 14] = y, this.uint16[B + 15] = m, this.uint16[B + 16] = g, this.uint16[B + 17] = x, this.uint16[B + 18] = v, this.uint16[B + 19] = b, this.uint16[B + 20] = w, this.uint16[B + 21] = _, this.uint16[B + 22] = k, this.uint32[P + 12] = S, this.float32[P + 13] = A, this.float32[P + 14] = I, this.float32[P + 15] = z, this.float32[P + 16] = M, t;\n    }\n\n  }\n\n  qi.prototype.bytesPerElement = 68, Je(\"StructArrayLayout8i15ui1ul4f68\", qi);\n\n  class Ui extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t) {\n      const e = this.length;\n      return this.resize(e + 1), this.emplace(e, t);\n    }\n\n    emplace(t, e) {\n      return this.float32[1 * t + 0] = e, t;\n    }\n\n  }\n\n  Ui.prototype.bytesPerElement = 4, Je(\"StructArrayLayout1f4\", Ui);\n\n  class Ni extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r) {\n      const n = this.length;\n      return this.resize(n + 1), this.emplace(n, t, e, r);\n    }\n\n    emplace(t, e, r, n) {\n      const i = 3 * t;\n      return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;\n    }\n\n  }\n\n  Ni.prototype.bytesPerElement = 6, Je(\"StructArrayLayout3i6\", Ni);\n\n  class ji extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r, n) {\n      const i = this.length;\n      return this.resize(i + 1), this.emplace(i, t, e, r, n);\n    }\n\n    emplace(t, e, r, n, i) {\n      const s = 6 * t;\n      return this.uint32[3 * t + 0] = e, this.uint16[s + 2] = r, this.uint16[s + 3] = n, this.uint16[s + 4] = i, t;\n    }\n\n  }\n\n  ji.prototype.bytesPerElement = 12, Je(\"StructArrayLayout1ul3ui12\", ji);\n\n  class Zi extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e) {\n      const r = this.length;\n      return this.resize(r + 1), this.emplace(r, t, e);\n    }\n\n    emplace(t, e, r) {\n      const n = 2 * t;\n      return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t;\n    }\n\n  }\n\n  Zi.prototype.bytesPerElement = 4, Je(\"StructArrayLayout2ui4\", Zi);\n\n  class Gi extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t) {\n      const e = this.length;\n      return this.resize(e + 1), this.emplace(e, t);\n    }\n\n    emplace(t, e) {\n      return this.uint16[1 * t + 0] = e, t;\n    }\n\n  }\n\n  Gi.prototype.bytesPerElement = 2, Je(\"StructArrayLayout1ui2\", Gi);\n\n  class Xi extends Si {\n    _refreshViews() {\n      this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n    }\n\n    emplaceBack(t, e, r, n) {\n      const i = this.length;\n      return this.resize(i + 1), this.emplace(i, t, e, r, n);\n    }\n\n    emplace(t, e, r, n, i) {\n      const s = 4 * t;\n      return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t;\n    }\n\n  }\n\n  Xi.prototype.bytesPerElement = 16, Je(\"StructArrayLayout4f16\", Xi);\n\n  class Ji extends ki {\n    get anchorPointX() {\n      return this._structArray.int16[this._pos2 + 0];\n    }\n\n    get anchorPointY() {\n      return this._structArray.int16[this._pos2 + 1];\n    }\n\n    get x1() {\n      return this._structArray.float32[this._pos4 + 1];\n    }\n\n    get y1() {\n      return this._structArray.float32[this._pos4 + 2];\n    }\n\n    get x2() {\n      return this._structArray.float32[this._pos4 + 3];\n    }\n\n    get y2() {\n      return this._structArray.float32[this._pos4 + 4];\n    }\n\n    get padding() {\n      return this._structArray.int16[this._pos2 + 10];\n    }\n\n    get featureIndex() {\n      return this._structArray.uint32[this._pos4 + 6];\n    }\n\n    get sourceLayerIndex() {\n      return this._structArray.uint16[this._pos2 + 14];\n    }\n\n    get bucketIndex() {\n      return this._structArray.uint16[this._pos2 + 15];\n    }\n\n    get anchorPoint() {\n      return new r(this.anchorPointX, this.anchorPointY);\n    }\n\n  }\n\n  Ji.prototype.size = 32;\n\n  class Yi extends Di {\n    get(t) {\n      return new Ji(this, t);\n    }\n\n  }\n\n  Je(\"CollisionBoxArray\", Yi);\n\n  class Ki extends ki {\n    get anchorX() {\n      return this._structArray.int16[this._pos2 + 0];\n    }\n\n    get anchorY() {\n      return this._structArray.int16[this._pos2 + 1];\n    }\n\n    get glyphStartIndex() {\n      return this._structArray.uint16[this._pos2 + 2];\n    }\n\n    get numGlyphs() {\n      return this._structArray.uint16[this._pos2 + 3];\n    }\n\n    get vertexStartIndex() {\n      return this._structArray.uint32[this._pos4 + 2];\n    }\n\n    get lineStartIndex() {\n      return this._structArray.uint32[this._pos4 + 3];\n    }\n\n    get lineLength() {\n      return this._structArray.uint32[this._pos4 + 4];\n    }\n\n    get segment() {\n      return this._structArray.uint16[this._pos2 + 10];\n    }\n\n    get lowerSize() {\n      return this._structArray.uint16[this._pos2 + 11];\n    }\n\n    get upperSize() {\n      return this._structArray.uint16[this._pos2 + 12];\n    }\n\n    get lineOffsetX() {\n      return this._structArray.float32[this._pos4 + 7];\n    }\n\n    get lineOffsetY() {\n      return this._structArray.float32[this._pos4 + 8];\n    }\n\n    get writingMode() {\n      return this._structArray.uint8[this._pos1 + 36];\n    }\n\n    get placedOrientation() {\n      return this._structArray.uint8[this._pos1 + 37];\n    }\n\n    set placedOrientation(t) {\n      this._structArray.uint8[this._pos1 + 37] = t;\n    }\n\n    get hidden() {\n      return this._structArray.uint8[this._pos1 + 38];\n    }\n\n    set hidden(t) {\n      this._structArray.uint8[this._pos1 + 38] = t;\n    }\n\n    get crossTileID() {\n      return this._structArray.uint32[this._pos4 + 10];\n    }\n\n    set crossTileID(t) {\n      this._structArray.uint32[this._pos4 + 10] = t;\n    }\n\n    get associatedIconIndex() {\n      return this._structArray.int16[this._pos2 + 22];\n    }\n\n  }\n\n  Ki.prototype.size = 48;\n\n  class Hi extends Ri {\n    get(t) {\n      return new Ki(this, t);\n    }\n\n  }\n\n  Je(\"PlacedSymbolArray\", Hi);\n\n  class Wi extends ki {\n    get anchorX() {\n      return this._structArray.int16[this._pos2 + 0];\n    }\n\n    get anchorY() {\n      return this._structArray.int16[this._pos2 + 1];\n    }\n\n    get rightJustifiedTextSymbolIndex() {\n      return this._structArray.int16[this._pos2 + 2];\n    }\n\n    get centerJustifiedTextSymbolIndex() {\n      return this._structArray.int16[this._pos2 + 3];\n    }\n\n    get leftJustifiedTextSymbolIndex() {\n      return this._structArray.int16[this._pos2 + 4];\n    }\n\n    get verticalPlacedTextSymbolIndex() {\n      return this._structArray.int16[this._pos2 + 5];\n    }\n\n    get placedIconSymbolIndex() {\n      return this._structArray.int16[this._pos2 + 6];\n    }\n\n    get verticalPlacedIconSymbolIndex() {\n      return this._structArray.int16[this._pos2 + 7];\n    }\n\n    get key() {\n      return this._structArray.uint16[this._pos2 + 8];\n    }\n\n    get textBoxStartIndex() {\n      return this._structArray.uint16[this._pos2 + 9];\n    }\n\n    get textBoxEndIndex() {\n      return this._structArray.uint16[this._pos2 + 10];\n    }\n\n    get verticalTextBoxStartIndex() {\n      return this._structArray.uint16[this._pos2 + 11];\n    }\n\n    get verticalTextBoxEndIndex() {\n      return this._structArray.uint16[this._pos2 + 12];\n    }\n\n    get iconBoxStartIndex() {\n      return this._structArray.uint16[this._pos2 + 13];\n    }\n\n    get iconBoxEndIndex() {\n      return this._structArray.uint16[this._pos2 + 14];\n    }\n\n    get verticalIconBoxStartIndex() {\n      return this._structArray.uint16[this._pos2 + 15];\n    }\n\n    get verticalIconBoxEndIndex() {\n      return this._structArray.uint16[this._pos2 + 16];\n    }\n\n    get featureIndex() {\n      return this._structArray.uint16[this._pos2 + 17];\n    }\n\n    get numHorizontalGlyphVertices() {\n      return this._structArray.uint16[this._pos2 + 18];\n    }\n\n    get numVerticalGlyphVertices() {\n      return this._structArray.uint16[this._pos2 + 19];\n    }\n\n    get numIconVertices() {\n      return this._structArray.uint16[this._pos2 + 20];\n    }\n\n    get numVerticalIconVertices() {\n      return this._structArray.uint16[this._pos2 + 21];\n    }\n\n    get useRuntimeCollisionCircles() {\n      return this._structArray.uint16[this._pos2 + 22];\n    }\n\n    get crossTileID() {\n      return this._structArray.uint32[this._pos4 + 12];\n    }\n\n    set crossTileID(t) {\n      this._structArray.uint32[this._pos4 + 12] = t;\n    }\n\n    get textBoxScale() {\n      return this._structArray.float32[this._pos4 + 13];\n    }\n\n    get textOffset0() {\n      return this._structArray.float32[this._pos4 + 14];\n    }\n\n    get textOffset1() {\n      return this._structArray.float32[this._pos4 + 15];\n    }\n\n    get collisionCircleDiameter() {\n      return this._structArray.float32[this._pos4 + 16];\n    }\n\n  }\n\n  Wi.prototype.size = 68;\n\n  class Qi extends qi {\n    get(t) {\n      return new Wi(this, t);\n    }\n\n  }\n\n  Je(\"SymbolInstanceArray\", Qi);\n\n  class ts extends Ui {\n    getoffsetX(t) {\n      return this.float32[1 * t + 0];\n    }\n\n  }\n\n  Je(\"GlyphOffsetArray\", ts);\n\n  class es extends Ni {\n    getx(t) {\n      return this.int16[3 * t + 0];\n    }\n\n    gety(t) {\n      return this.int16[3 * t + 1];\n    }\n\n    gettileUnitDistanceFromAnchor(t) {\n      return this.int16[3 * t + 2];\n    }\n\n  }\n\n  Je(\"SymbolLineVertexArray\", es);\n\n  class rs extends ki {\n    get featureIndex() {\n      return this._structArray.uint32[this._pos4 + 0];\n    }\n\n    get sourceLayerIndex() {\n      return this._structArray.uint16[this._pos2 + 2];\n    }\n\n    get bucketIndex() {\n      return this._structArray.uint16[this._pos2 + 3];\n    }\n\n    get layoutVertexArrayOffset() {\n      return this._structArray.uint16[this._pos2 + 4];\n    }\n\n  }\n\n  rs.prototype.size = 12;\n\n  class ns extends ji {\n    get(t) {\n      return new rs(this, t);\n    }\n\n  }\n\n  Je(\"FeatureIndexArray\", ns);\n\n  class is extends ki {\n    get a_centroid_pos0() {\n      return this._structArray.uint16[this._pos2 + 0];\n    }\n\n    get a_centroid_pos1() {\n      return this._structArray.uint16[this._pos2 + 1];\n    }\n\n  }\n\n  is.prototype.size = 4;\n\n  class ss extends Zi {\n    get(t) {\n      return new is(this, t);\n    }\n\n  }\n\n  Je(\"FillExtrusionCentroidArray\", ss);\n  const os = Ai([{\n    name: \"a_pattern_to\",\n    components: 4,\n    type: \"Uint16\"\n  }, {\n    name: \"a_pattern_from\",\n    components: 4,\n    type: \"Uint16\"\n  }, {\n    name: \"a_pixel_ratio_to\",\n    components: 1,\n    type: \"Uint16\"\n  }, {\n    name: \"a_pixel_ratio_from\",\n    components: 1,\n    type: \"Uint16\"\n  }]);\n  var as = M(function (t) {\n    t.exports = function (t, e) {\n      var r, n, i, s, o, a, l, u;\n\n      for (n = t.length - (r = 3 & t.length), i = e, o = 3432918353, a = 461845907, u = 0; u < n;) l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);\n\n      switch (l = 0, r) {\n        case 3:\n          l ^= (255 & t.charCodeAt(u + 2)) << 16;\n\n        case 2:\n          l ^= (255 & t.charCodeAt(u + 1)) << 8;\n\n        case 1:\n          i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295;\n      }\n\n      return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;\n    };\n  }),\n      ls = M(function (t) {\n    t.exports = function (t, e) {\n      for (var r, n = t.length, i = e ^ n, s = 0; n >= 4;) r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(s) | (255 & t.charCodeAt(++s)) << 8 | (255 & t.charCodeAt(++s)) << 16 | (255 & t.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;\n\n      switch (n) {\n        case 3:\n          i ^= (255 & t.charCodeAt(s + 2)) << 16;\n\n        case 2:\n          i ^= (255 & t.charCodeAt(s + 1)) << 8;\n\n        case 1:\n          i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);\n      }\n\n      return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;\n    };\n  }),\n      us = as,\n      cs = ls;\n  us.murmur3 = as, us.murmur2 = cs;\n\n  class hs {\n    constructor() {\n      this.ids = [], this.positions = [], this.indexed = !1;\n    }\n\n    add(t, e, r, n) {\n      this.ids.push(ps(t)), this.positions.push(e, r, n);\n    }\n\n    getPositions(t) {\n      const e = ps(t);\n      let r = 0,\n          n = this.ids.length - 1;\n\n      for (; r < n;) {\n        const t = r + n >> 1;\n        this.ids[t] >= e ? n = t : r = t + 1;\n      }\n\n      const i = [];\n\n      for (; this.ids[r] === e;) i.push({\n        index: this.positions[3 * r],\n        start: this.positions[3 * r + 1],\n        end: this.positions[3 * r + 2]\n      }), r++;\n\n      return i;\n    }\n\n    static serialize(t, e) {\n      const r = new Float64Array(t.ids),\n            n = new Uint32Array(t.positions);\n      return function t(e, r, n, i) {\n        for (; n < i;) {\n          const s = e[n + i >> 1];\n          let o = n - 1,\n              a = i + 1;\n\n          for (;;) {\n            do {\n              o++;\n            } while (e[o] < s);\n\n            do {\n              a--;\n            } while (e[a] > s);\n\n            if (o >= a) break;\n            fs(e, o, a), fs(r, 3 * o, 3 * a), fs(r, 3 * o + 1, 3 * a + 1), fs(r, 3 * o + 2, 3 * a + 2);\n          }\n\n          a - n < i - a ? (t(e, r, n, a), n = a + 1) : (t(e, r, a + 1, i), i = a);\n        }\n      }(r, n, 0, r.length - 1), e && e.push(r.buffer, n.buffer), {\n        ids: r,\n        positions: n\n      };\n    }\n\n    static deserialize(t) {\n      const e = new hs();\n      return e.ids = t.ids, e.positions = t.positions, e.indexed = !0, e;\n    }\n\n  }\n\n  function ps(t) {\n    const e = +t;\n    return !isNaN(e) && e <= s ? e : us(String(t));\n  }\n\n  function fs(t, e, r) {\n    const n = t[e];\n    t[e] = t[r], t[r] = n;\n  }\n\n  Je(\"FeaturePositionMap\", hs);\n\n  class ds {\n    constructor(t, e) {\n      this.gl = t.gl, this.location = e;\n    }\n\n  }\n\n  class ys extends ds {\n    constructor(t, e) {\n      super(t, e), this.current = 0;\n    }\n\n    set(t) {\n      this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));\n    }\n\n  }\n\n  class ms extends ds {\n    constructor(t, e) {\n      super(t, e), this.current = [0, 0, 0, 0];\n    }\n\n    set(t) {\n      t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));\n    }\n\n  }\n\n  class gs extends ds {\n    constructor(t, e) {\n      super(t, e), this.current = P.transparent;\n    }\n\n    set(t) {\n      t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));\n    }\n\n  }\n\n  function xs(t) {\n    return [wi(255 * t.r, 255 * t.g), wi(255 * t.b, 255 * t.a)];\n  }\n\n  class vs {\n    constructor(t, e, r) {\n      this.value = t, this.uniformNames = e.map(t => `u_${t}`), this.type = r;\n    }\n\n    setUniform(t, e, r) {\n      t.set(r.constantOr(this.value));\n    }\n\n    getBinding(t, e, r) {\n      return \"color\" === this.type ? new gs(t, e) : new ys(t, e);\n    }\n\n  }\n\n  class bs {\n    constructor(t, e) {\n      this.uniformNames = e.map(t => `u_${t}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;\n    }\n\n    setConstantPatternPositions(t, e) {\n      this.pixelRatioFrom = e.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = e.tlbr, this.patternTo = t.tlbr;\n    }\n\n    setUniform(t, e, r, n) {\n      const i = \"u_pattern_to\" === n ? this.patternTo : \"u_pattern_from\" === n ? this.patternFrom : \"u_pixel_ratio_to\" === n ? this.pixelRatioTo : \"u_pixel_ratio_from\" === n ? this.pixelRatioFrom : null;\n      i && t.set(i);\n    }\n\n    getBinding(t, e, r) {\n      return \"u_pattern\" === r.substr(0, 9) ? new ms(t, e) : new ys(t, e);\n    }\n\n  }\n\n  class ws {\n    constructor(t, e, r, n) {\n      this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n        name: `a_${t}`,\n        type: \"Float32\",\n        components: \"color\" === r ? 2 : 1,\n        offset: 0\n      })), this.paintVertexArray = new n();\n    }\n\n    populatePaintArray(t, e, r, n, i) {\n      const s = this.paintVertexArray.length,\n            o = this.expression.evaluate(new oi(0), e, {}, n, [], i);\n      this.paintVertexArray.resize(t), this._setPaintValue(s, t, o);\n    }\n\n    updatePaintArray(t, e, r, n) {\n      const i = this.expression.evaluate({\n        zoom: 0\n      }, r, n);\n\n      this._setPaintValue(t, e, i);\n    }\n\n    _setPaintValue(t, e, r) {\n      if (\"color\" === this.type) {\n        const n = xs(r);\n\n        for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, n[0], n[1]);\n      } else {\n        for (let n = t; n < e; n++) this.paintVertexArray.emplace(n, r);\n\n        this.maxValue = Math.max(this.maxValue, Math.abs(r));\n      }\n    }\n\n    upload(t) {\n      this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n    }\n\n    destroy() {\n      this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n    }\n\n  }\n\n  class _s {\n    constructor(t, e, r, n, i, s) {\n      this.expression = t, this.uniformNames = e.map(t => `u_${t}_t`), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n        name: `a_${t}`,\n        type: \"Float32\",\n        components: \"color\" === r ? 4 : 2,\n        offset: 0\n      })), this.paintVertexArray = new s();\n    }\n\n    populatePaintArray(t, e, r, n, i) {\n      const s = this.expression.evaluate(new oi(this.zoom), e, {}, n, [], i),\n            o = this.expression.evaluate(new oi(this.zoom + 1), e, {}, n, [], i),\n            a = this.paintVertexArray.length;\n      this.paintVertexArray.resize(t), this._setPaintValue(a, t, s, o);\n    }\n\n    updatePaintArray(t, e, r, n) {\n      const i = this.expression.evaluate({\n        zoom: this.zoom\n      }, r, n),\n            s = this.expression.evaluate({\n        zoom: this.zoom + 1\n      }, r, n);\n\n      this._setPaintValue(t, e, i, s);\n    }\n\n    _setPaintValue(t, e, r, n) {\n      if (\"color\" === this.type) {\n        const i = xs(r),\n              s = xs(n);\n\n        for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, i[0], i[1], s[0], s[1]);\n      } else {\n        for (let i = t; i < e; i++) this.paintVertexArray.emplace(i, r, n);\n\n        this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));\n      }\n    }\n\n    upload(t) {\n      this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n    }\n\n    destroy() {\n      this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n    }\n\n    setUniform(t, e) {\n      const r = this.useIntegerZoom ? Math.floor(e.zoom) : e.zoom,\n            n = l(this.expression.interpolationFactor(r, this.zoom, this.zoom + 1), 0, 1);\n      t.set(n);\n    }\n\n    getBinding(t, e, r) {\n      return new ys(t, e);\n    }\n\n  }\n\n  class ks {\n    constructor(t, e, r, n, i, s, o) {\n      this.expression = t, this.type = r, this.useIntegerZoom = n, this.zoom = i, this.layerId = o;\n\n      for (let t = 0; t < e.length; ++t);\n\n      this.zoomInPaintVertexArray = new s(), this.zoomOutPaintVertexArray = new s();\n    }\n\n    populatePaintArray(t, e, r) {\n      const n = this.zoomInPaintVertexArray.length;\n      this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], r);\n    }\n\n    updatePaintArray(t, e, r, n, i) {\n      this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], i);\n    }\n\n    _setPaintValues(t, e, r, n) {\n      if (!n || !r) return;\n      const {\n        min: i,\n        mid: s,\n        max: o\n      } = r,\n            a = n[i],\n            l = n[s],\n            u = n[o];\n      if (a && l && u) for (let r = t; r < e; r++) this.zoomInPaintVertexArray.emplace(r, l.tl[0], l.tl[1], l.br[0], l.br[1], a.tl[0], a.tl[1], a.br[0], a.br[1], l.pixelRatio, a.pixelRatio), this.zoomOutPaintVertexArray.emplace(r, l.tl[0], l.tl[1], l.br[0], l.br[1], u.tl[0], u.tl[1], u.br[0], u.br[1], l.pixelRatio, u.pixelRatio);\n    }\n\n    upload(t) {\n      this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, os.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, os.members, this.expression.isStateDependent));\n    }\n\n    destroy() {\n      this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();\n    }\n\n  }\n\n  class Ss {\n    constructor(t, e, r = () => !0) {\n      this.binders = {}, this._buffers = [];\n      const n = [];\n\n      for (const i in t.paint._values) {\n        if (!r(i)) continue;\n        const s = t.paint.get(i);\n        if (!(s instanceof fi && ze(s.property.specification))) continue;\n        const o = Is(i, t.type),\n              a = s.value,\n              l = s.property.specification.type,\n              u = s.property.useIntegerZoom,\n              c = s.property.specification[\"property-type\"],\n              h = \"cross-faded\" === c || \"cross-faded-data-driven\" === c;\n        if (\"constant\" === a.kind) this.binders[i] = h ? new bs(a.value, o) : new vs(a.value, o, l), n.push(`/u_${i}`);else if (\"source\" === a.kind || h) {\n          const r = zs(i, l, \"source\");\n          this.binders[i] = h ? new ks(a, o, l, u, e, r, t.id) : new ws(a, o, l, r), n.push(`/a_${i}`);\n        } else {\n          const t = zs(i, l, \"composite\");\n          this.binders[i] = new _s(a, o, l, u, e, t), n.push(`/z_${i}`);\n        }\n      }\n\n      this.cacheKey = n.sort().join(\"\");\n    }\n\n    getMaxValue(t) {\n      const e = this.binders[t];\n      return e instanceof ws || e instanceof _s ? e.maxValue : 0;\n    }\n\n    populatePaintArrays(t, e, r, n, i) {\n      for (const s in this.binders) {\n        const o = this.binders[s];\n        (o instanceof ws || o instanceof _s || o instanceof ks) && o.populatePaintArray(t, e, r, n, i);\n      }\n    }\n\n    setConstantPatternPositions(t, e) {\n      for (const r in this.binders) {\n        const n = this.binders[r];\n        n instanceof bs && n.setConstantPatternPositions(t, e);\n      }\n    }\n\n    updatePaintArrays(t, e, r, n, i) {\n      let s = !1;\n\n      for (const o in t) {\n        const a = e.getPositions(o);\n\n        for (const e of a) {\n          const a = r.feature(e.index);\n\n          for (const r in this.binders) {\n            const l = this.binders[r];\n\n            if ((l instanceof ws || l instanceof _s || l instanceof ks) && !0 === l.expression.isStateDependent) {\n              const u = n.paint.get(r);\n              l.expression = u.value, l.updatePaintArray(e.start, e.end, a, t[o], i), s = !0;\n            }\n          }\n        }\n      }\n\n      return s;\n    }\n\n    defines() {\n      const t = [];\n\n      for (const e in this.binders) {\n        const r = this.binders[e];\n        (r instanceof vs || r instanceof bs) && t.push(...r.uniformNames.map(t => `#define HAS_UNIFORM_${t}`));\n      }\n\n      return t;\n    }\n\n    getBinderAttributes() {\n      const t = [];\n\n      for (const e in this.binders) {\n        const r = this.binders[e];\n        if (r instanceof ws || r instanceof _s) for (let e = 0; e < r.paintVertexAttributes.length; e++) t.push(r.paintVertexAttributes[e].name);else if (r instanceof ks) for (let e = 0; e < os.members.length; e++) t.push(os.members[e].name);\n      }\n\n      return t;\n    }\n\n    getBinderUniforms() {\n      const t = [];\n\n      for (const e in this.binders) {\n        const r = this.binders[e];\n        if (r instanceof vs || r instanceof bs || r instanceof _s) for (const e of r.uniformNames) t.push(e);\n      }\n\n      return t;\n    }\n\n    getPaintVertexBuffers() {\n      return this._buffers;\n    }\n\n    getUniforms(t, e) {\n      const r = [];\n\n      for (const n in this.binders) {\n        const i = this.binders[n];\n        if (i instanceof vs || i instanceof bs || i instanceof _s) for (const s of i.uniformNames) if (e[s]) {\n          const o = i.getBinding(t, e[s], s);\n          r.push({\n            name: s,\n            property: n,\n            binding: o\n          });\n        }\n      }\n\n      return r;\n    }\n\n    setUniforms(t, e, r, n) {\n      for (const {\n        name: t,\n        property: i,\n        binding: s\n      } of e) this.binders[i].setUniform(s, n, r.get(i), t);\n    }\n\n    updatePaintBuffers(t) {\n      this._buffers = [];\n\n      for (const e in this.binders) {\n        const r = this.binders[e];\n\n        if (t && r instanceof ks) {\n          const e = 2 === t.fromScale ? r.zoomInPaintVertexBuffer : r.zoomOutPaintVertexBuffer;\n          e && this._buffers.push(e);\n        } else (r instanceof ws || r instanceof _s) && r.paintVertexBuffer && this._buffers.push(r.paintVertexBuffer);\n      }\n    }\n\n    upload(t) {\n      for (const e in this.binders) {\n        const r = this.binders[e];\n        (r instanceof ws || r instanceof _s || r instanceof ks) && r.upload(t);\n      }\n\n      this.updatePaintBuffers();\n    }\n\n    destroy() {\n      for (const t in this.binders) {\n        const e = this.binders[t];\n        (e instanceof ws || e instanceof _s || e instanceof ks) && e.destroy();\n      }\n    }\n\n  }\n\n  class As {\n    constructor(t, e, r = () => !0) {\n      this.programConfigurations = {};\n\n      for (const n of t) this.programConfigurations[n.id] = new Ss(n, e, r);\n\n      this.needsUpload = !1, this._featureMap = new hs(), this._bufferOffset = 0;\n    }\n\n    populatePaintArrays(t, e, r, n, i, s) {\n      for (const r in this.programConfigurations) this.programConfigurations[r].populatePaintArrays(t, e, n, i, s);\n\n      void 0 !== e.id && this._featureMap.add(e.id, r, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;\n    }\n\n    updatePaintArrays(t, e, r, n) {\n      for (const i of r) this.needsUpload = this.programConfigurations[i.id].updatePaintArrays(t, this._featureMap, e, i, n) || this.needsUpload;\n    }\n\n    get(t) {\n      return this.programConfigurations[t];\n    }\n\n    upload(t) {\n      if (this.needsUpload) {\n        for (const e in this.programConfigurations) this.programConfigurations[e].upload(t);\n\n        this.needsUpload = !1;\n      }\n    }\n\n    destroy() {\n      for (const t in this.programConfigurations) this.programConfigurations[t].destroy();\n    }\n\n  }\n\n  function Is(t, e) {\n    return {\n      \"text-opacity\": [\"opacity\"],\n      \"icon-opacity\": [\"opacity\"],\n      \"text-color\": [\"fill_color\"],\n      \"icon-color\": [\"fill_color\"],\n      \"text-halo-color\": [\"halo_color\"],\n      \"icon-halo-color\": [\"halo_color\"],\n      \"text-halo-blur\": [\"halo_blur\"],\n      \"icon-halo-blur\": [\"halo_blur\"],\n      \"text-halo-width\": [\"halo_width\"],\n      \"icon-halo-width\": [\"halo_width\"],\n      \"line-gap-width\": [\"gapwidth\"],\n      \"line-pattern\": [\"pattern_to\", \"pattern_from\", \"pixel_ratio_to\", \"pixel_ratio_from\"],\n      \"fill-pattern\": [\"pattern_to\", \"pattern_from\", \"pixel_ratio_to\", \"pixel_ratio_from\"],\n      \"fill-extrusion-pattern\": [\"pattern_to\", \"pattern_from\", \"pixel_ratio_to\", \"pixel_ratio_from\"]\n    }[t] || [t.replace(`${e}-`, \"\").replace(/-/g, \"_\")];\n  }\n\n  function zs(t, e, r) {\n    const n = {\n      color: {\n        source: Pi,\n        composite: Xi\n      },\n      number: {\n        source: Ui,\n        composite: Pi\n      }\n    },\n          i = function (t) {\n      return {\n        \"line-pattern\": {\n          source: Ci,\n          composite: Ci\n        },\n        \"fill-pattern\": {\n          source: Ci,\n          composite: Ci\n        },\n        \"fill-extrusion-pattern\": {\n          source: Ci,\n          composite: Ci\n        }\n      }[t];\n    }(t);\n\n    return i && i[r] || n[e][r];\n  }\n\n  Je(\"ConstantBinder\", vs), Je(\"CrossFadedConstantBinder\", bs), Je(\"SourceExpressionBinder\", ws), Je(\"CrossFadedCompositeBinder\", ks), Je(\"CompositeExpressionBinder\", _s), Je(\"ProgramConfiguration\", Ss, {\n    omit: [\"_buffers\"]\n  }), Je(\"ProgramConfigurationSet\", As);\n\n  class Ms extends Zr {\n    constructor(t, e) {\n      if (super(), this.id = t.id, this.type = t.type, this._featureFilter = {\n        filter: () => !0,\n        needGeometry: !1\n      }, \"custom\" !== t.type && (this.metadata = (t = t).metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, \"background\" !== t.type && \"sky\" !== t.type && (this.source = t.source, this.sourceLayer = t[\"source-layer\"], this.filter = t.filter), e.layout && (this._unevaluatedLayout = new pi(e.layout)), e.paint)) {\n        this._transitionablePaint = new ui(e.paint);\n\n        for (const e in t.paint) this.setPaintProperty(e, t.paint[e], {\n          validate: !1\n        });\n\n        for (const e in t.layout) this.setLayoutProperty(e, t.layout[e], {\n          validate: !1\n        });\n\n        this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new di(e.paint);\n      }\n    }\n\n    getCrossfadeParameters() {\n      return this._crossfadeParameters;\n    }\n\n    getLayoutProperty(t) {\n      return \"visibility\" === t ? this.visibility : this._unevaluatedLayout.getValue(t);\n    }\n\n    setLayoutProperty(t, e, r = {}) {\n      null != e && this._validate(Jr, `layers.${this.id}.layout.${t}`, t, e, r) || (\"visibility\" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e);\n    }\n\n    getPaintProperty(t) {\n      return d(t, \"-transition\") ? this._transitionablePaint.getTransition(t.slice(0, -\"-transition\".length)) : this._transitionablePaint.getValue(t);\n    }\n\n    setPaintProperty(t, e, r = {}) {\n      if (null != e && this._validate(Xr, `layers.${this.id}.paint.${t}`, t, e, r)) return !1;\n      if (d(t, \"-transition\")) return this._transitionablePaint.setTransition(t.slice(0, -\"-transition\".length), e || void 0), !1;\n      {\n        const r = this._transitionablePaint._values[t],\n              n = \"cross-faded-data-driven\" === r.property.specification[\"property-type\"],\n              i = r.value.isDataDriven(),\n              s = r.value;\n        this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t);\n        const o = this._transitionablePaint._values[t].value;\n        return o.isDataDriven() || i || n || this._handleOverridablePaintPropertyUpdate(t, s, o);\n      }\n    }\n\n    _handleSpecialPaintPropertyUpdate(t) {}\n\n    getProgramIds() {\n      return null;\n    }\n\n    getProgramConfiguration(t) {\n      return null;\n    }\n\n    _handleOverridablePaintPropertyUpdate(t, e, r) {\n      return !1;\n    }\n\n    isHidden(t) {\n      return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || \"none\" === this.visibility;\n    }\n\n    updateTransitions(t) {\n      this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);\n    }\n\n    hasTransition() {\n      return this._transitioningPaint.hasTransition();\n    }\n\n    recalculate(t, e) {\n      t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);\n    }\n\n    serialize() {\n      const t = {\n        id: this.id,\n        type: this.type,\n        source: this.source,\n        \"source-layer\": this.sourceLayer,\n        metadata: this.metadata,\n        minzoom: this.minzoom,\n        maxzoom: this.maxzoom,\n        filter: this.filter,\n        layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),\n        paint: this._transitionablePaint && this._transitionablePaint.serialize()\n      };\n      return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), function (t, e, r) {\n        const n = {};\n\n        for (const r in t) e.call(this, t[r], r, t) && (n[r] = t[r]);\n\n        return n;\n      }(t, (t, e) => !(void 0 === t || \"layout\" === e && !Object.keys(t).length || \"paint\" === e && !Object.keys(t).length));\n    }\n\n    _validate(t, e, r, n, i = {}) {\n      return (!i || !1 !== i.validate) && function (t, e) {\n        let r = !1;\n        if (e && e.length) for (const n of e) t.fire(new jr(new Error(n.message))), r = !0;\n        return r;\n      }(this, t.call(Gr, {\n        key: e,\n        layerType: this.type,\n        objectKey: r,\n        value: n,\n        styleSpec: sr,\n        style: {\n          glyphs: !0,\n          sprite: !0\n        }\n      }));\n    }\n\n    is3D() {\n      return !1;\n    }\n\n    isSky() {\n      return !1;\n    }\n\n    isTileClipped() {\n      return !1;\n    }\n\n    hasOffscreenPass() {\n      return !1;\n    }\n\n    resize() {}\n\n    isStateDependent() {\n      for (const t in this.paint._values) {\n        const e = this.paint.get(t);\n        if (e instanceof fi && ze(e.property.specification) && (\"source\" === e.value.kind || \"composite\" === e.value.kind) && e.value.isStateDependent) return !0;\n      }\n\n      return !1;\n    }\n\n  }\n\n  const Bs = Ai([{\n    name: \"a_pos\",\n    components: 2,\n    type: \"Int16\"\n  }], 4),\n        {\n    members: Ps\n  } = Bs;\n\n  class Cs {\n    constructor(t = []) {\n      this.segments = t;\n    }\n\n    prepareSegment(t, e, r, n) {\n      let i = this.segments[this.segments.length - 1];\n      return t > Cs.MAX_VERTEX_ARRAY_LENGTH && x(`Max vertices per segment is ${Cs.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!i || i.vertexLength + t > Cs.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {\n        vertexOffset: e.length,\n        primitiveOffset: r.length,\n        vertexLength: 0,\n        primitiveLength: 0\n      }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;\n    }\n\n    get() {\n      return this.segments;\n    }\n\n    destroy() {\n      for (const t of this.segments) for (const e in t.vaos) t.vaos[e].destroy();\n    }\n\n    static simpleSegment(t, e, r, n) {\n      return new Cs([{\n        vertexOffset: t,\n        primitiveOffset: e,\n        vertexLength: r,\n        primitiveLength: n,\n        vaos: {},\n        sortKey: 0\n      }]);\n    }\n\n  }\n\n  Cs.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Je(\"SegmentVector\", Cs);\n  const Vs = Math.pow(2, 14) - 1,\n        Ts = -Vs - 1;\n\n  function Es(t) {\n    const e = 8192 / t.extent,\n          r = t.loadGeometry();\n\n    for (let t = 0; t < r.length; t++) {\n      const n = r[t];\n\n      for (let t = 0; t < n.length; t++) {\n        const r = n[t],\n              i = Math.round(r.x * e),\n              s = Math.round(r.y * e);\n        r.x = l(i, Ts, Vs), r.y = l(s, Ts, Vs), (i < r.x || i > r.x + 1 || s < r.y || s > r.y + 1) && x(\"Geometry exceeds allowed extent, reduce your vector tile buffer size\");\n      }\n    }\n\n    return r;\n  }\n\n  function Ds(t, e) {\n    return {\n      type: t.type,\n      id: t.id,\n      properties: t.properties,\n      geometry: e ? Es(t) : []\n    };\n  }\n\n  function Fs(t, e, r, n, i) {\n    t.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);\n  }\n\n  class Ls {\n    constructor(t) {\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new zi(), this.indexArray = new $i(), this.segments = new Cs(), this.programConfigurations = new As(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n    }\n\n    populate(t, e, r) {\n      const n = this.layers[0],\n            i = [];\n      let s = null;\n      \"circle\" === n.type && (s = n.layout.get(\"circle-sort-key\"));\n\n      for (const {\n        feature: e,\n        id: n,\n        index: o,\n        sourceLayerIndex: a\n      } of t) {\n        const t = this.layers[0]._featureFilter.needGeometry,\n              l = Ds(e, t);\n        if (!this.layers[0]._featureFilter.filter(new oi(this.zoom), l, r)) continue;\n        const u = s ? s.evaluate(l, {}, r) : void 0,\n              c = {\n          id: n,\n          properties: e.properties,\n          type: e.type,\n          sourceLayerIndex: a,\n          index: o,\n          geometry: t ? l.geometry : Es(e),\n          patterns: {},\n          sortKey: u\n        };\n        i.push(c);\n      }\n\n      s && i.sort((t, e) => t.sortKey - e.sortKey);\n\n      for (const n of i) {\n        const {\n          geometry: i,\n          index: s,\n          sourceLayerIndex: o\n        } = n,\n              a = t[s].feature;\n        this.addFeature(n, i, s, r), e.featureIndex.insert(a, i, s, o, this.index);\n      }\n    }\n\n    update(t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }\n\n    isEmpty() {\n      return 0 === this.layoutVertexArray.length;\n    }\n\n    uploadPending() {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }\n\n    upload(t) {\n      this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ps), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }\n\n    destroy() {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n    }\n\n    addFeature(t, e, r, n) {\n      for (const r of e) for (const e of r) {\n        const r = e.x,\n              n = e.y;\n        if (r < 0 || r >= 8192 || n < 0 || n >= 8192) continue;\n        const i = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),\n              s = i.vertexLength;\n        Fs(this.layoutVertexArray, r, n, -1, -1), Fs(this.layoutVertexArray, r, n, 1, -1), Fs(this.layoutVertexArray, r, n, 1, 1), Fs(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(s, s + 1, s + 2), this.indexArray.emplaceBack(s, s + 3, s + 2), i.vertexLength += 4, i.primitiveLength += 2;\n      }\n\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n);\n    }\n\n  }\n\n  function Os(t, e) {\n    for (let r = 0; r < t.length; r++) if (Xs(e, t[r])) return !0;\n\n    for (let r = 0; r < e.length; r++) if (Xs(t, e[r])) return !0;\n\n    return !!Us(t, e);\n  }\n\n  function $s(t, e, r) {\n    return !!Xs(t, e) || !!js(e, t, r);\n  }\n\n  function Rs(t, e) {\n    if (1 === t.length) return Gs(e, t[0]);\n\n    for (let r = 0; r < e.length; r++) {\n      const n = e[r];\n\n      for (let e = 0; e < n.length; e++) if (Xs(t, n[e])) return !0;\n    }\n\n    for (let r = 0; r < t.length; r++) if (Gs(e, t[r])) return !0;\n\n    for (let r = 0; r < e.length; r++) if (Us(t, e[r])) return !0;\n\n    return !1;\n  }\n\n  function qs(t, e, r) {\n    if (t.length > 1) {\n      if (Us(t, e)) return !0;\n\n      for (let n = 0; n < e.length; n++) if (js(e[n], t, r)) return !0;\n    }\n\n    for (let n = 0; n < t.length; n++) if (js(t[n], e, r)) return !0;\n\n    return !1;\n  }\n\n  function Us(t, e) {\n    if (0 === t.length || 0 === e.length) return !1;\n\n    for (let r = 0; r < t.length - 1; r++) {\n      const n = t[r],\n            i = t[r + 1];\n\n      for (let t = 0; t < e.length - 1; t++) if (Ns(n, i, e[t], e[t + 1])) return !0;\n    }\n\n    return !1;\n  }\n\n  function Ns(t, e, r, n) {\n    return v(t, r, n) !== v(e, r, n) && v(t, e, r) !== v(t, e, n);\n  }\n\n  function js(t, e, r) {\n    const n = r * r;\n    if (1 === e.length) return t.distSqr(e[0]) < n;\n\n    for (let r = 1; r < e.length; r++) if (Zs(t, e[r - 1], e[r]) < n) return !0;\n\n    return !1;\n  }\n\n  function Zs(t, e, r) {\n    const n = e.distSqr(r);\n    if (0 === n) return t.distSqr(e);\n    const i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;\n    return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));\n  }\n\n  function Gs(t, e) {\n    let r,\n        n,\n        i,\n        s = !1;\n\n    for (let o = 0; o < t.length; o++) {\n      r = t[o];\n\n      for (let t = 0, o = r.length - 1; t < r.length; o = t++) n = r[t], i = r[o], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s);\n    }\n\n    return s;\n  }\n\n  function Xs(t, e) {\n    let r = !1;\n\n    for (let n = 0, i = t.length - 1; n < t.length; i = n++) {\n      const s = t[n],\n            o = t[i];\n      s.y > e.y != o.y > e.y && e.x < (o.x - s.x) * (e.y - s.y) / (o.y - s.y) + s.x && (r = !r);\n    }\n\n    return r;\n  }\n\n  function Js(t, e, r) {\n    const n = r[0],\n          i = r[2];\n    if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1;\n    const s = v(t, e, r[0]);\n    return s !== v(t, e, r[1]) || s !== v(t, e, r[2]) || s !== v(t, e, r[3]);\n  }\n\n  function Ys(t, e, r) {\n    const n = e.paint.get(t).value;\n    return \"constant\" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t);\n  }\n\n  function Ks(t) {\n    return Math.sqrt(t[0] * t[0] + t[1] * t[1]);\n  }\n\n  function Hs(t, e, n, i, s) {\n    if (!e[0] && !e[1]) return t;\n\n    const o = r.convert(e)._mult(s);\n\n    \"viewport\" === n && o._rotate(-i);\n    const a = [];\n\n    for (let e = 0; e < t.length; e++) a.push(t[e].sub(o));\n\n    return a;\n  }\n\n  function Ws(t, e, n, i) {\n    const s = r.convert(t)._mult(i);\n\n    return \"viewport\" === e && s._rotate(-n), s;\n  }\n\n  Je(\"CircleBucket\", Ls, {\n    omit: [\"layers\"]\n  });\n  const Qs = new bi({\n    \"circle-sort-key\": new mi(sr.layout_circle[\"circle-sort-key\"])\n  });\n  var to,\n      eo = {\n    paint: new bi({\n      \"circle-radius\": new mi(sr.paint_circle[\"circle-radius\"]),\n      \"circle-color\": new mi(sr.paint_circle[\"circle-color\"]),\n      \"circle-blur\": new mi(sr.paint_circle[\"circle-blur\"]),\n      \"circle-opacity\": new mi(sr.paint_circle[\"circle-opacity\"]),\n      \"circle-translate\": new yi(sr.paint_circle[\"circle-translate\"]),\n      \"circle-translate-anchor\": new yi(sr.paint_circle[\"circle-translate-anchor\"]),\n      \"circle-pitch-scale\": new yi(sr.paint_circle[\"circle-pitch-scale\"]),\n      \"circle-pitch-alignment\": new yi(sr.paint_circle[\"circle-pitch-alignment\"]),\n      \"circle-stroke-width\": new mi(sr.paint_circle[\"circle-stroke-width\"]),\n      \"circle-stroke-color\": new mi(sr.paint_circle[\"circle-stroke-color\"]),\n      \"circle-stroke-opacity\": new mi(sr.paint_circle[\"circle-stroke-opacity\"])\n    }),\n    layout: Qs\n  },\n      ro = \"undefined\" != typeof Float32Array ? Float32Array : Array;\n\n  function no(t) {\n    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }\n\n  function io() {\n    var t = new ro(3);\n    return ro != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;\n  }\n\n  function so(t, e, r) {\n    var n = new ro(3);\n    return n[0] = t, n[1] = e, n[2] = r, n;\n  }\n\n  function oo(t, e, r, n) {\n    return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t;\n  }\n\n  function ao(t, e, r) {\n    var n = e[0],\n        i = e[1],\n        s = e[2],\n        o = r[3] * n + r[7] * i + r[11] * s + r[15];\n    return t[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (o = o || 1), t[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / o, t[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / o, t;\n  }\n\n  function lo(t, e, r) {\n    var n = e[0],\n        i = e[1],\n        s = e[2],\n        o = e[3];\n    return t[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * o, t[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * o, t[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * o, t[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * o, t;\n  }\n\n  function uo() {\n    var t = new ro(4);\n    return ro != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;\n  }\n\n  function co(t, e, n) {\n    const i = lo([], [t.x, t.y, e, 1], n);\n    return new r(i[0] / i[3], i[1] / i[3]);\n  }\n\n  Math.hypot || (Math.hypot = function () {\n    for (var t = 0, e = arguments.length; e--;) t += arguments[e] * arguments[e];\n\n    return Math.sqrt(t);\n  }), io(), function () {\n    var t;\n    t = new ro(4), ro != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0);\n  }(), io(), so(1, 0, 0), so(0, 1, 0), uo(), uo(), to = new ro(9), ro != Float32Array && (to[1] = 0, to[2] = 0, to[3] = 0, to[5] = 0, to[6] = 0, to[7] = 0), to[0] = 1, to[4] = 1, to[8] = 1;\n  const ho = so(0, 0, 0),\n        po = so(0, 0, 1);\n\n  function fo(t, e) {\n    const n = io();\n    return ho[2] = e, t.intersectsPlane(ho, po, n), new r(n[0], n[1]);\n  }\n\n  class yo extends Ls {}\n\n  function mo(t, {\n    width: e,\n    height: r\n  }, n, i) {\n    if (i) {\n      if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);else if (i.length !== e * r * n) throw new RangeError(\"mismatched image size\");\n    } else i = new Uint8Array(e * r * n);\n\n    return t.width = e, t.height = r, t.data = i, t;\n  }\n\n  function go(t, {\n    width: e,\n    height: r\n  }, n) {\n    if (e === t.width && r === t.height) return;\n    const i = mo({}, {\n      width: e,\n      height: r\n    }, n);\n    xo(t, i, {\n      x: 0,\n      y: 0\n    }, {\n      x: 0,\n      y: 0\n    }, {\n      width: Math.min(t.width, e),\n      height: Math.min(t.height, r)\n    }, n), t.width = e, t.height = r, t.data = i.data;\n  }\n\n  function xo(t, e, r, n, i, s) {\n    if (0 === i.width || 0 === i.height) return e;\n    if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError(\"out of range source coordinates for image copy\");\n    if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError(\"out of range destination coordinates for image copy\");\n    const o = t.data,\n          a = e.data;\n\n    for (let l = 0; l < i.height; l++) {\n      const u = ((r.y + l) * t.width + r.x) * s,\n            c = ((n.y + l) * e.width + n.x) * s;\n\n      for (let t = 0; t < i.width * s; t++) a[c + t] = o[u + t];\n    }\n\n    return e;\n  }\n\n  Je(\"HeatmapBucket\", yo, {\n    omit: [\"layers\"]\n  });\n\n  class vo {\n    constructor(t, e) {\n      mo(this, t, 1, e);\n    }\n\n    resize(t) {\n      go(this, t, 1);\n    }\n\n    clone() {\n      return new vo({\n        width: this.width,\n        height: this.height\n      }, new Uint8Array(this.data));\n    }\n\n    static copy(t, e, r, n, i) {\n      xo(t, e, r, n, i, 1);\n    }\n\n  }\n\n  class bo {\n    constructor(t, e) {\n      mo(this, t, 4, e);\n    }\n\n    resize(t) {\n      go(this, t, 4);\n    }\n\n    replace(t, e) {\n      e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;\n    }\n\n    clone() {\n      return new bo({\n        width: this.width,\n        height: this.height\n      }, new Uint8Array(this.data));\n    }\n\n    static copy(t, e, r, n, i) {\n      xo(t, e, r, n, i, 4);\n    }\n\n  }\n\n  Je(\"AlphaImage\", vo), Je(\"RGBAImage\", bo);\n  var wo = {\n    paint: new bi({\n      \"heatmap-radius\": new mi(sr.paint_heatmap[\"heatmap-radius\"]),\n      \"heatmap-weight\": new mi(sr.paint_heatmap[\"heatmap-weight\"]),\n      \"heatmap-intensity\": new yi(sr.paint_heatmap[\"heatmap-intensity\"]),\n      \"heatmap-color\": new vi(sr.paint_heatmap[\"heatmap-color\"]),\n      \"heatmap-opacity\": new yi(sr.paint_heatmap[\"heatmap-opacity\"])\n    })\n  };\n\n  function _o(t) {\n    const e = {},\n          r = t.resolution || 256,\n          n = t.clips ? t.clips.length : 1,\n          i = t.image || new bo({\n      width: r,\n      height: n\n    }),\n          s = (r, n, s) => {\n      e[t.evaluationKey] = s;\n      const o = t.expression.evaluate(e);\n      i.data[r + n + 0] = Math.floor(255 * o.r / o.a), i.data[r + n + 1] = Math.floor(255 * o.g / o.a), i.data[r + n + 2] = Math.floor(255 * o.b / o.a), i.data[r + n + 3] = Math.floor(255 * o.a);\n    };\n\n    if (t.clips) for (let e = 0, i = 0; e < n; ++e, i += 4 * r) for (let n = 0, o = 0; n < r; n++, o += 4) {\n      const a = n / (r - 1),\n            {\n        start: l,\n        end: u\n      } = t.clips[e];\n      s(i, o, l * (1 - a) + u * a);\n    } else for (let t = 0, e = 0; t < r; t++, e += 4) s(0, e, t / (r - 1));\n    return i;\n  }\n\n  var ko = {\n    paint: new bi({\n      \"hillshade-illumination-direction\": new yi(sr.paint_hillshade[\"hillshade-illumination-direction\"]),\n      \"hillshade-illumination-anchor\": new yi(sr.paint_hillshade[\"hillshade-illumination-anchor\"]),\n      \"hillshade-exaggeration\": new yi(sr.paint_hillshade[\"hillshade-exaggeration\"]),\n      \"hillshade-shadow-color\": new yi(sr.paint_hillshade[\"hillshade-shadow-color\"]),\n      \"hillshade-highlight-color\": new yi(sr.paint_hillshade[\"hillshade-highlight-color\"]),\n      \"hillshade-accent-color\": new yi(sr.paint_hillshade[\"hillshade-accent-color\"])\n    })\n  };\n  const So = Ai([{\n    name: \"a_pos\",\n    components: 2,\n    type: \"Int16\"\n  }], 4),\n        {\n    members: Ao\n  } = So;\n  var Io = Mo,\n      zo = Mo;\n\n  function Mo(t, e, r) {\n    r = r || 2;\n    var n,\n        i,\n        s,\n        o,\n        a,\n        l,\n        u,\n        c = e && e.length,\n        h = c ? e[0] * r : t.length,\n        p = Bo(t, 0, h, r, !0),\n        f = [];\n    if (!p || p.next === p.prev) return f;\n\n    if (c && (p = function (t, e, r, n) {\n      var i,\n          s,\n          o,\n          a = [];\n\n      for (i = 0, s = e.length; i < s; i++) (o = Bo(t, e[i] * n, i < s - 1 ? e[i + 1] * n : t.length, n, !1)) === o.next && (o.steiner = !0), a.push(Ro(o));\n\n      for (a.sort(Fo), i = 0; i < a.length; i++) Lo(a[i], r), r = Po(r, r.next);\n\n      return r;\n    }(t, e, p, r)), t.length > 80 * r) {\n      n = s = t[0], i = o = t[1];\n\n      for (var d = r; d < h; d += r) (a = t[d]) < n && (n = a), (l = t[d + 1]) < i && (i = l), a > s && (s = a), l > o && (o = l);\n\n      u = 0 !== (u = Math.max(s - n, o - i)) ? 1 / u : 0;\n    }\n\n    return Co(p, f, r, n, i, u), f;\n  }\n\n  function Bo(t, e, r, n, i) {\n    var s, o;\n    if (i === Qo(t, e, r, n) > 0) for (s = e; s < r; s += n) o = Ko(s, t[s], t[s + 1], o);else for (s = r - n; s >= e; s -= n) o = Ko(s, t[s], t[s + 1], o);\n    return o && jo(o, o.next) && (Ho(o), o = o.next), o;\n  }\n\n  function Po(t, e) {\n    if (!t) return t;\n    e || (e = t);\n    var r,\n        n = t;\n\n    do {\n      if (r = !1, n.steiner || !jo(n, n.next) && 0 !== No(n.prev, n, n.next)) n = n.next;else {\n        if (Ho(n), (n = e = n.prev) === n.next) break;\n        r = !0;\n      }\n    } while (r || n !== e);\n\n    return e;\n  }\n\n  function Co(t, e, r, n, i, s, o) {\n    if (t) {\n      !o && s && function (t, e, r, n) {\n        var i = t;\n\n        do {\n          null === i.z && (i.z = $o(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;\n        } while (i !== t);\n\n        i.prevZ.nextZ = null, i.prevZ = null, function (t) {\n          var e,\n              r,\n              n,\n              i,\n              s,\n              o,\n              a,\n              l,\n              u = 1;\n\n          do {\n            for (r = t, t = null, s = null, o = 0; r;) {\n              for (o++, n = r, a = 0, e = 0; e < u && (a++, n = n.nextZ); e++);\n\n              for (l = u; a > 0 || l > 0 && n;) 0 !== a && (0 === l || !n || r.z <= n.z) ? (i = r, r = r.nextZ, a--) : (i = n, n = n.nextZ, l--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i;\n\n              r = n;\n            }\n\n            s.nextZ = null, u *= 2;\n          } while (o > 1);\n        }(i);\n      }(t, n, i, s);\n\n      for (var a, l, u = t; t.prev !== t.next;) if (a = t.prev, l = t.next, s ? To(t, n, i, s) : Vo(t)) e.push(a.i / r), e.push(t.i / r), e.push(l.i / r), Ho(t), t = l.next, u = l.next;else if ((t = l) === u) {\n        o ? 1 === o ? Co(t = Eo(Po(t), e, r), e, r, n, i, s, 2) : 2 === o && Do(t, e, r, n, i, s) : Co(Po(t), e, r, n, i, s, 1);\n        break;\n      }\n    }\n  }\n\n  function Vo(t) {\n    var e = t.prev,\n        r = t,\n        n = t.next;\n    if (No(e, r, n) >= 0) return !1;\n\n    for (var i = t.next.next; i !== t.prev;) {\n      if (qo(e.x, e.y, r.x, r.y, n.x, n.y, i.x, i.y) && No(i.prev, i, i.next) >= 0) return !1;\n      i = i.next;\n    }\n\n    return !0;\n  }\n\n  function To(t, e, r, n) {\n    var i = t.prev,\n        s = t,\n        o = t.next;\n    if (No(i, s, o) >= 0) return !1;\n\n    for (var a = i.x > s.x ? i.x > o.x ? i.x : o.x : s.x > o.x ? s.x : o.x, l = i.y > s.y ? i.y > o.y ? i.y : o.y : s.y > o.y ? s.y : o.y, u = $o(i.x < s.x ? i.x < o.x ? i.x : o.x : s.x < o.x ? s.x : o.x, i.y < s.y ? i.y < o.y ? i.y : o.y : s.y < o.y ? s.y : o.y, e, r, n), c = $o(a, l, e, r, n), h = t.prevZ, p = t.nextZ; h && h.z >= u && p && p.z <= c;) {\n      if (h !== t.prev && h !== t.next && qo(i.x, i.y, s.x, s.y, o.x, o.y, h.x, h.y) && No(h.prev, h, h.next) >= 0) return !1;\n      if (h = h.prevZ, p !== t.prev && p !== t.next && qo(i.x, i.y, s.x, s.y, o.x, o.y, p.x, p.y) && No(p.prev, p, p.next) >= 0) return !1;\n      p = p.nextZ;\n    }\n\n    for (; h && h.z >= u;) {\n      if (h !== t.prev && h !== t.next && qo(i.x, i.y, s.x, s.y, o.x, o.y, h.x, h.y) && No(h.prev, h, h.next) >= 0) return !1;\n      h = h.prevZ;\n    }\n\n    for (; p && p.z <= c;) {\n      if (p !== t.prev && p !== t.next && qo(i.x, i.y, s.x, s.y, o.x, o.y, p.x, p.y) && No(p.prev, p, p.next) >= 0) return !1;\n      p = p.nextZ;\n    }\n\n    return !0;\n  }\n\n  function Eo(t, e, r) {\n    var n = t;\n\n    do {\n      var i = n.prev,\n          s = n.next.next;\n      !jo(i, s) && Zo(i, n, n.next, s) && Jo(i, s) && Jo(s, i) && (e.push(i.i / r), e.push(n.i / r), e.push(s.i / r), Ho(n), Ho(n.next), n = t = s), n = n.next;\n    } while (n !== t);\n\n    return Po(n);\n  }\n\n  function Do(t, e, r, n, i, s) {\n    var o = t;\n\n    do {\n      for (var a = o.next.next; a !== o.prev;) {\n        if (o.i !== a.i && Uo(o, a)) {\n          var l = Yo(o, a);\n          return o = Po(o, o.next), l = Po(l, l.next), Co(o, e, r, n, i, s), void Co(l, e, r, n, i, s);\n        }\n\n        a = a.next;\n      }\n\n      o = o.next;\n    } while (o !== t);\n  }\n\n  function Fo(t, e) {\n    return t.x - e.x;\n  }\n\n  function Lo(t, e) {\n    if (e = function (t, e) {\n      var r,\n          n = e,\n          i = t.x,\n          s = t.y,\n          o = -1 / 0;\n\n      do {\n        if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {\n          var a = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);\n\n          if (a <= i && a > o) {\n            if (o = a, a === i) {\n              if (s === n.y) return n;\n              if (s === n.next.y) return n.next;\n            }\n\n            r = n.x < n.next.x ? n : n.next;\n          }\n        }\n\n        n = n.next;\n      } while (n !== e);\n\n      if (!r) return null;\n      if (i === o) return r;\n      var l,\n          u = r,\n          c = r.x,\n          h = r.y,\n          p = 1 / 0;\n      n = r;\n\n      do {\n        i >= n.x && n.x >= c && i !== n.x && qo(s < h ? i : o, s, c, h, s < h ? o : i, s, n.x, n.y) && (l = Math.abs(s - n.y) / (i - n.x), Jo(n, t) && (l < p || l === p && (n.x > r.x || n.x === r.x && Oo(r, n))) && (r = n, p = l)), n = n.next;\n      } while (n !== u);\n\n      return r;\n    }(t, e)) {\n      var r = Yo(e, t);\n      Po(e, e.next), Po(r, r.next);\n    }\n  }\n\n  function Oo(t, e) {\n    return No(t.prev, t, e.prev) < 0 && No(e.next, t, t.next) < 0;\n  }\n\n  function $o(t, e, r, n, i) {\n    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;\n  }\n\n  function Ro(t) {\n    var e = t,\n        r = t;\n\n    do {\n      (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;\n    } while (e !== t);\n\n    return r;\n  }\n\n  function qo(t, e, r, n, i, s, o, a) {\n    return (i - o) * (e - a) - (t - o) * (s - a) >= 0 && (t - o) * (n - a) - (r - o) * (e - a) >= 0 && (r - o) * (s - a) - (i - o) * (n - a) >= 0;\n  }\n\n  function Uo(t, e) {\n    return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {\n      var r = t;\n\n      do {\n        if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && Zo(r, r.next, t, e)) return !0;\n        r = r.next;\n      } while (r !== t);\n\n      return !1;\n    }(t, e) && (Jo(t, e) && Jo(e, t) && function (t, e) {\n      var r = t,\n          n = !1,\n          i = (t.x + e.x) / 2,\n          s = (t.y + e.y) / 2;\n\n      do {\n        r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;\n      } while (r !== t);\n\n      return n;\n    }(t, e) && (No(t.prev, t, e.prev) || No(t, e.prev, e)) || jo(t, e) && No(t.prev, t, t.next) > 0 && No(e.prev, e, e.next) > 0);\n  }\n\n  function No(t, e, r) {\n    return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);\n  }\n\n  function jo(t, e) {\n    return t.x === e.x && t.y === e.y;\n  }\n\n  function Zo(t, e, r, n) {\n    var i = Xo(No(t, e, r)),\n        s = Xo(No(t, e, n)),\n        o = Xo(No(r, n, t)),\n        a = Xo(No(r, n, e));\n    return i !== s && o !== a || !(0 !== i || !Go(t, r, e)) || !(0 !== s || !Go(t, n, e)) || !(0 !== o || !Go(r, t, n)) || !(0 !== a || !Go(r, e, n));\n  }\n\n  function Go(t, e, r) {\n    return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y);\n  }\n\n  function Xo(t) {\n    return t > 0 ? 1 : t < 0 ? -1 : 0;\n  }\n\n  function Jo(t, e) {\n    return No(t.prev, t, t.next) < 0 ? No(t, e, t.next) >= 0 && No(t, t.prev, e) >= 0 : No(t, e, t.prev) < 0 || No(t, t.next, e) < 0;\n  }\n\n  function Yo(t, e) {\n    var r = new Wo(t.i, t.x, t.y),\n        n = new Wo(e.i, e.x, e.y),\n        i = t.next,\n        s = e.prev;\n    return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;\n  }\n\n  function Ko(t, e, r, n) {\n    var i = new Wo(t, e, r);\n    return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;\n  }\n\n  function Ho(t) {\n    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);\n  }\n\n  function Wo(t, e, r) {\n    this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n  }\n\n  function Qo(t, e, r, n) {\n    for (var i = 0, s = e, o = r - n; s < r; s += n) i += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s;\n\n    return i;\n  }\n\n  function ta(t, e, r, n, i) {\n    !function t(e, r, n, i, s) {\n      for (; i > n;) {\n        if (i - n > 600) {\n          var o = i - n + 1,\n              a = r - n + 1,\n              l = Math.log(o),\n              u = .5 * Math.exp(2 * l / 3),\n              c = .5 * Math.sqrt(l * u * (o - u) / o) * (a - o / 2 < 0 ? -1 : 1);\n          t(e, r, Math.max(n, Math.floor(r - a * u / o + c)), Math.min(i, Math.floor(r + (o - a) * u / o + c)), s);\n        }\n\n        var h = e[r],\n            p = n,\n            f = i;\n\n        for (ea(e, n, r), s(e[i], h) > 0 && ea(e, n, i); p < f;) {\n          for (ea(e, p, f), p++, f--; s(e[p], h) < 0;) p++;\n\n          for (; s(e[f], h) > 0;) f--;\n        }\n\n        0 === s(e[n], h) ? ea(e, n, f) : ea(e, ++f, i), f <= r && (n = f + 1), r <= f && (i = f - 1);\n      }\n    }(t, e, r || 0, n || t.length - 1, i || ra);\n  }\n\n  function ea(t, e, r) {\n    var n = t[e];\n    t[e] = t[r], t[r] = n;\n  }\n\n  function ra(t, e) {\n    return t < e ? -1 : t > e ? 1 : 0;\n  }\n\n  function na(t, e) {\n    const r = t.length;\n    if (r <= 1) return [t];\n    const n = [];\n    let i, s;\n\n    for (let e = 0; e < r; e++) {\n      const r = b(t[e]);\n      0 !== r && (t[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [t[e]]) : i.push(t[e]));\n    }\n\n    if (i && n.push(i), e > 1) for (let t = 0; t < n.length; t++) n[t].length <= e || (ta(n[t], e, 1, n[t].length - 1, ia), n[t] = n[t].slice(0, e));\n    return n;\n  }\n\n  function ia(t, e) {\n    return e.area - t.area;\n  }\n\n  function sa(t, e, r) {\n    const n = r.patternDependencies;\n    let i = !1;\n\n    for (const r of e) {\n      const e = r.paint.get(`${t}-pattern`);\n      e.isConstant() || (i = !0);\n      const s = e.constantOr(null);\n      s && (i = !0, n[s.to] = !0, n[s.from] = !0);\n    }\n\n    return i;\n  }\n\n  function oa(t, e, r, n, i) {\n    const s = i.patternDependencies;\n\n    for (const o of e) {\n      const e = o.paint.get(`${t}-pattern`).value;\n\n      if (\"constant\" !== e.kind) {\n        let t = e.evaluate({\n          zoom: n - 1\n        }, r, {}, i.availableImages),\n            a = e.evaluate({\n          zoom: n\n        }, r, {}, i.availableImages),\n            l = e.evaluate({\n          zoom: n + 1\n        }, r, {}, i.availableImages);\n        t = t && t.name ? t.name : t, a = a && a.name ? a.name : a, l = l && l.name ? l.name : l, s[t] = !0, s[a] = !0, s[l] = !0, r.patterns[o.id] = {\n          min: t,\n          mid: a,\n          max: l\n        };\n      }\n    }\n\n    return r;\n  }\n\n  Mo.deviation = function (t, e, r, n) {\n    var i = e && e.length,\n        s = Math.abs(Qo(t, 0, i ? e[0] * r : t.length, r));\n    if (i) for (var o = 0, a = e.length; o < a; o++) s -= Math.abs(Qo(t, e[o] * r, o < a - 1 ? e[o + 1] * r : t.length, r));\n    var l = 0;\n\n    for (o = 0; o < n.length; o += 3) {\n      var u = n[o] * r,\n          c = n[o + 1] * r,\n          h = n[o + 2] * r;\n      l += Math.abs((t[u] - t[h]) * (t[c + 1] - t[u + 1]) - (t[u] - t[c]) * (t[h + 1] - t[u + 1]));\n    }\n\n    return 0 === s && 0 === l ? 0 : Math.abs((l - s) / s);\n  }, Mo.flatten = function (t) {\n    for (var e = t[0][0].length, r = {\n      vertices: [],\n      holes: [],\n      dimensions: e\n    }, n = 0, i = 0; i < t.length; i++) {\n      for (var s = 0; s < t[i].length; s++) for (var o = 0; o < e; o++) r.vertices.push(t[i][s][o]);\n\n      i > 0 && r.holes.push(n += t[i - 1].length);\n    }\n\n    return r;\n  }, Io.default = zo;\n\n  class aa {\n    constructor(t) {\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new zi(), this.indexArray = new $i(), this.indexArray2 = new Zi(), this.programConfigurations = new As(t.layers, t.zoom), this.segments = new Cs(), this.segments2 = new Cs(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n    }\n\n    populate(t, e, r) {\n      this.hasPattern = sa(\"fill\", this.layers, e);\n      const n = this.layers[0].layout.get(\"fill-sort-key\"),\n            i = [];\n\n      for (const {\n        feature: s,\n        id: o,\n        index: a,\n        sourceLayerIndex: l\n      } of t) {\n        const t = this.layers[0]._featureFilter.needGeometry,\n              u = Ds(s, t);\n        if (!this.layers[0]._featureFilter.filter(new oi(this.zoom), u, r)) continue;\n        const c = n ? n.evaluate(u, {}, r, e.availableImages) : void 0,\n              h = {\n          id: o,\n          properties: s.properties,\n          type: s.type,\n          sourceLayerIndex: l,\n          index: a,\n          geometry: t ? u.geometry : Es(s),\n          patterns: {},\n          sortKey: c\n        };\n        i.push(h);\n      }\n\n      n && i.sort((t, e) => t.sortKey - e.sortKey);\n\n      for (const n of i) {\n        const {\n          geometry: i,\n          index: s,\n          sourceLayerIndex: o\n        } = n;\n\n        if (this.hasPattern) {\n          const t = oa(\"fill\", this.layers, n, this.zoom, e);\n          this.patternFeatures.push(t);\n        } else this.addFeature(n, i, s, r, {});\n\n        e.featureIndex.insert(t[s].feature, i, s, o, this.index);\n      }\n    }\n\n    update(t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }\n\n    addFeatures(t, e, r) {\n      for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r);\n    }\n\n    isEmpty() {\n      return 0 === this.layoutVertexArray.length;\n    }\n\n    uploadPending() {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }\n\n    upload(t) {\n      this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ao), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }\n\n    destroy() {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());\n    }\n\n    addFeature(t, e, r, n, i) {\n      for (const t of na(e, 500)) {\n        let e = 0;\n\n        for (const r of t) e += r.length;\n\n        const r = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray),\n              n = r.vertexLength,\n              i = [],\n              s = [];\n\n        for (const e of t) {\n          if (0 === e.length) continue;\n          e !== t[0] && s.push(i.length / 2);\n          const r = this.segments2.prepareSegment(e.length, this.layoutVertexArray, this.indexArray2),\n                n = r.vertexLength;\n          this.layoutVertexArray.emplaceBack(e[0].x, e[0].y), this.indexArray2.emplaceBack(n + e.length - 1, n), i.push(e[0].x), i.push(e[0].y);\n\n          for (let t = 1; t < e.length; t++) this.layoutVertexArray.emplaceBack(e[t].x, e[t].y), this.indexArray2.emplaceBack(n + t - 1, n + t), i.push(e[t].x), i.push(e[t].y);\n\n          r.vertexLength += e.length, r.primitiveLength += e.length;\n        }\n\n        const o = Io(i, s);\n\n        for (let t = 0; t < o.length; t += 3) this.indexArray.emplaceBack(n + o[t], n + o[t + 1], n + o[t + 2]);\n\n        r.vertexLength += e, r.primitiveLength += o.length / 3;\n      }\n\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n    }\n\n  }\n\n  Je(\"FillBucket\", aa, {\n    omit: [\"layers\", \"patternFeatures\"]\n  });\n  const la = new bi({\n    \"fill-sort-key\": new mi(sr.layout_fill[\"fill-sort-key\"])\n  });\n  var ua = {\n    paint: new bi({\n      \"fill-antialias\": new yi(sr.paint_fill[\"fill-antialias\"]),\n      \"fill-opacity\": new mi(sr.paint_fill[\"fill-opacity\"]),\n      \"fill-color\": new mi(sr.paint_fill[\"fill-color\"]),\n      \"fill-outline-color\": new mi(sr.paint_fill[\"fill-outline-color\"]),\n      \"fill-translate\": new yi(sr.paint_fill[\"fill-translate\"]),\n      \"fill-translate-anchor\": new yi(sr.paint_fill[\"fill-translate-anchor\"]),\n      \"fill-pattern\": new gi(sr.paint_fill[\"fill-pattern\"])\n    }),\n    layout: la\n  };\n  const ca = Ai([{\n    name: \"a_pos_normal_ed\",\n    components: 4,\n    type: \"Int16\"\n  }]),\n        ha = Ai([{\n    name: \"a_centroid_pos\",\n    components: 2,\n    type: \"Uint16\"\n  }]),\n        {\n    members: pa\n  } = ca;\n  var fa = da;\n\n  function da(t, e, r, n, i) {\n    this.properties = {}, this.extent = r, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = n, this._values = i, t.readFields(ya, this, e);\n  }\n\n  function ya(t, e, r) {\n    1 == t ? e.id = r.readVarint() : 2 == t ? function (t, e) {\n      for (var r = t.readVarint() + t.pos; t.pos < r;) {\n        var n = e._keys[t.readVarint()],\n            i = e._values[t.readVarint()];\n\n        e.properties[n] = i;\n      }\n    }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);\n  }\n\n  function ma(t) {\n    for (var e, r, n = 0, i = 0, s = t.length, o = s - 1; i < s; o = i++) n += ((r = t[o]).x - (e = t[i]).x) * (e.y + r.y);\n\n    return n;\n  }\n\n  da.types = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"], da.prototype.loadGeometry = function () {\n    var t = this._pbf;\n    t.pos = this._geometry;\n\n    for (var e, n = t.readVarint() + t.pos, i = 1, s = 0, o = 0, a = 0, l = []; t.pos < n;) {\n      if (s <= 0) {\n        var u = t.readVarint();\n        i = 7 & u, s = u >> 3;\n      }\n\n      if (s--, 1 === i || 2 === i) o += t.readSVarint(), a += t.readSVarint(), 1 === i && (e && l.push(e), e = []), e.push(new r(o, a));else {\n        if (7 !== i) throw new Error(\"unknown command \" + i);\n        e && e.push(e[0].clone());\n      }\n    }\n\n    return e && l.push(e), l;\n  }, da.prototype.bbox = function () {\n    var t = this._pbf;\n    t.pos = this._geometry;\n\n    for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, s = 0, o = 1 / 0, a = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e;) {\n      if (n <= 0) {\n        var c = t.readVarint();\n        r = 7 & c, n = c >> 3;\n      }\n\n      if (n--, 1 === r || 2 === r) (i += t.readSVarint()) < o && (o = i), i > a && (a = i), (s += t.readSVarint()) < l && (l = s), s > u && (u = s);else if (7 !== r) throw new Error(\"unknown command \" + r);\n    }\n\n    return [o, l, a, u];\n  }, da.prototype.toGeoJSON = function (t, e, r) {\n    var n,\n        i,\n        s = this.extent * Math.pow(2, r),\n        o = this.extent * t,\n        a = this.extent * e,\n        l = this.loadGeometry(),\n        u = da.types[this.type];\n\n    function c(t) {\n      for (var e = 0; e < t.length; e++) {\n        var r = t[e];\n        t[e] = [360 * (r.x + o) / s - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + a) / s) * Math.PI / 180)) - 90];\n      }\n    }\n\n    switch (this.type) {\n      case 1:\n        var h = [];\n\n        for (n = 0; n < l.length; n++) h[n] = l[n][0];\n\n        c(l = h);\n        break;\n\n      case 2:\n        for (n = 0; n < l.length; n++) c(l[n]);\n\n        break;\n\n      case 3:\n        for (l = function (t) {\n          var e = t.length;\n          if (e <= 1) return [t];\n\n          for (var r, n, i = [], s = 0; s < e; s++) {\n            var o = ma(t[s]);\n            0 !== o && (void 0 === n && (n = o < 0), n === o < 0 ? (r && i.push(r), r = [t[s]]) : r.push(t[s]));\n          }\n\n          return r && i.push(r), i;\n        }(l), n = 0; n < l.length; n++) for (i = 0; i < l[n].length; i++) c(l[n][i]);\n\n    }\n\n    1 === l.length ? l = l[0] : u = \"Multi\" + u;\n    var p = {\n      type: \"Feature\",\n      geometry: {\n        type: u,\n        coordinates: l\n      },\n      properties: this.properties\n    };\n    return \"id\" in this && (p.id = this.id), p;\n  };\n  var ga = xa;\n\n  function xa(t, e) {\n    this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(va, this, e), this.length = this._features.length;\n  }\n\n  function va(t, e, r) {\n    15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) {\n      for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) {\n        var n = t.readVarint() >> 3;\n        e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;\n      }\n\n      return e;\n    }(r));\n  }\n\n  function ba(t, e, r) {\n    if (3 === t) {\n      var n = new ga(r, r.readVarint() + r.pos);\n      n.length && (e[n.name] = n);\n    }\n  }\n\n  xa.prototype.feature = function (t) {\n    if (t < 0 || t >= this._features.length) throw new Error(\"feature index out of bounds\");\n    this._pbf.pos = this._features[t];\n\n    var e = this._pbf.readVarint() + this._pbf.pos;\n\n    return new fa(this._pbf, e, this.extent, this._keys, this._values);\n  };\n\n  var wa = {\n    VectorTile: function (t, e) {\n      this.layers = t.readFields(ba, {}, e);\n    },\n    VectorTileFeature: fa,\n    VectorTileLayer: ga\n  };\n  const _a = wa.VectorTileFeature.types,\n        ka = Math.pow(2, 13);\n\n  function Sa(t, e, r, n, i, s, o, a) {\n    t.emplaceBack((e << 1) + o, (r << 1) + s, (Math.floor(n * ka) << 1) + i, Math.round(a));\n  }\n\n  class Aa {\n    constructor() {\n      this.acc = new r(0, 0), this.polyCount = [];\n    }\n\n    startRing(t) {\n      this.currentPolyCount = {\n        edges: 0,\n        top: 0\n      }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new r(t.x, t.y), this.max = new r(t.x, t.y));\n    }\n\n    append(t, e) {\n      this.currentPolyCount.edges++, this.acc._add(t);\n      let r = !!this.borders;\n      const n = this.min,\n            i = this.max;\n      t.x < n.x ? (n.x = t.x, r = !0) : t.x > i.x && (i.x = t.x, r = !0), t.y < n.y ? (n.y = t.y, r = !0) : t.y > i.y && (i.y = t.y, r = !0), ((0 === t.x || 8192 === t.x) && t.x === e.x) != ((0 === t.y || 8192 === t.y) && t.y === e.y) && this.processBorderOverlap(t, e), r && this.checkBorderIntersection(t, e);\n    }\n\n    checkBorderIntersection(t, e) {\n      e.x < 0 != t.x < 0 && this.addBorderIntersection(0, $t(e.y, t.y, (0 - e.x) / (t.x - e.x))), e.x > 8192 != t.x > 8192 && this.addBorderIntersection(1, $t(e.y, t.y, (8192 - e.x) / (t.x - e.x))), e.y < 0 != t.y < 0 && this.addBorderIntersection(2, $t(e.x, t.x, (0 - e.y) / (t.y - e.y))), e.y > 8192 != t.y > 8192 && this.addBorderIntersection(3, $t(e.x, t.x, (8192 - e.y) / (t.y - e.y)));\n    }\n\n    addBorderIntersection(t, e) {\n      this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);\n      const r = this.borders[t];\n      e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);\n    }\n\n    processBorderOverlap(t, e) {\n      if (t.x === e.x) {\n        if (t.y === e.y) return;\n        const r = 0 === t.x ? 0 : 1;\n        this.addBorderIntersection(r, e.y), this.addBorderIntersection(r, t.y);\n      } else {\n        const r = 0 === t.y ? 2 : 3;\n        this.addBorderIntersection(r, e.x), this.addBorderIntersection(r, t.x);\n      }\n    }\n\n    centroid() {\n      const t = this.polyCount.reduce((t, e) => t + e.edges, 0);\n      return 0 !== t ? this.acc.div(t)._round() : new r(0, 0);\n    }\n\n    span() {\n      return new r(this.max.x - this.min.x, this.max.y - this.min.y);\n    }\n\n    intersectsCount() {\n      return this.borders.reduce((t, e) => t + +(e[0] !== Number.MAX_VALUE), 0);\n    }\n\n  }\n\n  class Ia {\n    constructor(t) {\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Mi(), this.centroidVertexArray = new ss(), this.indexArray = new $i(), this.programConfigurations = new As(t.layers, t.zoom), this.segments = new Cs(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.enableTerrain = t.enableTerrain;\n    }\n\n    populate(t, e, r) {\n      this.features = [], this.hasPattern = sa(\"fill-extrusion\", this.layers, e), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDone = [!1, !1, !1, !1], this.tileToMeter = function (t) {\n        const e = Math.exp(Math.PI * (1 - t.y / (1 << t.z) * 2));\n        return 80150034 * e / (e * e + 1) / 8192 / (1 << t.z);\n      }(r);\n\n      for (const {\n        feature: n,\n        id: i,\n        index: s,\n        sourceLayerIndex: o\n      } of t) {\n        const t = this.layers[0]._featureFilter.needGeometry,\n              a = Ds(n, t);\n        if (!this.layers[0]._featureFilter.filter(new oi(this.zoom), a, r)) continue;\n        const l = {\n          id: i,\n          sourceLayerIndex: o,\n          index: s,\n          geometry: t ? a.geometry : Es(n),\n          properties: n.properties,\n          type: n.type,\n          patterns: {}\n        },\n              u = this.layoutVertexArray.length;\n        this.hasPattern ? this.features.push(oa(\"fill-extrusion\", this.layers, l, this.zoom, e)) : this.addFeature(l, l.geometry, s, r, {}), e.featureIndex.insert(n, l.geometry, s, o, this.index, u);\n      }\n\n      this.sortBorders();\n    }\n\n    addFeatures(t, e, r) {\n      for (const t of this.features) {\n        const {\n          geometry: n\n        } = t;\n        this.addFeature(t, n, t.index, e, r);\n      }\n\n      this.sortBorders();\n    }\n\n    update(t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }\n\n    isEmpty() {\n      return 0 === this.layoutVertexArray.length;\n    }\n\n    uploadPending() {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }\n\n    upload(t) {\n      this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, pa), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }\n\n    uploadCentroid(t) {\n      0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, ha.members, !0), this.needsCentroidUpdate = !1);\n    }\n\n    destroy() {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n    }\n\n    addFeature(t, e, r, n, i) {\n      const s = this.enableTerrain && t.properties && t.properties.hasOwnProperty(\"type\") && t.properties.hasOwnProperty(\"height\") && \"Polygon\" === _a[t.type] ? new Aa() : null;\n\n      for (const r of na(e, 500)) {\n        let e = 0,\n            n = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);\n        if (0 === r.length || (o = r[0]).every(t => t.x <= 0) || o.every(t => t.x >= 8192) || o.every(t => t.y <= 0) || o.every(t => t.y >= 8192)) continue;\n\n        for (let t = 0; t < r.length; t++) {\n          const i = r[t];\n          if (0 === i.length) continue;\n          e += i.length;\n          let o = 0;\n          s && s.startRing(i[0]);\n\n          for (let t = 0; t < i.length; t++) {\n            const e = i[t];\n\n            if (t >= 1) {\n              const r = i[t - 1];\n\n              if (!za(e, r)) {\n                s && s.append(e, r), n.vertexLength + 4 > Cs.MAX_VERTEX_ARRAY_LENGTH && (n = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));\n\n                const t = e.sub(r)._perp(),\n                      i = t.x / (Math.abs(t.x) + Math.abs(t.y)),\n                      a = t.y > 0 ? 1 : 0,\n                      l = r.dist(e);\n\n                o + l > 32768 && (o = 0), Sa(this.layoutVertexArray, e.x, e.y, i, a, 0, 0, o), Sa(this.layoutVertexArray, e.x, e.y, i, a, 0, 1, o), o += l, Sa(this.layoutVertexArray, r.x, r.y, i, a, 0, 0, o), Sa(this.layoutVertexArray, r.x, r.y, i, a, 0, 1, o);\n                const u = n.vertexLength;\n                this.indexArray.emplaceBack(u, u + 2, u + 1), this.indexArray.emplaceBack(u + 1, u + 2, u + 3), n.vertexLength += 4, n.primitiveLength += 2;\n              }\n            }\n          }\n        }\n\n        if (n.vertexLength + e > Cs.MAX_VERTEX_ARRAY_LENGTH && (n = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray)), \"Polygon\" !== _a[t.type]) continue;\n        const i = [],\n              a = [],\n              l = n.vertexLength;\n\n        for (let t = 0; t < r.length; t++) {\n          const e = r[t];\n\n          if (0 !== e.length) {\n            e !== r[0] && a.push(i.length / 2);\n\n            for (let t = 0; t < e.length; t++) {\n              const r = e[t];\n              Sa(this.layoutVertexArray, r.x, r.y, 0, 0, 1, 1, 0), i.push(r.x), i.push(r.y), s && s.currentPolyCount.top++;\n            }\n          }\n        }\n\n        const u = Io(i, a);\n\n        for (let t = 0; t < u.length; t += 3) this.indexArray.emplaceBack(l + u[t], l + u[t + 2], l + u[t + 1]);\n\n        n.primitiveLength += u.length / 3, n.vertexLength += e;\n      }\n\n      var o;\n\n      if (s && s.polyCount.length > 0) {\n        if (s.borders) {\n          s.vertexArrayOffset = this.centroidVertexArray.length;\n          const t = s.borders,\n                e = this.featuresOnBorder.push(s) - 1;\n\n          for (let r = 0; r < 4; r++) t[r][0] !== Number.MAX_VALUE && this.borders[r].push(e);\n        }\n\n        this.encodeCentroid(s.borders ? void 0 : s.centroid(), s);\n      }\n\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n    }\n\n    sortBorders() {\n      for (let t = 0; t < 4; t++) this.borders[t].sort((e, r) => this.featuresOnBorder[e].borders[t][0] - this.featuresOnBorder[r].borders[t][0]);\n    }\n\n    encodeCentroid(t, e, r = !0) {\n      let n, i;\n      if (t) {\n        if (0 !== t.y) {\n          const r = e.span()._mult(this.tileToMeter);\n\n          n = (Math.max(t.x, 1) << 3) + Math.min(7, Math.round(r.x / 10)), i = (Math.max(t.y, 1) << 3) + Math.min(7, Math.round(r.y / 10));\n        } else n = Math.ceil(7.3 * t.x), i = 0;\n      } else n = 0, i = +r;\n      let s = r ? this.centroidVertexArray.length : e.vertexArrayOffset;\n\n      for (const t of e.polyCount) {\n        r && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t.edges + t.top);\n\n        for (let e = 0; e < 2 * t.edges; e++) this.centroidVertexArray.emplace(s++, 0, i), this.centroidVertexArray.emplace(s++, n, i);\n\n        for (let e = 0; e < t.top; e++) this.centroidVertexArray.emplace(s++, n, i);\n      }\n    }\n\n  }\n\n  function za(t, e) {\n    return t.x === e.x && (t.x < 0 || t.x > 8192) || t.y === e.y && (t.y < 0 || t.y > 8192);\n  }\n\n  Je(\"FillExtrusionBucket\", Ia, {\n    omit: [\"layers\", \"features\"]\n  }), Je(\"PartMetadata\", Aa);\n  var Ma = {\n    paint: new bi({\n      \"fill-extrusion-opacity\": new yi(sr[\"paint_fill-extrusion\"][\"fill-extrusion-opacity\"]),\n      \"fill-extrusion-color\": new mi(sr[\"paint_fill-extrusion\"][\"fill-extrusion-color\"]),\n      \"fill-extrusion-translate\": new yi(sr[\"paint_fill-extrusion\"][\"fill-extrusion-translate\"]),\n      \"fill-extrusion-translate-anchor\": new yi(sr[\"paint_fill-extrusion\"][\"fill-extrusion-translate-anchor\"]),\n      \"fill-extrusion-pattern\": new gi(sr[\"paint_fill-extrusion\"][\"fill-extrusion-pattern\"]),\n      \"fill-extrusion-height\": new mi(sr[\"paint_fill-extrusion\"][\"fill-extrusion-height\"]),\n      \"fill-extrusion-base\": new mi(sr[\"paint_fill-extrusion\"][\"fill-extrusion-base\"]),\n      \"fill-extrusion-vertical-gradient\": new yi(sr[\"paint_fill-extrusion\"][\"fill-extrusion-vertical-gradient\"])\n    })\n  };\n\n  function Ba(t, e) {\n    return t.x * e.x + t.y * e.y;\n  }\n\n  function Pa(t, e) {\n    if (1 === t.length) {\n      let r = 0;\n      const n = e[r++];\n      let i;\n\n      for (; !i || n.equals(i);) if (i = e[r++], !i) return 1 / 0;\n\n      for (; r < e.length; r++) {\n        const s = e[r],\n              o = t[0],\n              a = i.sub(n),\n              l = s.sub(n),\n              u = o.sub(n),\n              c = Ba(a, a),\n              h = Ba(a, l),\n              p = Ba(l, l),\n              f = Ba(u, a),\n              d = Ba(u, l),\n              y = c * p - h * h,\n              m = (p * f - h * d) / y,\n              g = (c * d - h * f) / y,\n              x = n.z * (1 - m - g) + i.z * m + s.z * g;\n        if (isFinite(x)) return x;\n      }\n\n      return 1 / 0;\n    }\n\n    {\n      let t = 1 / 0;\n\n      for (const r of e) t = Math.min(t, r.z);\n\n      return t;\n    }\n  }\n\n  function Ca(t) {\n    const e = new r(t[0], t[1]);\n    return e.z = t[2], e;\n  }\n\n  function Va(t, e, r, n, i, s, o, a) {\n    const l = o * i.getElevationAt(t, e, !0, !0),\n          u = 0 !== s[0],\n          c = u ? 0 === s[1] ? o * (s[0] / 7.3) : o * function (t, e, r) {\n      const n = Math.floor(e[0] / 8),\n            i = Math.floor(e[1] / 8),\n            s = 10 * (e[0] - 8 * n),\n            o = 10 * (e[1] - 8 * i),\n            a = t.getElevationAt(n, i, !0, !0),\n            l = t.getMeterToDEM(r),\n            u = Math.floor(.5 * (s * l - 1)),\n            c = Math.floor(.5 * (o * l - 1)),\n            h = t.tileCoordToPixel(n, i),\n            p = 2 * u + 1,\n            f = 2 * c + 1,\n            d = function (t, e, r, n, i) {\n        return [t.getElevationAtPixel(e, r, !0), t.getElevationAtPixel(e + i, r, !0), t.getElevationAtPixel(e, r + i, !0), t.getElevationAtPixel(e + n, r + i, !0)];\n      }(t, h.x - u, h.y - c, p, f),\n            y = Math.abs(d[0] - d[1]),\n            m = Math.abs(d[2] - d[3]),\n            g = Math.abs(d[0] - d[2]) + Math.abs(d[1] - d[3]),\n            x = Math.min(.25, .5 * l * (y + m) / p),\n            v = Math.min(.25, .5 * l * g / f);\n\n      return a + Math.max(x * s, v * o);\n    }(i, s, a) : l;\n    return {\n      base: l + (0 === r) ? -1 : r,\n      top: u ? Math.max(c + n, l + r + 2) : l + n\n    };\n  }\n\n  const Ta = Ai([{\n    name: \"a_pos_normal\",\n    components: 2,\n    type: \"Int16\"\n  }, {\n    name: \"a_data\",\n    components: 4,\n    type: \"Uint8\"\n  }, {\n    name: \"a_linesofar\",\n    components: 1,\n    type: \"Float32\"\n  }], 4),\n        {\n    members: Ea\n  } = Ta,\n        Da = Ai([{\n    name: \"a_uv_x\",\n    components: 1,\n    type: \"Float32\"\n  }, {\n    name: \"a_split_index\",\n    components: 1,\n    type: \"Float32\"\n  }]),\n        {\n    members: Fa\n  } = Da,\n        La = wa.VectorTileFeature.types,\n        Oa = Math.cos(Math.PI / 180 * 37.5);\n\n  class $a {\n    constructor(t) {\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(t => {\n        this.gradients[t.id] = {};\n      }), this.layoutVertexArray = new Bi(), this.layoutVertexArray2 = new Pi(), this.indexArray = new $i(), this.programConfigurations = new As(t.layers, t.zoom), this.segments = new Cs(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n    }\n\n    populate(t, e, r) {\n      this.hasPattern = sa(\"line\", this.layers, e);\n      const n = this.layers[0].layout.get(\"line-sort-key\"),\n            i = [];\n\n      for (const {\n        feature: e,\n        id: s,\n        index: o,\n        sourceLayerIndex: a\n      } of t) {\n        const t = this.layers[0]._featureFilter.needGeometry,\n              l = Ds(e, t);\n        if (!this.layers[0]._featureFilter.filter(new oi(this.zoom), l, r)) continue;\n        const u = n ? n.evaluate(l, {}, r) : void 0,\n              c = {\n          id: s,\n          properties: e.properties,\n          type: e.type,\n          sourceLayerIndex: a,\n          index: o,\n          geometry: t ? l.geometry : Es(e),\n          patterns: {},\n          sortKey: u\n        };\n        i.push(c);\n      }\n\n      n && i.sort((t, e) => t.sortKey - e.sortKey);\n\n      for (const n of i) {\n        const {\n          geometry: i,\n          index: s,\n          sourceLayerIndex: o\n        } = n;\n\n        if (this.hasPattern) {\n          const t = oa(\"line\", this.layers, n, this.zoom, e);\n          this.patternFeatures.push(t);\n        } else this.addFeature(n, i, s, r, {});\n\n        e.featureIndex.insert(t[s].feature, i, s, o, this.index);\n      }\n    }\n\n    update(t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }\n\n    addFeatures(t, e, r) {\n      for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r);\n    }\n\n    isEmpty() {\n      return 0 === this.layoutVertexArray.length;\n    }\n\n    uploadPending() {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }\n\n    upload(t) {\n      this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Fa)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ea), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }\n\n    destroy() {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n    }\n\n    lineFeatureClips(t) {\n      if (t.properties && t.properties.hasOwnProperty(\"mapbox_clip_start\") && t.properties.hasOwnProperty(\"mapbox_clip_end\")) return {\n        start: +t.properties.mapbox_clip_start,\n        end: +t.properties.mapbox_clip_end\n      };\n    }\n\n    addFeature(t, e, r, n, i) {\n      const s = this.layers[0].layout,\n            o = s.get(\"line-join\").evaluate(t, {}),\n            a = s.get(\"line-cap\"),\n            l = s.get(\"line-miter-limit\"),\n            u = s.get(\"line-round-limit\");\n      this.lineClips = this.lineFeatureClips(t);\n\n      for (const r of e) this.addLine(r, t, o, a, l, u);\n\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n    }\n\n    addLine(t, e, r, n, i, s) {\n      if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {\n        this.lineClipsArray.push(this.lineClips);\n\n        for (let e = 0; e < t.length - 1; e++) this.totalDistance += t[e].dist(t[e + 1]);\n\n        this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);\n      }\n\n      const o = \"Polygon\" === La[e.type];\n      let a = t.length;\n\n      for (; a >= 2 && t[a - 1].equals(t[a - 2]);) a--;\n\n      let l = 0;\n\n      for (; l < a - 1 && t[l].equals(t[l + 1]);) l++;\n\n      if (a < (o ? 3 : 2)) return;\n      \"bevel\" === r && (i = 1.05);\n      const u = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,\n            c = this.segments.prepareSegment(10 * a, this.layoutVertexArray, this.indexArray);\n      let h,\n          p = void 0,\n          f = void 0,\n          d = void 0,\n          y = void 0;\n      this.e1 = this.e2 = -1, o && (h = t[a - 2], y = t[l].sub(h)._unit()._perp());\n\n      for (let e = l; e < a; e++) {\n        if (f = e === a - 1 ? o ? t[l + 1] : void 0 : t[e + 1], f && t[e].equals(f)) continue;\n        y && (d = y), h && (p = h), h = t[e], y = f ? f.sub(h)._unit()._perp() : d, d = d || y;\n        let m = d.add(y);\n        0 === m.x && 0 === m.y || m._unit();\n\n        const g = d.x * y.x + d.y * y.y,\n              x = m.x * y.x + m.y * y.y,\n              v = 0 !== x ? 1 / x : 1 / 0,\n              b = 2 * Math.sqrt(2 - 2 * x),\n              w = x < Oa && p && f,\n              _ = d.x * y.y - d.y * y.x > 0;\n\n        if (w && e > l) {\n          const t = h.dist(p);\n\n          if (t > 2 * u) {\n            const e = h.sub(h.sub(p)._mult(u / t)._round());\n            this.updateDistance(p, e), this.addCurrentVertex(e, d, 0, 0, c), p = e;\n          }\n        }\n\n        const k = p && f;\n        let S = k ? r : o ? \"butt\" : n;\n        if (k && \"round\" === S && (v < s ? S = \"miter\" : v <= 2 && (S = \"fakeround\")), \"miter\" === S && v > i && (S = \"bevel\"), \"bevel\" === S && (v > 2 && (S = \"flipbevel\"), v < i && (S = \"miter\")), p && this.updateDistance(p, h), \"miter\" === S) m._mult(v), this.addCurrentVertex(h, m, 0, 0, c);else if (\"flipbevel\" === S) {\n          if (v > 100) m = y.mult(-1);else {\n            const t = v * d.add(y).mag() / d.sub(y).mag();\n\n            m._perp()._mult(t * (_ ? -1 : 1));\n          }\n          this.addCurrentVertex(h, m, 0, 0, c), this.addCurrentVertex(h, m.mult(-1), 0, 0, c);\n        } else if (\"bevel\" === S || \"fakeround\" === S) {\n          const t = -Math.sqrt(v * v - 1),\n                e = _ ? t : 0,\n                r = _ ? 0 : t;\n\n          if (p && this.addCurrentVertex(h, d, e, r, c), \"fakeround\" === S) {\n            const t = Math.round(180 * b / Math.PI / 20);\n\n            for (let e = 1; e < t; e++) {\n              let r = e / t;\n\n              if (.5 !== r) {\n                const t = r - .5;\n                r += r * t * (r - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * t * t + (.848013 + g * (.215638 * g - 1.06021)));\n              }\n\n              const n = y.sub(d)._mult(r)._add(d)._unit()._mult(_ ? -1 : 1);\n\n              this.addHalfVertex(h, n.x, n.y, !1, _, 0, c);\n            }\n          }\n\n          f && this.addCurrentVertex(h, y, -e, -r, c);\n        } else if (\"butt\" === S) this.addCurrentVertex(h, m, 0, 0, c);else if (\"square\" === S) {\n          const t = p ? 1 : -1;\n          this.addCurrentVertex(h, m, t, t, c);\n        } else \"round\" === S && (p && (this.addCurrentVertex(h, d, 0, 0, c), this.addCurrentVertex(h, d, 1, 1, c, !0)), f && (this.addCurrentVertex(h, y, -1, -1, c, !0), this.addCurrentVertex(h, y, 0, 0, c)));\n\n        if (w && e < a - 1) {\n          const t = h.dist(f);\n\n          if (t > 2 * u) {\n            const e = h.add(f.sub(h)._mult(u / t)._round());\n            this.updateDistance(h, e), this.addCurrentVertex(e, y, 0, 0, c), h = e;\n          }\n        }\n      }\n    }\n\n    addCurrentVertex(t, e, r, n, i, s = !1) {\n      const o = e.y * n - e.x,\n            a = -e.y - e.x * n;\n      this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, s, !1, r, i), this.addHalfVertex(t, o, a, s, !0, -n, i);\n    }\n\n    addHalfVertex({\n      x: t,\n      y: e\n    }, r, n, i, s, o, a) {\n      this.layoutVertexArray.emplaceBack((t << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === o ? 0 : o < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length);\n      const l = a.vertexLength++;\n      this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l), a.primitiveLength++), s ? this.e2 = l : this.e1 = l;\n    }\n\n    updateScaledDistance() {\n      if (this.lineClips) {\n        const t = this.totalDistance / (this.lineClips.end - this.lineClips.start);\n        this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t * this.lineClips.start + this.distance;\n      } else this.lineSoFar = this.distance;\n    }\n\n    updateDistance(t, e) {\n      this.distance += t.dist(e), this.updateScaledDistance();\n    }\n\n  }\n\n  Je(\"LineBucket\", $a, {\n    omit: [\"layers\", \"patternFeatures\"]\n  });\n  const Ra = new bi({\n    \"line-cap\": new yi(sr.layout_line[\"line-cap\"]),\n    \"line-join\": new mi(sr.layout_line[\"line-join\"]),\n    \"line-miter-limit\": new yi(sr.layout_line[\"line-miter-limit\"]),\n    \"line-round-limit\": new yi(sr.layout_line[\"line-round-limit\"]),\n    \"line-sort-key\": new mi(sr.layout_line[\"line-sort-key\"])\n  });\n  var qa = {\n    paint: new bi({\n      \"line-opacity\": new mi(sr.paint_line[\"line-opacity\"]),\n      \"line-color\": new mi(sr.paint_line[\"line-color\"]),\n      \"line-translate\": new yi(sr.paint_line[\"line-translate\"]),\n      \"line-translate-anchor\": new yi(sr.paint_line[\"line-translate-anchor\"]),\n      \"line-width\": new mi(sr.paint_line[\"line-width\"]),\n      \"line-gap-width\": new mi(sr.paint_line[\"line-gap-width\"]),\n      \"line-offset\": new mi(sr.paint_line[\"line-offset\"]),\n      \"line-blur\": new mi(sr.paint_line[\"line-blur\"]),\n      \"line-dasharray\": new xi(sr.paint_line[\"line-dasharray\"]),\n      \"line-pattern\": new gi(sr.paint_line[\"line-pattern\"]),\n      \"line-gradient\": new vi(sr.paint_line[\"line-gradient\"])\n    }),\n    layout: Ra\n  };\n  const Ua = new class extends mi {\n    possiblyEvaluate(t, e) {\n      return e = new oi(Math.floor(e.zoom), {\n        now: e.now,\n        fadeDuration: e.fadeDuration,\n        zoomHistory: e.zoomHistory,\n        transition: e.transition\n      }), super.possiblyEvaluate(t, e);\n    }\n\n    evaluate(t, e, r, n) {\n      return e = c({}, e, {\n        zoom: Math.floor(e.zoom)\n      }), super.evaluate(t, e, r, n);\n    }\n\n  }(qa.paint.properties[\"line-width\"].specification);\n\n  function Na(t, e) {\n    return e > 0 ? e + 2 * t : t;\n  }\n\n  Ua.useIntegerZoom = !0;\n  const ja = Ai([{\n    name: \"a_pos_offset\",\n    components: 4,\n    type: \"Int16\"\n  }, {\n    name: \"a_data\",\n    components: 4,\n    type: \"Uint16\"\n  }, {\n    name: \"a_pixeloffset\",\n    components: 4,\n    type: \"Int16\"\n  }], 4),\n        Za = Ai([{\n    name: \"a_projected_pos\",\n    components: 3,\n    type: \"Float32\"\n  }], 4),\n        Ga = (Ai([{\n    name: \"a_fade_opacity\",\n    components: 1,\n    type: \"Uint32\"\n  }], 4), Ai([{\n    name: \"a_placed\",\n    components: 2,\n    type: \"Uint8\"\n  }, {\n    name: \"a_shift\",\n    components: 2,\n    type: \"Float32\"\n  }])),\n        Xa = Ai([{\n    name: \"a_size_scale\",\n    components: 1,\n    type: \"Float32\"\n  }, {\n    name: \"a_padding\",\n    components: 2,\n    type: \"Float32\"\n  }]),\n        Ja = (Ai([{\n    type: \"Int16\",\n    name: \"anchorPointX\"\n  }, {\n    type: \"Int16\",\n    name: \"anchorPointY\"\n  }, {\n    type: \"Float32\",\n    name: \"x1\"\n  }, {\n    type: \"Float32\",\n    name: \"y1\"\n  }, {\n    type: \"Float32\",\n    name: \"x2\"\n  }, {\n    type: \"Float32\",\n    name: \"y2\"\n  }, {\n    type: \"Int16\",\n    name: \"padding\"\n  }, {\n    type: \"Uint32\",\n    name: \"featureIndex\"\n  }, {\n    type: \"Uint16\",\n    name: \"sourceLayerIndex\"\n  }, {\n    type: \"Uint16\",\n    name: \"bucketIndex\"\n  }]), Ai([{\n    name: \"a_pos\",\n    components: 2,\n    type: \"Int16\"\n  }, {\n    name: \"a_anchor_pos\",\n    components: 2,\n    type: \"Int16\"\n  }, {\n    name: \"a_extrude\",\n    components: 2,\n    type: \"Int16\"\n  }], 4));\n\n  function Ya(t, e) {\n    const {\n      expression: r\n    } = e;\n    if (\"constant\" === r.kind) return {\n      kind: \"constant\",\n      layoutSize: r.evaluate(new oi(t + 1))\n    };\n    if (\"source\" === r.kind) return {\n      kind: \"source\"\n    };\n    {\n      const {\n        zoomStops: e,\n        interpolationType: n\n      } = r;\n      let i = 0;\n\n      for (; i < e.length && e[i] <= t;) i++;\n\n      i = Math.max(0, i - 1);\n      let s = i;\n\n      for (; s < e.length && e[s] < t + 1;) s++;\n\n      s = Math.min(e.length - 1, s);\n      const o = e[i],\n            a = e[s];\n      return \"composite\" === r.kind ? {\n        kind: \"composite\",\n        minZoom: o,\n        maxZoom: a,\n        interpolationType: n\n      } : {\n        kind: \"camera\",\n        minZoom: o,\n        maxZoom: a,\n        minSize: r.evaluate(new oi(o)),\n        maxSize: r.evaluate(new oi(a)),\n        interpolationType: n\n      };\n    }\n  }\n\n  function Ka(t, {\n    uSize: e,\n    uSizeT: r\n  }, {\n    lowerSize: n,\n    upperSize: i\n  }) {\n    return \"source\" === t.kind ? n / 128 : \"composite\" === t.kind ? $t(n / 128, i / 128, r) : e;\n  }\n\n  function Ha(t, e) {\n    let r = 0,\n        n = 0;\n    if (\"constant\" === t.kind) n = t.layoutSize;else if (\"source\" !== t.kind) {\n      const {\n        interpolationType: i,\n        minZoom: s,\n        maxZoom: o\n      } = t,\n            a = i ? l(te.interpolationFactor(i, e, s, o), 0, 1) : 0;\n      \"camera\" === t.kind ? n = $t(t.minSize, t.maxSize, a) : r = a;\n    }\n    return {\n      uSizeT: r,\n      uSize: n\n    };\n  }\n\n  function Wa(t, e, r) {\n    return t.sections.forEach(t => {\n      t.text = function (t, e, r) {\n        const n = e.layout.get(\"text-transform\").evaluate(r, {});\n        return \"uppercase\" === n ? t = t.toLocaleUpperCase() : \"lowercase\" === n && (t = t.toLocaleLowerCase()), si.applyArabicShaping && (t = si.applyArabicShaping(t)), t;\n      }(t.text, e, r);\n    }), t;\n  }\n\n  Ai([{\n    name: \"a_pos_2f\",\n    components: 2,\n    type: \"Float32\"\n  }, {\n    name: \"a_radius\",\n    components: 1,\n    type: \"Float32\"\n  }, {\n    name: \"a_flags\",\n    components: 2,\n    type: \"Int16\"\n  }], 4), Ai([{\n    name: \"triangle\",\n    components: 3,\n    type: \"Uint16\"\n  }]), Ai([{\n    type: \"Int16\",\n    name: \"anchorX\"\n  }, {\n    type: \"Int16\",\n    name: \"anchorY\"\n  }, {\n    type: \"Uint16\",\n    name: \"glyphStartIndex\"\n  }, {\n    type: \"Uint16\",\n    name: \"numGlyphs\"\n  }, {\n    type: \"Uint32\",\n    name: \"vertexStartIndex\"\n  }, {\n    type: \"Uint32\",\n    name: \"lineStartIndex\"\n  }, {\n    type: \"Uint32\",\n    name: \"lineLength\"\n  }, {\n    type: \"Uint16\",\n    name: \"segment\"\n  }, {\n    type: \"Uint16\",\n    name: \"lowerSize\"\n  }, {\n    type: \"Uint16\",\n    name: \"upperSize\"\n  }, {\n    type: \"Float32\",\n    name: \"lineOffsetX\"\n  }, {\n    type: \"Float32\",\n    name: \"lineOffsetY\"\n  }, {\n    type: \"Uint8\",\n    name: \"writingMode\"\n  }, {\n    type: \"Uint8\",\n    name: \"placedOrientation\"\n  }, {\n    type: \"Uint8\",\n    name: \"hidden\"\n  }, {\n    type: \"Uint32\",\n    name: \"crossTileID\"\n  }, {\n    type: \"Int16\",\n    name: \"associatedIconIndex\"\n  }]), Ai([{\n    type: \"Int16\",\n    name: \"anchorX\"\n  }, {\n    type: \"Int16\",\n    name: \"anchorY\"\n  }, {\n    type: \"Int16\",\n    name: \"rightJustifiedTextSymbolIndex\"\n  }, {\n    type: \"Int16\",\n    name: \"centerJustifiedTextSymbolIndex\"\n  }, {\n    type: \"Int16\",\n    name: \"leftJustifiedTextSymbolIndex\"\n  }, {\n    type: \"Int16\",\n    name: \"verticalPlacedTextSymbolIndex\"\n  }, {\n    type: \"Int16\",\n    name: \"placedIconSymbolIndex\"\n  }, {\n    type: \"Int16\",\n    name: \"verticalPlacedIconSymbolIndex\"\n  }, {\n    type: \"Uint16\",\n    name: \"key\"\n  }, {\n    type: \"Uint16\",\n    name: \"textBoxStartIndex\"\n  }, {\n    type: \"Uint16\",\n    name: \"textBoxEndIndex\"\n  }, {\n    type: \"Uint16\",\n    name: \"verticalTextBoxStartIndex\"\n  }, {\n    type: \"Uint16\",\n    name: \"verticalTextBoxEndIndex\"\n  }, {\n    type: \"Uint16\",\n    name: \"iconBoxStartIndex\"\n  }, {\n    type: \"Uint16\",\n    name: \"iconBoxEndIndex\"\n  }, {\n    type: \"Uint16\",\n    name: \"verticalIconBoxStartIndex\"\n  }, {\n    type: \"Uint16\",\n    name: \"verticalIconBoxEndIndex\"\n  }, {\n    type: \"Uint16\",\n    name: \"featureIndex\"\n  }, {\n    type: \"Uint16\",\n    name: \"numHorizontalGlyphVertices\"\n  }, {\n    type: \"Uint16\",\n    name: \"numVerticalGlyphVertices\"\n  }, {\n    type: \"Uint16\",\n    name: \"numIconVertices\"\n  }, {\n    type: \"Uint16\",\n    name: \"numVerticalIconVertices\"\n  }, {\n    type: \"Uint16\",\n    name: \"useRuntimeCollisionCircles\"\n  }, {\n    type: \"Uint32\",\n    name: \"crossTileID\"\n  }, {\n    type: \"Float32\",\n    name: \"textBoxScale\"\n  }, {\n    type: \"Float32\",\n    components: 2,\n    name: \"textOffset\"\n  }, {\n    type: \"Float32\",\n    name: \"collisionCircleDiameter\"\n  }]), Ai([{\n    type: \"Float32\",\n    name: \"offsetX\"\n  }]), Ai([{\n    type: \"Int16\",\n    name: \"x\"\n  }, {\n    type: \"Int16\",\n    name: \"y\"\n  }, {\n    type: \"Int16\",\n    name: \"tileUnitDistanceFromAnchor\"\n  }]);\n  const Qa = {\n    \"!\": \"\",\n    \"#\": \"\",\n    $: \"\",\n    \"%\": \"\",\n    \"&\": \"\",\n    \"(\": \"\",\n    \")\": \"\",\n    \"*\": \"\",\n    \"+\": \"\",\n    \",\": \"\",\n    \"-\": \"\",\n    \".\": \"\",\n    \"/\": \"\",\n    \":\": \"\",\n    \";\": \"\",\n    \"<\": \"\",\n    \"=\": \"\",\n    \">\": \"\",\n    \"?\": \"\",\n    \"@\": \"\",\n    \"[\": \"\",\n    \"\\\\\": \"\",\n    \"]\": \"\",\n    \"^\": \"\",\n    _: \"\",\n    \"`\": \"\",\n    \"{\": \"\",\n    \"|\": \"\",\n    \"}\": \"\",\n    \"~\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\",\n    \"\": \"\"\n  };\n\n  var tl = function (t, e, r, n, i) {\n    var s,\n        o,\n        a = 8 * i - n - 1,\n        l = (1 << a) - 1,\n        u = l >> 1,\n        c = -7,\n        h = r ? i - 1 : 0,\n        p = r ? -1 : 1,\n        f = t[e + h];\n\n    for (h += p, s = f & (1 << -c) - 1, f >>= -c, c += a; c > 0; s = 256 * s + t[e + h], h += p, c -= 8);\n\n    for (o = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; o = 256 * o + t[e + h], h += p, c -= 8);\n\n    if (0 === s) s = 1 - u;else {\n      if (s === l) return o ? NaN : 1 / 0 * (f ? -1 : 1);\n      o += Math.pow(2, n), s -= u;\n    }\n    return (f ? -1 : 1) * o * Math.pow(2, s - n);\n  },\n      el = function (t, e, r, n, i, s) {\n    var o,\n        a,\n        l,\n        u = 8 * s - i - 1,\n        c = (1 << u) - 1,\n        h = c >> 1,\n        p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n        f = n ? 0 : s - 1,\n        d = n ? 1 : -1,\n        y = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;\n\n    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = c) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), (e += o + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (o++, l /= 2), o + h >= c ? (a = 0, o = c) : o + h >= 1 ? (a = (e * l - 1) * Math.pow(2, i), o += h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, i), o = 0)); i >= 8; t[r + f] = 255 & a, f += d, a /= 256, i -= 8);\n\n    for (o = o << i | a, u += i; u > 0; t[r + f] = 255 & o, f += d, o /= 256, u -= 8);\n\n    t[r + f - d] |= 128 * y;\n  },\n      rl = nl;\n\n  function nl(t) {\n    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;\n  }\n\n  nl.Varint = 0, nl.Fixed64 = 1, nl.Bytes = 2, nl.Fixed32 = 5;\n  var il = \"undefined\" == typeof TextDecoder ? null : new TextDecoder(\"utf8\");\n\n  function sl(t) {\n    return t.type === nl.Bytes ? t.readVarint() + t.pos : t.pos + 1;\n  }\n\n  function ol(t, e, r) {\n    return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);\n  }\n\n  function al(t, e, r) {\n    var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));\n    r.realloc(n);\n\n    for (var i = r.pos - 1; i >= t; i--) r.buf[i + n] = r.buf[i];\n  }\n\n  function ll(t, e) {\n    for (var r = 0; r < t.length; r++) e.writeVarint(t[r]);\n  }\n\n  function ul(t, e) {\n    for (var r = 0; r < t.length; r++) e.writeSVarint(t[r]);\n  }\n\n  function cl(t, e) {\n    for (var r = 0; r < t.length; r++) e.writeFloat(t[r]);\n  }\n\n  function hl(t, e) {\n    for (var r = 0; r < t.length; r++) e.writeDouble(t[r]);\n  }\n\n  function pl(t, e) {\n    for (var r = 0; r < t.length; r++) e.writeBoolean(t[r]);\n  }\n\n  function fl(t, e) {\n    for (var r = 0; r < t.length; r++) e.writeFixed32(t[r]);\n  }\n\n  function dl(t, e) {\n    for (var r = 0; r < t.length; r++) e.writeSFixed32(t[r]);\n  }\n\n  function yl(t, e) {\n    for (var r = 0; r < t.length; r++) e.writeFixed64(t[r]);\n  }\n\n  function ml(t, e) {\n    for (var r = 0; r < t.length; r++) e.writeSFixed64(t[r]);\n  }\n\n  function gl(t, e) {\n    return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];\n  }\n\n  function xl(t, e, r) {\n    t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24;\n  }\n\n  function vl(t, e) {\n    return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);\n  }\n\n  function bl(t) {\n    let e = 0,\n        r = 0;\n\n    for (const n of t) e += n.w * n.h, r = Math.max(r, n.w);\n\n    t.sort((t, e) => e.h - t.h);\n    const n = [{\n      x: 0,\n      y: 0,\n      w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),\n      h: 1 / 0\n    }];\n    let i = 0,\n        s = 0;\n\n    for (const e of t) for (let t = n.length - 1; t >= 0; t--) {\n      const r = n[t];\n\n      if (!(e.w > r.w || e.h > r.h)) {\n        if (e.x = r.x, e.y = r.y, s = Math.max(s, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {\n          const e = n.pop();\n          t < n.length && (n[t] = e);\n        } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({\n          x: r.x + e.w,\n          y: r.y,\n          w: r.w - e.w,\n          h: e.h\n        }), r.y += e.h, r.h -= e.h);\n\n        break;\n      }\n    }\n\n    return {\n      w: i,\n      h: s,\n      fill: e / (i * s) || 0\n    };\n  }\n\n  nl.prototype = {\n    destroy: function () {\n      this.buf = null;\n    },\n    readFields: function (t, e, r) {\n      for (r = r || this.length; this.pos < r;) {\n        var n = this.readVarint(),\n            i = n >> 3,\n            s = this.pos;\n        this.type = 7 & n, t(i, e, this), this.pos === s && this.skip(n);\n      }\n\n      return e;\n    },\n    readMessage: function (t, e) {\n      return this.readFields(t, e, this.readVarint() + this.pos);\n    },\n    readFixed32: function () {\n      var t = gl(this.buf, this.pos);\n      return this.pos += 4, t;\n    },\n    readSFixed32: function () {\n      var t = vl(this.buf, this.pos);\n      return this.pos += 4, t;\n    },\n    readFixed64: function () {\n      var t = gl(this.buf, this.pos) + 4294967296 * gl(this.buf, this.pos + 4);\n      return this.pos += 8, t;\n    },\n    readSFixed64: function () {\n      var t = gl(this.buf, this.pos) + 4294967296 * vl(this.buf, this.pos + 4);\n      return this.pos += 8, t;\n    },\n    readFloat: function () {\n      var t = tl(this.buf, this.pos, !0, 23, 4);\n      return this.pos += 4, t;\n    },\n    readDouble: function () {\n      var t = tl(this.buf, this.pos, !0, 52, 8);\n      return this.pos += 8, t;\n    },\n    readVarint: function (t) {\n      var e,\n          r,\n          n = this.buf;\n      return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function (t, e, r) {\n        var n,\n            i,\n            s = r.buf;\n        if (n = (112 & (i = s[r.pos++])) >> 4, i < 128) return ol(t, n, e);\n        if (n |= (127 & (i = s[r.pos++])) << 3, i < 128) return ol(t, n, e);\n        if (n |= (127 & (i = s[r.pos++])) << 10, i < 128) return ol(t, n, e);\n        if (n |= (127 & (i = s[r.pos++])) << 17, i < 128) return ol(t, n, e);\n        if (n |= (127 & (i = s[r.pos++])) << 24, i < 128) return ol(t, n, e);\n        if (n |= (1 & (i = s[r.pos++])) << 31, i < 128) return ol(t, n, e);\n        throw new Error(\"Expected varint not more than 10 bytes\");\n      }(e |= (15 & (r = n[this.pos])) << 28, t, this))));\n    },\n    readVarint64: function () {\n      return this.readVarint(!0);\n    },\n    readSVarint: function () {\n      var t = this.readVarint();\n      return t % 2 == 1 ? (t + 1) / -2 : t / 2;\n    },\n    readBoolean: function () {\n      return Boolean(this.readVarint());\n    },\n    readString: function () {\n      var t = this.readVarint() + this.pos,\n          e = this.pos;\n      return this.pos = t, t - e >= 12 && il ? function (t, e, r) {\n        return il.decode(t.subarray(e, r));\n      }(this.buf, e, t) : function (t, e, r) {\n        for (var n = \"\", i = e; i < r;) {\n          var s,\n              o,\n              a,\n              l = t[i],\n              u = null,\n              c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;\n          if (i + c > r) break;\n          1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (s = t[i + 1])) && (u = (31 & l) << 6 | 63 & s) <= 127 && (u = null) : 3 === c ? (o = t[i + 2], 128 == (192 & (s = t[i + 1])) && 128 == (192 & o) && ((u = (15 & l) << 12 | (63 & s) << 6 | 63 & o) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (o = t[i + 2], a = t[i + 3], 128 == (192 & (s = t[i + 1])) && 128 == (192 & o) && 128 == (192 & a) && ((u = (15 & l) << 18 | (63 & s) << 12 | (63 & o) << 6 | 63 & a) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;\n        }\n\n        return n;\n      }(this.buf, e, t);\n    },\n    readBytes: function () {\n      var t = this.readVarint() + this.pos,\n          e = this.buf.subarray(this.pos, t);\n      return this.pos = t, e;\n    },\n    readPackedVarint: function (t, e) {\n      if (this.type !== nl.Bytes) return t.push(this.readVarint(e));\n      var r = sl(this);\n\n      for (t = t || []; this.pos < r;) t.push(this.readVarint(e));\n\n      return t;\n    },\n    readPackedSVarint: function (t) {\n      if (this.type !== nl.Bytes) return t.push(this.readSVarint());\n      var e = sl(this);\n\n      for (t = t || []; this.pos < e;) t.push(this.readSVarint());\n\n      return t;\n    },\n    readPackedBoolean: function (t) {\n      if (this.type !== nl.Bytes) return t.push(this.readBoolean());\n      var e = sl(this);\n\n      for (t = t || []; this.pos < e;) t.push(this.readBoolean());\n\n      return t;\n    },\n    readPackedFloat: function (t) {\n      if (this.type !== nl.Bytes) return t.push(this.readFloat());\n      var e = sl(this);\n\n      for (t = t || []; this.pos < e;) t.push(this.readFloat());\n\n      return t;\n    },\n    readPackedDouble: function (t) {\n      if (this.type !== nl.Bytes) return t.push(this.readDouble());\n      var e = sl(this);\n\n      for (t = t || []; this.pos < e;) t.push(this.readDouble());\n\n      return t;\n    },\n    readPackedFixed32: function (t) {\n      if (this.type !== nl.Bytes) return t.push(this.readFixed32());\n      var e = sl(this);\n\n      for (t = t || []; this.pos < e;) t.push(this.readFixed32());\n\n      return t;\n    },\n    readPackedSFixed32: function (t) {\n      if (this.type !== nl.Bytes) return t.push(this.readSFixed32());\n      var e = sl(this);\n\n      for (t = t || []; this.pos < e;) t.push(this.readSFixed32());\n\n      return t;\n    },\n    readPackedFixed64: function (t) {\n      if (this.type !== nl.Bytes) return t.push(this.readFixed64());\n      var e = sl(this);\n\n      for (t = t || []; this.pos < e;) t.push(this.readFixed64());\n\n      return t;\n    },\n    readPackedSFixed64: function (t) {\n      if (this.type !== nl.Bytes) return t.push(this.readSFixed64());\n      var e = sl(this);\n\n      for (t = t || []; this.pos < e;) t.push(this.readSFixed64());\n\n      return t;\n    },\n    skip: function (t) {\n      var e = 7 & t;\n      if (e === nl.Varint) for (; this.buf[this.pos++] > 127;);else if (e === nl.Bytes) this.pos = this.readVarint() + this.pos;else if (e === nl.Fixed32) this.pos += 4;else {\n        if (e !== nl.Fixed64) throw new Error(\"Unimplemented type: \" + e);\n        this.pos += 8;\n      }\n    },\n    writeTag: function (t, e) {\n      this.writeVarint(t << 3 | e);\n    },\n    realloc: function (t) {\n      for (var e = this.length || 16; e < this.pos + t;) e *= 2;\n\n      if (e !== this.length) {\n        var r = new Uint8Array(e);\n        r.set(this.buf), this.buf = r, this.length = e;\n      }\n    },\n    finish: function () {\n      return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);\n    },\n    writeFixed32: function (t) {\n      this.realloc(4), xl(this.buf, t, this.pos), this.pos += 4;\n    },\n    writeSFixed32: function (t) {\n      this.realloc(4), xl(this.buf, t, this.pos), this.pos += 4;\n    },\n    writeFixed64: function (t) {\n      this.realloc(8), xl(this.buf, -1 & t, this.pos), xl(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8;\n    },\n    writeSFixed64: function (t) {\n      this.realloc(8), xl(this.buf, -1 & t, this.pos), xl(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8;\n    },\n    writeVarint: function (t) {\n      (t = +t || 0) > 268435455 || t < 0 ? function (t, e) {\n        var r, n;\n        if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error(\"Given varint doesn't fit into 10 bytes\");\n        e.realloc(10), function (t, e, r) {\n          r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7);\n        }(r, 0, e), function (t, e) {\n          var r = (7 & t) << 4;\n          e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));\n        }(n, e);\n      }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));\n    },\n    writeSVarint: function (t) {\n      this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);\n    },\n    writeBoolean: function (t) {\n      this.writeVarint(Boolean(t));\n    },\n    writeString: function (t) {\n      t = String(t), this.realloc(4 * t.length), this.pos++;\n      var e = this.pos;\n\n      this.pos = function (t, e, r) {\n        for (var n, i, s = 0; s < e.length; s++) {\n          if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {\n            if (!i) {\n              n > 56319 || s + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n;\n              continue;\n            }\n\n            if (n < 56320) {\n              t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n;\n              continue;\n            }\n\n            n = i - 55296 << 10 | n - 56320 | 65536, i = null;\n          } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null);\n\n          n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);\n        }\n\n        return r;\n      }(this.buf, t, this.pos);\n\n      var r = this.pos - e;\n      r >= 128 && al(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;\n    },\n    writeFloat: function (t) {\n      this.realloc(4), el(this.buf, t, this.pos, !0, 23, 4), this.pos += 4;\n    },\n    writeDouble: function (t) {\n      this.realloc(8), el(this.buf, t, this.pos, !0, 52, 8), this.pos += 8;\n    },\n    writeBytes: function (t) {\n      var e = t.length;\n      this.writeVarint(e), this.realloc(e);\n\n      for (var r = 0; r < e; r++) this.buf[this.pos++] = t[r];\n    },\n    writeRawMessage: function (t, e) {\n      this.pos++;\n      var r = this.pos;\n      t(e, this);\n      var n = this.pos - r;\n      n >= 128 && al(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;\n    },\n    writeMessage: function (t, e, r) {\n      this.writeTag(t, nl.Bytes), this.writeRawMessage(e, r);\n    },\n    writePackedVarint: function (t, e) {\n      e.length && this.writeMessage(t, ll, e);\n    },\n    writePackedSVarint: function (t, e) {\n      e.length && this.writeMessage(t, ul, e);\n    },\n    writePackedBoolean: function (t, e) {\n      e.length && this.writeMessage(t, pl, e);\n    },\n    writePackedFloat: function (t, e) {\n      e.length && this.writeMessage(t, cl, e);\n    },\n    writePackedDouble: function (t, e) {\n      e.length && this.writeMessage(t, hl, e);\n    },\n    writePackedFixed32: function (t, e) {\n      e.length && this.writeMessage(t, fl, e);\n    },\n    writePackedSFixed32: function (t, e) {\n      e.length && this.writeMessage(t, dl, e);\n    },\n    writePackedFixed64: function (t, e) {\n      e.length && this.writeMessage(t, yl, e);\n    },\n    writePackedSFixed64: function (t, e) {\n      e.length && this.writeMessage(t, ml, e);\n    },\n    writeBytesField: function (t, e) {\n      this.writeTag(t, nl.Bytes), this.writeBytes(e);\n    },\n    writeFixed32Field: function (t, e) {\n      this.writeTag(t, nl.Fixed32), this.writeFixed32(e);\n    },\n    writeSFixed32Field: function (t, e) {\n      this.writeTag(t, nl.Fixed32), this.writeSFixed32(e);\n    },\n    writeFixed64Field: function (t, e) {\n      this.writeTag(t, nl.Fixed64), this.writeFixed64(e);\n    },\n    writeSFixed64Field: function (t, e) {\n      this.writeTag(t, nl.Fixed64), this.writeSFixed64(e);\n    },\n    writeVarintField: function (t, e) {\n      this.writeTag(t, nl.Varint), this.writeVarint(e);\n    },\n    writeSVarintField: function (t, e) {\n      this.writeTag(t, nl.Varint), this.writeSVarint(e);\n    },\n    writeStringField: function (t, e) {\n      this.writeTag(t, nl.Bytes), this.writeString(e);\n    },\n    writeFloatField: function (t, e) {\n      this.writeTag(t, nl.Fixed32), this.writeFloat(e);\n    },\n    writeDoubleField: function (t, e) {\n      this.writeTag(t, nl.Fixed64), this.writeDouble(e);\n    },\n    writeBooleanField: function (t, e) {\n      this.writeVarintField(t, Boolean(e));\n    }\n  };\n\n  class wl {\n    constructor(t, {\n      pixelRatio: e,\n      version: r,\n      stretchX: n,\n      stretchY: i,\n      content: s\n    }) {\n      this.paddedRect = t, this.pixelRatio = e, this.stretchX = n, this.stretchY = i, this.content = s, this.version = r;\n    }\n\n    get tl() {\n      return [this.paddedRect.x + 1, this.paddedRect.y + 1];\n    }\n\n    get br() {\n      return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];\n    }\n\n    get tlbr() {\n      return this.tl.concat(this.br);\n    }\n\n    get displaySize() {\n      return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];\n    }\n\n  }\n\n  class _l {\n    constructor(t, e) {\n      const r = {},\n            n = {};\n      this.haveRenderCallbacks = [];\n      const i = [];\n      this.addImages(t, r, i), this.addImages(e, n, i);\n      const {\n        w: s,\n        h: o\n      } = bl(i),\n            a = new bo({\n        width: s || 1,\n        height: o || 1\n      });\n\n      for (const e in t) {\n        const n = t[e],\n              i = r[e].paddedRect;\n        bo.copy(n.data, a, {\n          x: 0,\n          y: 0\n        }, {\n          x: i.x + 1,\n          y: i.y + 1\n        }, n.data);\n      }\n\n      for (const t in e) {\n        const r = e[t],\n              i = n[t].paddedRect,\n              s = i.x + 1,\n              o = i.y + 1,\n              l = r.data.width,\n              u = r.data.height;\n        bo.copy(r.data, a, {\n          x: 0,\n          y: 0\n        }, {\n          x: s,\n          y: o\n        }, r.data), bo.copy(r.data, a, {\n          x: 0,\n          y: u - 1\n        }, {\n          x: s,\n          y: o - 1\n        }, {\n          width: l,\n          height: 1\n        }), bo.copy(r.data, a, {\n          x: 0,\n          y: 0\n        }, {\n          x: s,\n          y: o + u\n        }, {\n          width: l,\n          height: 1\n        }), bo.copy(r.data, a, {\n          x: l - 1,\n          y: 0\n        }, {\n          x: s - 1,\n          y: o\n        }, {\n          width: 1,\n          height: u\n        }), bo.copy(r.data, a, {\n          x: 0,\n          y: 0\n        }, {\n          x: s + l,\n          y: o\n        }, {\n          width: 1,\n          height: u\n        });\n      }\n\n      this.image = a, this.iconPositions = r, this.patternPositions = n;\n    }\n\n    addImages(t, e, r) {\n      for (const n in t) {\n        const i = t[n],\n              s = {\n          x: 0,\n          y: 0,\n          w: i.data.width + 2,\n          h: i.data.height + 2\n        };\n        r.push(s), e[n] = new wl(s, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);\n      }\n    }\n\n    patchUpdatedImages(t, e) {\n      t.dispatchRenderCallbacks(this.haveRenderCallbacks);\n\n      for (const r in t.updatedImages) this.patchUpdatedImage(this.iconPositions[r], t.getImage(r), e), this.patchUpdatedImage(this.patternPositions[r], t.getImage(r), e);\n    }\n\n    patchUpdatedImage(t, e, r) {\n      if (!t || !e) return;\n      if (t.version === e.version) return;\n      t.version = e.version;\n      const [n, i] = t.tl;\n      r.update(e.data, void 0, {\n        x: n,\n        y: i\n      });\n    }\n\n  }\n\n  Je(\"ImagePosition\", wl), Je(\"ImageAtlas\", _l);\n  const kl = {\n    horizontal: 1,\n    vertical: 2,\n    horizontalOnly: 3\n  };\n\n  class Sl {\n    constructor() {\n      this.scale = 1, this.fontStack = \"\", this.imageName = null;\n    }\n\n    static forText(t, e) {\n      const r = new Sl();\n      return r.scale = t || 1, r.fontStack = e, r;\n    }\n\n    static forImage(t) {\n      const e = new Sl();\n      return e.imageName = t, e;\n    }\n\n  }\n\n  class Al {\n    constructor() {\n      this.text = \"\", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;\n    }\n\n    static fromFeature(t, e) {\n      const r = new Al();\n\n      for (let n = 0; n < t.sections.length; n++) {\n        const i = t.sections[n];\n        i.image ? r.addImageSection(i) : r.addTextSection(i, e);\n      }\n\n      return r;\n    }\n\n    length() {\n      return this.text.length;\n    }\n\n    getSection(t) {\n      return this.sections[this.sectionIndex[t]];\n    }\n\n    getSectionIndex(t) {\n      return this.sectionIndex[t];\n    }\n\n    getCharCode(t) {\n      return this.text.charCodeAt(t);\n    }\n\n    verticalizePunctuation() {\n      this.text = function (t) {\n        let e = \"\";\n\n        for (let r = 0; r < t.length; r++) {\n          const n = t.charCodeAt(r + 1) || null,\n                i = t.charCodeAt(r - 1) || null;\n          e += n && zn(n) && !Qa[t[r + 1]] || i && zn(i) && !Qa[t[r - 1]] || !Qa[t[r]] ? t[r] : Qa[t[r]];\n        }\n\n        return e;\n      }(this.text);\n    }\n\n    trim() {\n      let t = 0;\n\n      for (let e = 0; e < this.text.length && zl[this.text.charCodeAt(e)]; e++) t++;\n\n      let e = this.text.length;\n\n      for (let r = this.text.length - 1; r >= 0 && r >= t && zl[this.text.charCodeAt(r)]; r--) e--;\n\n      this.text = this.text.substring(t, e), this.sectionIndex = this.sectionIndex.slice(t, e);\n    }\n\n    substring(t, e) {\n      const r = new Al();\n      return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r;\n    }\n\n    toString() {\n      return this.text;\n    }\n\n    getMaxScale() {\n      return this.sectionIndex.reduce((t, e) => Math.max(t, this.sections[e].scale), 0);\n    }\n\n    addTextSection(t, e) {\n      this.text += t.text, this.sections.push(Sl.forText(t.scale, t.fontStack || e));\n      const r = this.sections.length - 1;\n\n      for (let e = 0; e < t.text.length; ++e) this.sectionIndex.push(r);\n    }\n\n    addImageSection(t) {\n      const e = t.image ? t.image.name : \"\";\n      if (0 === e.length) return void x(\"Can't add FormattedSection with an empty image.\");\n      const r = this.getNextImageSectionCharCode();\n      r ? (this.text += String.fromCharCode(r), this.sections.push(Sl.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : x(\"Reached maximum number of images 6401\");\n    }\n\n    getNextImageSectionCharCode() {\n      return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);\n    }\n\n  }\n\n  function Il(t, e, r, n, i, s, o, a, l, u, c, h, p, f, d, y) {\n    const m = Al.fromFeature(t, i);\n    let g;\n    h === kl.vertical && m.verticalizePunctuation();\n    const {\n      processBidirectionalText: x,\n      processStyledBidirectionalText: v\n    } = si;\n\n    if (x && 1 === m.sections.length) {\n      g = [];\n      const t = x(m.toString(), Tl(m, u, s, e, n, f, d));\n\n      for (const e of t) {\n        const t = new Al();\n        t.text = e, t.sections = m.sections;\n\n        for (let r = 0; r < e.length; r++) t.sectionIndex.push(0);\n\n        g.push(t);\n      }\n    } else if (v) {\n      g = [];\n      const t = v(m.text, m.sectionIndex, Tl(m, u, s, e, n, f, d));\n\n      for (const e of t) {\n        const t = new Al();\n        t.text = e[0], t.sectionIndex = e[1], t.sections = m.sections, g.push(t);\n      }\n    } else g = function (t, e) {\n      const r = [],\n            n = t.text;\n      let i = 0;\n\n      for (const n of e) r.push(t.substring(i, n)), i = n;\n\n      return i < n.length && r.push(t.substring(i, n.length)), r;\n    }(m, Tl(m, u, s, e, n, f, d));\n\n    const b = [],\n          w = {\n      positionedLines: b,\n      text: m.toString(),\n      top: c[1],\n      bottom: c[1],\n      left: c[0],\n      right: c[0],\n      writingMode: h,\n      iconsInText: !1,\n      verticalizable: !1\n    };\n    return function (t, e, r, n, i, s, o, a, l, u, c, h) {\n      let p = 0,\n          f = -17,\n          d = 0,\n          y = 0;\n      const m = \"right\" === a ? 1 : \"left\" === a ? 0 : .5;\n      let g = 0;\n\n      for (const o of i) {\n        o.trim();\n        const i = o.getMaxScale(),\n              a = 24 * (i - 1),\n              v = {\n          positionedGlyphs: [],\n          lineOffset: 0\n        };\n        t.positionedLines[g] = v;\n        const b = v.positionedGlyphs;\n        let w = 0;\n\n        if (!o.length()) {\n          f += s, ++g;\n          continue;\n        }\n\n        for (let s = 0; s < o.length(); s++) {\n          const d = o.getSection(s),\n                y = o.getSectionIndex(s),\n                m = o.getCharCode(s);\n          let g = 0,\n              v = null,\n              _ = null,\n              k = null,\n              S = 24;\n          const A = !(l === kl.horizontal || !c && !In(m) || c && (zl[m] || (x = m, Kr(x) || Hr(x) || Wr(x) || gn(x) || wn(x))));\n\n          if (d.imageName) {\n            const e = n[d.imageName];\n            if (!e) continue;\n            k = d.imageName, t.iconsInText = t.iconsInText || !0, _ = e.paddedRect;\n            const r = e.displaySize;\n            d.scale = 24 * d.scale / h, v = {\n              width: r[0],\n              height: r[1],\n              left: 1,\n              top: -3,\n              advance: A ? r[1] : r[0],\n              localGlyph: !1\n            }, g = a + (24 - r[1] * d.scale), S = v.advance;\n            const s = A ? r[0] * d.scale - 24 * i : r[1] * d.scale - 24 * i;\n            s > 0 && s > w && (w = s);\n          } else {\n            const t = r[d.fontStack],\n                  n = t && t[m];\n            if (n && n.rect) _ = n.rect, v = n.metrics;else {\n              const t = e[d.fontStack],\n                    r = t && t[m];\n              if (!r) continue;\n              v = r.metrics;\n            }\n            g = 24 * (i - d.scale);\n          }\n\n          A ? (t.verticalizable = !0, b.push({\n            glyph: m,\n            imageName: k,\n            x: p,\n            y: f + g,\n            vertical: A,\n            scale: d.scale,\n            localGlyph: v.localGlyph,\n            fontStack: d.fontStack,\n            sectionIndex: y,\n            metrics: v,\n            rect: _\n          }), p += S * d.scale + u) : (b.push({\n            glyph: m,\n            imageName: k,\n            x: p,\n            y: f + g,\n            vertical: A,\n            scale: d.scale,\n            localGlyph: v.localGlyph,\n            fontStack: d.fontStack,\n            sectionIndex: y,\n            metrics: v,\n            rect: _\n          }), p += v.advance * d.scale + u);\n        }\n\n        0 !== b.length && (d = Math.max(p - u, d), Dl(b, 0, b.length - 1, m, w)), p = 0;\n\n        const _ = s * i + w;\n\n        v.lineOffset = Math.max(w, a), f += _, y = Math.max(_, y), ++g;\n      }\n\n      var x;\n      const v = f - -17,\n            {\n        horizontalAlign: b,\n        verticalAlign: w\n      } = El(o);\n      (function (t, e, r, n, i, s, o, a, l) {\n        const u = (e - r) * i;\n        let c = 0;\n        c = s !== o ? -a * n - -17 : (-n * l + .5) * o;\n\n        for (const e of t) for (const t of e.positionedGlyphs) t.x += u, t.y += c;\n      })(t.positionedLines, m, b, w, d, y, s, v, i.length), t.top += -w * v, t.bottom = t.top + v, t.left += -b * d, t.right = t.left + d;\n    }(w, e, r, n, g, o, a, l, h, u, p, y), !function (t) {\n      for (const e of t) if (0 !== e.positionedGlyphs.length) return !1;\n\n      return !0;\n    }(b) && w;\n  }\n\n  const zl = {\n    9: !0,\n    10: !0,\n    11: !0,\n    12: !0,\n    13: !0,\n    32: !0\n  },\n        Ml = {\n    10: !0,\n    32: !0,\n    38: !0,\n    40: !0,\n    41: !0,\n    43: !0,\n    45: !0,\n    47: !0,\n    173: !0,\n    183: !0,\n    8203: !0,\n    8208: !0,\n    8211: !0,\n    8231: !0\n  };\n\n  function Bl(t, e, r, n, i, s) {\n    if (e.imageName) {\n      const t = n[e.imageName];\n      return t ? t.displaySize[0] * e.scale * 24 / s + i : 0;\n    }\n\n    {\n      const n = r[e.fontStack],\n            s = n && n[t];\n      return s ? s.metrics.advance * e.scale + i : 0;\n    }\n  }\n\n  function Pl(t, e, r, n) {\n    const i = Math.pow(t - e, 2);\n    return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r;\n  }\n\n  function Cl(t, e, r) {\n    let n = 0;\n    return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;\n  }\n\n  function Vl(t, e, r, n, i, s) {\n    let o = null,\n        a = Pl(e, r, i, s);\n\n    for (const t of n) {\n      const n = Pl(e - t.x, r, i, s) + t.badness;\n      n <= a && (o = t, a = n);\n    }\n\n    return {\n      index: t,\n      x: e,\n      priorBreak: o,\n      badness: a\n    };\n  }\n\n  function Tl(t, e, r, n, i, s, o) {\n    if (\"point\" !== s) return [];\n    if (!t) return [];\n\n    const a = [],\n          l = function (t, e, r, n, i, s) {\n      let o = 0;\n\n      for (let r = 0; r < t.length(); r++) {\n        const a = t.getSection(r);\n        o += Bl(t.getCharCode(r), a, n, i, e, s);\n      }\n\n      return o / Math.max(1, Math.ceil(o / r));\n    }(t, e, r, n, i, o),\n          u = t.text.indexOf(\"\") >= 0;\n\n    let c = 0;\n\n    for (let r = 0; r < t.length(); r++) {\n      const s = t.getSection(r),\n            p = t.getCharCode(r);\n\n      if (zl[p] || (c += Bl(p, s, n, i, e, o)), r < t.length() - 1) {\n        const e = !((h = p) < 11904 || !(an(h) || on(h) || vn(h) || mn(h) || hn(h) || Qr(h) || ln(h) || rn(h) || pn(h) || fn(h) || cn(h) || _n(h) || nn(h) || en(h) || tn(h) || un(h) || sn(h) || xn(h) || yn(h) || dn(h)));\n        (Ml[p] || e || s.imageName) && a.push(Vl(r + 1, c, l, a, Cl(p, t.getCharCode(r + 1), e && u), !1));\n      }\n    }\n\n    var h;\n    return function t(e) {\n      return e ? t(e.priorBreak).concat(e.index) : [];\n    }(Vl(t.length(), c, l, a, 0, !0));\n  }\n\n  function El(t) {\n    let e = .5,\n        r = .5;\n\n    switch (t) {\n      case \"right\":\n      case \"top-right\":\n      case \"bottom-right\":\n        e = 1;\n        break;\n\n      case \"left\":\n      case \"top-left\":\n      case \"bottom-left\":\n        e = 0;\n    }\n\n    switch (t) {\n      case \"bottom\":\n      case \"bottom-right\":\n      case \"bottom-left\":\n        r = 1;\n        break;\n\n      case \"top\":\n      case \"top-right\":\n      case \"top-left\":\n        r = 0;\n    }\n\n    return {\n      horizontalAlign: e,\n      verticalAlign: r\n    };\n  }\n\n  function Dl(t, e, r, n, i) {\n    if (!n && !i) return;\n    const s = t[r],\n          o = (t[r].x + s.metrics.advance * s.scale) * n;\n\n    for (let n = e; n <= r; n++) t[n].x -= o, t[n].y += i;\n  }\n\n  function Fl(t, e, r) {\n    const {\n      horizontalAlign: n,\n      verticalAlign: i\n    } = El(r),\n          s = e[0] - t.displaySize[0] * n,\n          o = e[1] - t.displaySize[1] * i;\n    return {\n      image: t,\n      top: o,\n      bottom: o + t.displaySize[1],\n      left: s,\n      right: s + t.displaySize[0]\n    };\n  }\n\n  function Ll(t, e, r, n, i, s) {\n    const o = t.image;\n    let a;\n\n    if (o.content) {\n      const t = o.content,\n            e = o.pixelRatio || 1;\n      a = [t[0] / e, t[1] / e, o.displaySize[0] - t[2] / e, o.displaySize[1] - t[3] / e];\n    }\n\n    const l = e.left * s,\n          u = e.right * s;\n    let c, h, p, f;\n    \"width\" === r || \"both\" === r ? (f = i[0] + l - n[3], h = i[0] + u + n[1]) : (f = i[0] + (l + u - o.displaySize[0]) / 2, h = f + o.displaySize[0]);\n    const d = e.top * s,\n          y = e.bottom * s;\n    return \"height\" === r || \"both\" === r ? (c = i[1] + d - n[0], p = i[1] + y + n[2]) : (c = i[1] + (d + y - o.displaySize[1]) / 2, p = c + o.displaySize[1]), {\n      image: o,\n      top: c,\n      right: h,\n      bottom: p,\n      left: f,\n      collisionPadding: a\n    };\n  }\n\n  class Ol extends r {\n    constructor(t, e, r, n) {\n      super(t, e), this.angle = r, void 0 !== n && (this.segment = n);\n    }\n\n    clone() {\n      return new Ol(this.x, this.y, this.angle, this.segment);\n    }\n\n  }\n\n  function $l(t, e, r, n, i) {\n    if (void 0 === e.segment) return !0;\n    let s = e,\n        o = e.segment + 1,\n        a = 0;\n\n    for (; a > -r / 2;) {\n      if (o--, o < 0) return !1;\n      a -= t[o].dist(s), s = t[o];\n    }\n\n    a += t[o].dist(t[o + 1]), o++;\n    const l = [];\n    let u = 0;\n\n    for (; a < r / 2;) {\n      const e = t[o],\n            r = t[o + 1];\n      if (!r) return !1;\n      let s = t[o - 1].angleTo(e) - e.angleTo(r);\n\n      for (s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({\n        distance: a,\n        angleDelta: s\n      }), u += s; a - l[0].distance > n;) u -= l.shift().angleDelta;\n\n      if (u > i) return !1;\n      o++, a += e.dist(r);\n    }\n\n    return !0;\n  }\n\n  function Rl(t) {\n    let e = 0;\n\n    for (let r = 0; r < t.length - 1; r++) e += t[r].dist(t[r + 1]);\n\n    return e;\n  }\n\n  function ql(t, e, r) {\n    return t ? .6 * e * r : 0;\n  }\n\n  function Ul(t, e) {\n    return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);\n  }\n\n  function Nl(t, e, r, n, i, s) {\n    const o = ql(r, i, s),\n          a = Ul(r, n) * s;\n    let l = 0;\n    const u = Rl(t) / 2;\n\n    for (let r = 0; r < t.length - 1; r++) {\n      const n = t[r],\n            i = t[r + 1],\n            s = n.dist(i);\n\n      if (l + s > u) {\n        const c = (u - l) / s,\n              h = $t(n.x, i.x, c),\n              p = $t(n.y, i.y, c),\n              f = new Ol(h, p, i.angleTo(n), r);\n        return f._round(), !o || $l(t, f, a, o, e) ? f : void 0;\n      }\n\n      l += s;\n    }\n  }\n\n  function jl(t, e, r, n, i, s, o, a, l) {\n    const u = ql(n, s, o),\n          c = Ul(n, i),\n          h = c * o,\n          p = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;\n    return e - h < e / 4 && (e = h + e / 4), function t(e, r, n, i, s, o, a, l, u) {\n      const c = o / 2,\n            h = Rl(e);\n      let p = 0,\n          f = r - n,\n          d = [];\n\n      for (let t = 0; t < e.length - 1; t++) {\n        const r = e[t],\n              a = e[t + 1],\n              l = r.dist(a),\n              y = a.angleTo(r);\n\n        for (; f + n < p + l;) {\n          f += n;\n          const m = (f - p) / l,\n                g = $t(r.x, a.x, m),\n                x = $t(r.y, a.y, m);\n\n          if (g >= 0 && g < u && x >= 0 && x < u && f - c >= 0 && f + c <= h) {\n            const r = new Ol(g, x, y, t);\n            r._round(), i && !$l(e, r, o, i, s) || d.push(r);\n          }\n        }\n\n        p += l;\n      }\n\n      return l || d.length || a || (d = t(e, p / 2, n, i, s, o, a, !0, u)), d;\n    }(t, p ? e / 2 * a % e : (c / 2 + 2 * s) * o * a % e, e, u, r, h, p, !1, l);\n  }\n\n  Je(\"Anchor\", Ol);\n  var Zl = Jl,\n      Gl = Jl,\n      Xl = 1e20;\n\n  function Jl(t, e, r, n, i, s) {\n    this.fontSize = t || 24, this.buffer = void 0 === e ? 3 : e, this.cutoff = n || .25, this.fontFamily = i || \"sans-serif\", this.fontWeight = s || \"normal\", this.radius = r || 8;\n    var o = this.size = this.fontSize + 2 * this.buffer,\n        a = o + 2 * this.buffer;\n    this.canvas = document.createElement(\"canvas\"), this.canvas.width = this.canvas.height = o, this.ctx = this.canvas.getContext(\"2d\"), this.ctx.font = this.fontWeight + \" \" + this.fontSize + \"px \" + this.fontFamily, this.ctx.textBaseline = \"middle\", this.ctx.textAlign = \"left\", this.ctx.fillStyle = \"black\", this.gridOuter = new Float64Array(a * a), this.gridInner = new Float64Array(a * a), this.f = new Float64Array(a), this.z = new Float64Array(a + 1), this.v = new Uint16Array(a), this.middle = Math.round(o / 2 * (navigator.userAgent.indexOf(\"Gecko/\") >= 0 ? 1.2 : 1));\n  }\n\n  function Yl(t, e, r, n, i, s) {\n    for (var o = 0; o < e; o++) Kl(t, o, e, r, n, i, s);\n\n    for (var a = 0; a < r; a++) Kl(t, a * e, 1, e, n, i, s);\n  }\n\n  function Kl(t, e, r, n, i, s, o) {\n    var a, l, u, c;\n\n    for (s[0] = 0, o[0] = -Xl, o[1] = Xl, a = 0; a < n; a++) i[a] = t[e + a * r];\n\n    for (a = 1, l = 0, u = 0; a < n; a++) {\n      do {\n        u = (i[a] - i[c = s[l]] + a * a - c * c) / (a - c) / 2;\n      } while (u <= o[l] && --l > -1);\n\n      s[++l] = a, o[l] = u, o[l + 1] = Xl;\n    }\n\n    for (a = 0, l = 0; a < n; a++) {\n      for (; o[l + 1] < a;) l++;\n\n      t[e + a * r] = i[c = s[l]] + (a - c) * (a - c);\n    }\n  }\n\n  function Hl(t, e, n, i) {\n    const s = [],\n          o = t.image,\n          a = o.pixelRatio,\n          l = o.paddedRect.w - 2,\n          u = o.paddedRect.h - 2,\n          c = t.right - t.left,\n          h = t.bottom - t.top,\n          p = o.stretchX || [[0, l]],\n          f = o.stretchY || [[0, u]],\n          d = (t, e) => t + e[1] - e[0],\n          y = p.reduce(d, 0),\n          m = f.reduce(d, 0),\n          g = l - y,\n          x = u - m;\n\n    let v = 0,\n        b = y,\n        w = 0,\n        _ = m,\n        k = 0,\n        S = g,\n        A = 0,\n        I = x;\n\n    if (o.content && i) {\n      const t = o.content;\n      v = Wl(p, 0, t[0]), w = Wl(f, 0, t[1]), b = Wl(p, t[0], t[2]), _ = Wl(f, t[1], t[3]), k = t[0] - v, A = t[1] - w, S = t[2] - t[0] - b, I = t[3] - t[1] - _;\n    }\n\n    const z = (i, s, l, u) => {\n      const p = tu(i.stretch - v, b, c, t.left),\n            f = eu(i.fixed - k, S, i.stretch, y),\n            d = tu(s.stretch - w, _, h, t.top),\n            g = eu(s.fixed - A, I, s.stretch, m),\n            x = tu(l.stretch - v, b, c, t.left),\n            z = eu(l.fixed - k, S, l.stretch, y),\n            M = tu(u.stretch - w, _, h, t.top),\n            B = eu(u.fixed - A, I, u.stretch, m),\n            P = new r(p, d),\n            C = new r(x, d),\n            V = new r(x, M),\n            T = new r(p, M),\n            E = new r(f / a, g / a),\n            D = new r(z / a, B / a),\n            F = e * Math.PI / 180;\n\n      if (F) {\n        const t = Math.sin(F),\n              e = Math.cos(F),\n              r = [e, -t, t, e];\n        P._matMult(r), C._matMult(r), T._matMult(r), V._matMult(r);\n      }\n\n      const L = i.stretch + i.fixed,\n            O = s.stretch + s.fixed;\n      return {\n        tl: P,\n        tr: C,\n        bl: T,\n        br: V,\n        tex: {\n          x: o.paddedRect.x + 1 + L,\n          y: o.paddedRect.y + 1 + O,\n          w: l.stretch + l.fixed - L,\n          h: u.stretch + u.fixed - O\n        },\n        writingMode: void 0,\n        glyphOffset: [0, 0],\n        sectionIndex: 0,\n        pixelOffsetTL: E,\n        pixelOffsetBR: D,\n        minFontScaleX: S / a / c,\n        minFontScaleY: I / a / h,\n        isSDF: n\n      };\n    };\n\n    if (i && (o.stretchX || o.stretchY)) {\n      const t = Ql(p, g, y),\n            e = Ql(f, x, m);\n\n      for (let r = 0; r < t.length - 1; r++) {\n        const n = t[r],\n              i = t[r + 1];\n\n        for (let t = 0; t < e.length - 1; t++) s.push(z(n, e[t], i, e[t + 1]));\n      }\n    } else s.push(z({\n      fixed: 0,\n      stretch: -1\n    }, {\n      fixed: 0,\n      stretch: -1\n    }, {\n      fixed: 0,\n      stretch: l + 1\n    }, {\n      fixed: 0,\n      stretch: u + 1\n    }));\n\n    return s;\n  }\n\n  function Wl(t, e, r) {\n    let n = 0;\n\n    for (const i of t) n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));\n\n    return n;\n  }\n\n  function Ql(t, e, r) {\n    const n = [{\n      fixed: -1,\n      stretch: 0\n    }];\n\n    for (const [e, r] of t) {\n      const t = n[n.length - 1];\n      n.push({\n        fixed: e - t.stretch,\n        stretch: t.stretch\n      }), n.push({\n        fixed: e - t.stretch,\n        stretch: t.stretch + (r - e)\n      });\n    }\n\n    return n.push({\n      fixed: e + 1,\n      stretch: r\n    }), n;\n  }\n\n  function tu(t, e, r, n) {\n    return t / e * r + n;\n  }\n\n  function eu(t, e, r, n) {\n    return t - e * r / n;\n  }\n\n  Jl.prototype._draw = function (t, e) {\n    var r,\n        n,\n        i,\n        s,\n        o,\n        a,\n        l,\n        u,\n        c = this.ctx.measureText(t),\n        h = c.width,\n        p = 2 * this.buffer;\n    e && void 0 !== c.actualBoundingBoxLeft ? (o = Math.floor(c.actualBoundingBoxAscent) - this.middle, a = Math.max(0, this.middle - Math.ceil(c.actualBoundingBoxAscent)), l = this.buffer, r = (n = Math.min(this.size, Math.ceil(c.actualBoundingBoxRight - c.actualBoundingBoxLeft))) + p, i = (s = Math.min(this.size - a, Math.ceil(c.actualBoundingBoxAscent + c.actualBoundingBoxDescent))) + p) : (r = n = this.size, i = s = this.size, o = 0, a = l = 0), n && s && (this.ctx.clearRect(l, a, n, s), this.ctx.fillText(t, this.buffer, this.middle), u = this.ctx.getImageData(l, a, n, s));\n    var f = new Uint8ClampedArray(r * i);\n    return function (t, e, r, n, i, s, o) {\n      s.fill(Xl, 0, e * r), o.fill(0, 0, e * r);\n\n      for (var a = (e - n) / 2, l = 0; l < i; l++) for (var u = 0; u < n; u++) {\n        var c = (l + a) * e + u + a,\n            h = t.data[4 * (l * n + u) + 3] / 255;\n        if (1 === h) s[c] = 0, o[c] = Xl;else if (0 === h) s[c] = Xl, o[c] = 0;else {\n          var p = Math.max(0, .5 - h),\n              f = Math.max(0, h - .5);\n          s[c] = p * p, o[c] = f * f;\n        }\n      }\n    }(u, r, i, n, s, this.gridOuter, this.gridInner), Yl(this.gridOuter, r, i, this.f, this.v, this.z), Yl(this.gridInner, r, i, this.f, this.v, this.z), function (t, e, r, n, i, s, o) {\n      for (var a = 0; a < e * r; a++) {\n        var l = Math.sqrt(n[a]) - Math.sqrt(i[a]);\n        t[a] = Math.round(255 - 255 * (l / s + o));\n      }\n    }(f, r, i, this.gridOuter, this.gridInner, this.radius, this.cutoff), {\n      data: f,\n      metrics: {\n        width: n,\n        height: s,\n        sdfWidth: r,\n        sdfHeight: i,\n        top: o,\n        left: 0,\n        advance: h,\n        fontAscent: c.fontBoundingBoxAscent\n      }\n    };\n  }, Jl.prototype.draw = function (t) {\n    return this._draw(t, !1).data;\n  }, Jl.prototype.drawWithMetrics = function (t) {\n    return this._draw(t, !0);\n  }, Zl.default = Gl;\n\n  class ru {\n    constructor(t = [], e = nu) {\n      if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (let t = (this.length >> 1) - 1; t >= 0; t--) this._down(t);\n    }\n\n    push(t) {\n      this.data.push(t), this.length++, this._up(this.length - 1);\n    }\n\n    pop() {\n      if (0 === this.length) return;\n      const t = this.data[0],\n            e = this.data.pop();\n      return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t;\n    }\n\n    peek() {\n      return this.data[0];\n    }\n\n    _up(t) {\n      const {\n        data: e,\n        compare: r\n      } = this,\n            n = e[t];\n\n      for (; t > 0;) {\n        const i = t - 1 >> 1,\n              s = e[i];\n        if (r(n, s) >= 0) break;\n        e[t] = s, t = i;\n      }\n\n      e[t] = n;\n    }\n\n    _down(t) {\n      const {\n        data: e,\n        compare: r\n      } = this,\n            n = this.length >> 1,\n            i = e[t];\n\n      for (; t < n;) {\n        let n = 1 + (t << 1),\n            s = e[n];\n        const o = n + 1;\n        if (o < this.length && r(e[o], s) < 0 && (n = o, s = e[o]), r(s, i) >= 0) break;\n        e[t] = s, t = n;\n      }\n\n      e[t] = i;\n    }\n\n  }\n\n  function nu(t, e) {\n    return t < e ? -1 : t > e ? 1 : 0;\n  }\n\n  function iu(t, e = 1, n = !1) {\n    let i = 1 / 0,\n        s = 1 / 0,\n        o = -1 / 0,\n        a = -1 / 0;\n    const l = t[0];\n\n    for (let t = 0; t < l.length; t++) {\n      const e = l[t];\n      (!t || e.x < i) && (i = e.x), (!t || e.y < s) && (s = e.y), (!t || e.x > o) && (o = e.x), (!t || e.y > a) && (a = e.y);\n    }\n\n    const u = Math.min(o - i, a - s);\n    let c = u / 2;\n    const h = new ru([], su);\n    if (0 === u) return new r(i, s);\n\n    for (let e = i; e < o; e += u) for (let r = s; r < a; r += u) h.push(new ou(e + c, r + c, c, t));\n\n    let p = function (t) {\n      let e = 0,\n          r = 0,\n          n = 0;\n      const i = t[0];\n\n      for (let t = 0, s = i.length, o = s - 1; t < s; o = t++) {\n        const s = i[t],\n              a = i[o],\n              l = s.x * a.y - a.x * s.y;\n        r += (s.x + a.x) * l, n += (s.y + a.y) * l, e += 3 * l;\n      }\n\n      return new ou(r / e, n / e, 0, t);\n    }(t),\n        f = h.length;\n\n    for (; h.length;) {\n      const r = h.pop();\n      (r.d > p.d || !p.d) && (p = r, n && console.log(\"found best %d after %d probes\", Math.round(1e4 * r.d) / 1e4, f)), r.max - p.d <= e || (c = r.h / 2, h.push(new ou(r.p.x - c, r.p.y - c, c, t)), h.push(new ou(r.p.x + c, r.p.y - c, c, t)), h.push(new ou(r.p.x - c, r.p.y + c, c, t)), h.push(new ou(r.p.x + c, r.p.y + c, c, t)), f += 4);\n    }\n\n    return n && (console.log(`num probes: ${f}`), console.log(`best distance: ${p.d}`)), p.p;\n  }\n\n  function su(t, e) {\n    return e.max - t.max;\n  }\n\n  function ou(t, e, n, i) {\n    this.p = new r(t, e), this.h = n, this.d = function (t, e) {\n      let r = !1,\n          n = 1 / 0;\n\n      for (let i = 0; i < e.length; i++) {\n        const s = e[i];\n\n        for (let e = 0, i = s.length, o = i - 1; e < i; o = e++) {\n          const i = s[e],\n                a = s[o];\n          i.y > t.y != a.y > t.y && t.x < (a.x - i.x) * (t.y - i.y) / (a.y - i.y) + i.x && (r = !r), n = Math.min(n, Zs(t, i, a));\n        }\n      }\n\n      return (r ? 1 : -1) * Math.sqrt(n);\n    }(this.p, i), this.max = this.d + this.h * Math.SQRT2;\n  }\n\n  const au = Number.POSITIVE_INFINITY;\n\n  function lu(t, e, r, n, i, s, o, a) {\n    t.createArrays(), t.tilePixelRatio = 8192 / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1;\n    const l = t.layers[0].layout,\n          u = t.layers[0]._unevaluatedLayout._values,\n          c = {};\n\n    if (\"composite\" === t.textSizeData.kind) {\n      const {\n        minZoom: e,\n        maxZoom: r\n      } = t.textSizeData;\n      c.compositeTextSizes = [u[\"text-size\"].possiblyEvaluate(new oi(e), o), u[\"text-size\"].possiblyEvaluate(new oi(r), o)];\n    }\n\n    if (\"composite\" === t.iconSizeData.kind) {\n      const {\n        minZoom: e,\n        maxZoom: r\n      } = t.iconSizeData;\n      c.compositeIconSizes = [u[\"icon-size\"].possiblyEvaluate(new oi(e), o), u[\"icon-size\"].possiblyEvaluate(new oi(r), o)];\n    }\n\n    c.layoutTextSize = u[\"text-size\"].possiblyEvaluate(new oi(a + 1), o), c.layoutIconSize = u[\"icon-size\"].possiblyEvaluate(new oi(a + 1), o), c.textMaxSize = u[\"text-size\"].possiblyEvaluate(new oi(18), o);\n    const h = 24 * l.get(\"text-line-height\"),\n          p = \"map\" === l.get(\"text-rotation-alignment\") && \"point\" !== l.get(\"symbol-placement\"),\n          f = l.get(\"text-keep-upright\"),\n          d = l.get(\"text-size\");\n\n    for (const s of t.features) {\n      const a = l.get(\"text-font\").evaluate(s, {}, o).join(\",\"),\n            u = d.evaluate(s, {}, o),\n            g = c.layoutTextSize.evaluate(s, {}, o),\n            v = (c.layoutIconSize.evaluate(s, {}, o), {\n        horizontal: {},\n        vertical: void 0\n      }),\n            b = s.text;\n      let w,\n          _ = [0, 0];\n\n      if (b) {\n        const n = b.toString(),\n              c = 24 * l.get(\"text-letter-spacing\").evaluate(s, {}, o),\n              d = Sn(n) ? c : 0,\n              x = l.get(\"text-anchor\").evaluate(s, {}, o),\n              w = l.get(\"text-variable-anchor\");\n\n        if (!w) {\n          const t = l.get(\"text-radial-offset\").evaluate(s, {}, o);\n          t ? (y = x, _ = (m = [24 * t, au])[1] !== au ? function (t, e, r) {\n            let n = 0,\n                i = 0;\n\n            switch (e = Math.abs(e), r = Math.abs(r), t) {\n              case \"top-right\":\n              case \"top-left\":\n              case \"top\":\n                i = r - 7;\n                break;\n\n              case \"bottom-right\":\n              case \"bottom-left\":\n              case \"bottom\":\n                i = 7 - r;\n            }\n\n            switch (t) {\n              case \"top-right\":\n              case \"bottom-right\":\n              case \"right\":\n                n = -e;\n                break;\n\n              case \"top-left\":\n              case \"bottom-left\":\n              case \"left\":\n                n = e;\n            }\n\n            return [n, i];\n          }(y, m[0], m[1]) : function (t, e) {\n            let r = 0,\n                n = 0;\n            e < 0 && (e = 0);\n            const i = e / Math.sqrt(2);\n\n            switch (t) {\n              case \"top-right\":\n              case \"top-left\":\n                n = i - 7;\n                break;\n\n              case \"bottom-right\":\n              case \"bottom-left\":\n                n = 7 - i;\n                break;\n\n              case \"bottom\":\n                n = 7 - e;\n                break;\n\n              case \"top\":\n                n = e - 7;\n            }\n\n            switch (t) {\n              case \"top-right\":\n              case \"bottom-right\":\n                r = -i;\n                break;\n\n              case \"top-left\":\n              case \"bottom-left\":\n                r = i;\n                break;\n\n              case \"left\":\n                r = e;\n                break;\n\n              case \"right\":\n                r = -e;\n            }\n\n            return [r, n];\n          }(y, m[0])) : _ = l.get(\"text-offset\").evaluate(s, {}, o).map(t => 24 * t);\n        }\n\n        let k = p ? \"center\" : l.get(\"text-justify\").evaluate(s, {}, o);\n\n        const S = l.get(\"symbol-placement\"),\n              A = \"point\" === S ? 24 * l.get(\"text-max-width\").evaluate(s, {}, o) : 0,\n              I = () => {\n          t.allowVerticalPlacement && kn(n) && (v.vertical = Il(b, e, r, i, a, A, h, x, \"left\", d, _, kl.vertical, !0, S, g, u));\n        };\n\n        if (!p && w) {\n          const t = \"auto\" === k ? w.map(t => uu(t)) : [k];\n          let n = !1;\n\n          for (let s = 0; s < t.length; s++) {\n            const o = t[s];\n            if (!v.horizontal[o]) if (n) v.horizontal[o] = v.horizontal[0];else {\n              const t = Il(b, e, r, i, a, A, h, \"center\", o, d, _, kl.horizontal, !1, S, g, u);\n              t && (v.horizontal[o] = t, n = 1 === t.positionedLines.length);\n            }\n          }\n\n          I();\n        } else {\n          \"auto\" === k && (k = uu(x));\n          const t = Il(b, e, r, i, a, A, h, x, k, d, _, kl.horizontal, !1, S, g, u);\n          t && (v.horizontal[k] = t), I(), kn(n) && p && f && (v.vertical = Il(b, e, r, i, a, A, h, x, k, d, _, kl.vertical, !1, S, g, u));\n        }\n      }\n\n      let k = !1;\n\n      if (s.icon && s.icon.name) {\n        const e = n[s.icon.name];\n        e && (w = Fl(i[s.icon.name], l.get(\"icon-offset\").evaluate(s, {}, o), l.get(\"icon-anchor\").evaluate(s, {}, o)), k = e.sdf, void 0 === t.sdfIcons ? t.sdfIcons = e.sdf : t.sdfIcons !== e.sdf && x(\"Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer\"), (e.pixelRatio !== t.pixelRatio || 0 !== l.get(\"icon-rotate\").constantOr(1)) && (t.iconsNeedLinear = !0));\n      }\n\n      const S = pu(v.horizontal) || v.vertical;\n      t.iconsInText = !!S && S.iconsInText, (S || w) && cu(t, s, v, w, n, c, g, 0, _, k, o);\n    }\n\n    var y, m;\n    s && t.generateCollisionDebugBuffers(a, t.collisionBoxArray);\n  }\n\n  function uu(t) {\n    switch (t) {\n      case \"right\":\n      case \"top-right\":\n      case \"bottom-right\":\n        return \"right\";\n\n      case \"left\":\n      case \"top-left\":\n      case \"bottom-left\":\n        return \"left\";\n    }\n\n    return \"center\";\n  }\n\n  function cu(t, e, n, i, s, o, l, u, c, h, p) {\n    let f = o.textMaxSize.evaluate(e, {}, p);\n    void 0 === f && (f = l);\n\n    const d = t.layers[0].layout,\n          y = d.get(\"icon-offset\").evaluate(e, {}, p),\n          m = pu(n.horizontal),\n          g = l / 24,\n          v = t.tilePixelRatio * g,\n          b = t.tilePixelRatio * f / 24,\n          w = t.tilePixelRatio * d.get(\"symbol-spacing\"),\n          _ = d.get(\"text-padding\") * t.tilePixelRatio,\n          k = d.get(\"icon-padding\") * t.tilePixelRatio,\n          S = a(d.get(\"text-max-angle\")),\n          A = \"map\" === d.get(\"text-rotation-alignment\") && \"point\" !== d.get(\"symbol-placement\"),\n          I = \"map\" === d.get(\"icon-rotation-alignment\") && \"point\" !== d.get(\"symbol-placement\"),\n          z = d.get(\"symbol-placement\"),\n          M = w / 2,\n          B = d.get(\"icon-text-fit\");\n\n    let P;\n    i && \"none\" !== B && (t.allowVerticalPlacement && n.vertical && (P = Ll(i, n.vertical, B, d.get(\"icon-text-fit-padding\"), y, g)), m && (i = Ll(i, m, B, d.get(\"icon-text-fit-padding\"), y, g)));\n\n    const C = (r, a) => {\n      a.x < 0 || a.x >= 8192 || a.y < 0 || a.y >= 8192 || function (t, e, r, n, i, s, o, a, l, u, c, h, p, f, d, y, m, g, v, b, w, _, k, S, A) {\n        const I = t.addToLineVertexArray(e, r);\n        let z,\n            M,\n            B,\n            P,\n            C,\n            V,\n            T,\n            E = 0,\n            D = 0,\n            F = 0,\n            L = 0,\n            O = -1,\n            $ = -1;\n        const R = {};\n        let q = us(\"\"),\n            U = 0,\n            N = 0;\n\n        if (void 0 === a._unevaluatedLayout.getValue(\"text-radial-offset\") ? [U, N] = a.layout.get(\"text-offset\").evaluate(w, {}, S).map(t => 24 * t) : (U = 24 * a.layout.get(\"text-radial-offset\").evaluate(w, {}, S), N = au), t.allowVerticalPlacement && n.vertical) {\n          const t = n.vertical;\n          if (d) V = du(t), o && (T = du(o));else {\n            const r = a.layout.get(\"text-rotate\").evaluate(w, {}, S) + 90;\n            B = fu(l, e, u, c, h, t, 0, f, r), o && (P = fu(l, e, u, c, h, o, 0, g, r));\n          }\n        }\n\n        if (i) {\n          const r = a.layout.get(\"icon-rotate\").evaluate(w, {}, S),\n                n = \"none\" !== a.layout.get(\"icon-text-fit\"),\n                s = Hl(i, r, k, n),\n                p = o ? Hl(o, r, k, n) : void 0;\n          M = fu(l, e, u, c, h, i, 0, g, r), E = 4 * s.length;\n          const f = t.iconSizeData;\n          let d = null;\n          \"source\" === f.kind ? (d = [128 * a.layout.get(\"icon-size\").evaluate(w, {}, S)], d[0] > 32640 && x(`${t.layerIds[0]}: Value for \"icon-size\" is >= 255. Reduce your \"icon-size\".`)) : \"composite\" === f.kind && (d = [128 * _.compositeIconSizes[0].evaluate(w, {}, S), 128 * _.compositeIconSizes[1].evaluate(w, {}, S)], (d[0] > 32640 || d[1] > 32640) && x(`${t.layerIds[0]}: Value for \"icon-size\" is >= 255. Reduce your \"icon-size\".`)), t.addSymbols(t.icon, s, d, b, v, w, !1, e, I.lineStartIndex, I.lineLength, -1, S), O = t.icon.placedSymbolArray.length - 1, p && (D = 4 * p.length, t.addSymbols(t.icon, p, d, b, v, w, kl.vertical, e, I.lineStartIndex, I.lineLength, -1, S), $ = t.icon.placedSymbolArray.length - 1);\n        }\n\n        for (const r in n.horizontal) {\n          const i = n.horizontal[r];\n          z || (q = us(i.text), d ? C = du(i) : z = fu(l, e, u, c, h, i, 0, f, a.layout.get(\"text-rotate\").evaluate(w, {}, S)));\n          const o = 1 === i.positionedLines.length;\n          if (F += hu(t, e, i, s, a, d, w, y, I, n.vertical ? kl.horizontal : kl.horizontalOnly, o ? Object.keys(n.horizontal) : [r], R, O, _, S), o) break;\n        }\n\n        n.vertical && (L += hu(t, e, n.vertical, s, a, d, w, y, I, kl.vertical, [\"vertical\"], R, $, _, S));\n        let j = -1;\n\n        const Z = (t, e) => t ? Math.max(t, e) : e;\n\n        j = Z(C, j), j = Z(V, j), j = Z(T, j);\n        const G = j > -1 ? 1 : 0;\n        G && (j *= A / 24), t.glyphOffsetArray.length >= ku.MAX_GLYPHS && x(\"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\"), void 0 !== w.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, w.sortKey), t.symbolInstances.emplaceBack(e.x, e.y, R.right >= 0 ? R.right : -1, R.center >= 0 ? R.center : -1, R.left >= 0 ? R.left : -1, R.vertical || -1, O, $, q, void 0 !== z ? z : t.collisionBoxArray.length, void 0 !== z ? z + 1 : t.collisionBoxArray.length, void 0 !== B ? B : t.collisionBoxArray.length, void 0 !== B ? B + 1 : t.collisionBoxArray.length, void 0 !== M ? M : t.collisionBoxArray.length, void 0 !== M ? M + 1 : t.collisionBoxArray.length, P || t.collisionBoxArray.length, P ? P + 1 : t.collisionBoxArray.length, u, F, L, E, D, G, 0, p, U, N, j);\n      }(t, a, r, n, i, s, P, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, v, _, A, c, 0, k, I, y, e, o, h, p, l);\n    };\n\n    if (\"line\" === z) for (const s of function (t, e, n, i, s) {\n      const o = [];\n\n      for (let e = 0; e < t.length; e++) {\n        const n = t[e];\n        let a;\n\n        for (let t = 0; t < n.length - 1; t++) {\n          let e = n[t],\n              l = n[t + 1];\n          e.x < 0 && l.x < 0 || (e.x < 0 ? e = new r(0, e.y + (0 - e.x) / (l.x - e.x) * (l.y - e.y))._round() : l.x < 0 && (l = new r(0, e.y + (0 - e.x) / (l.x - e.x) * (l.y - e.y))._round()), e.y < 0 && l.y < 0 || (e.y < 0 ? e = new r(e.x + (0 - e.y) / (l.y - e.y) * (l.x - e.x), 0)._round() : l.y < 0 && (l = new r(e.x + (0 - e.y) / (l.y - e.y) * (l.x - e.x), 0)._round()), e.x >= i && l.x >= i || (e.x >= i ? e = new r(i, e.y + (i - e.x) / (l.x - e.x) * (l.y - e.y))._round() : l.x >= i && (l = new r(i, e.y + (i - e.x) / (l.x - e.x) * (l.y - e.y))._round()), e.y >= s && l.y >= s || (e.y >= s ? e = new r(e.x + (s - e.y) / (l.y - e.y) * (l.x - e.x), s)._round() : l.y >= s && (l = new r(e.x + (s - e.y) / (l.y - e.y) * (l.x - e.x), s)._round()), a && e.equals(a[a.length - 1]) || (a = [e], o.push(a)), a.push(l)))));\n        }\n      }\n\n      return o;\n    }(e.geometry, 0, 0, 8192, 8192)) {\n      const e = jl(s, w, S, n.vertical || m, i, 24, b, t.overscaling, 8192);\n\n      for (const r of e) {\n        const e = m;\n        e && yu(t, e.text, M, r) || C(s, r);\n      }\n    } else if (\"line-center\" === z) {\n      for (const t of e.geometry) if (t.length > 1) {\n        const e = Nl(t, S, n.vertical || m, i, 24, b);\n        e && C(t, e);\n      }\n    } else if (\"Polygon\" === e.type) for (const t of na(e.geometry, 0)) {\n      const e = iu(t, 16);\n      C(t[0], new Ol(e.x, e.y, 0));\n    } else if (\"LineString\" === e.type) for (const t of e.geometry) C(t, new Ol(t[0].x, t[0].y, 0));else if (\"Point\" === e.type) for (const t of e.geometry) for (const e of t) C([e], new Ol(e.x, e.y, 0));\n  }\n\n  function hu(t, e, n, i, s, o, a, l, u, c, h, p, f, d, y) {\n    const m = function (t, e, n, i, s, o, a, l) {\n      const u = i.layout.get(\"text-rotate\").evaluate(o, {}) * Math.PI / 180,\n            c = [];\n\n      for (const t of e.positionedLines) for (const i of t.positionedGlyphs) {\n        if (!i.rect) continue;\n        const o = i.rect || {};\n        let h = 4,\n            p = !0,\n            f = 1,\n            d = 0;\n        const y = (s || l) && i.vertical,\n              m = i.metrics.advance * i.scale / 2;\n\n        if (l && e.verticalizable) {\n          const e = 24 * (i.scale - 1),\n                r = (24 - i.metrics.width * i.scale) / 2;\n          d = t.lineOffset / 2 - (i.imageName ? -r : e);\n        }\n\n        if (i.imageName) {\n          const t = a[i.imageName];\n          p = t.sdf, f = t.pixelRatio, h = 1 / f;\n        }\n\n        const g = s ? [i.x + m, i.y] : [0, 0];\n        let x = s ? [0, 0] : [i.x + m + n[0], i.y + n[1] - d],\n            v = [0, 0];\n        y && (v = x, x = [0, 0]);\n\n        const b = (i.metrics.left - h) * i.scale - m + x[0],\n              w = (-i.metrics.top - h) * i.scale + x[1],\n              _ = b + o.w * i.scale / (f * (i.localGlyph ? 2 : 1)),\n              k = w + o.h * i.scale / (f * (i.localGlyph ? 2 : 1)),\n              S = new r(b, w),\n              A = new r(_, w),\n              I = new r(b, k),\n              z = new r(_, k);\n\n        if (y) {\n          const t = new r(-m, m - -17),\n                e = -Math.PI / 2,\n                n = 12 - m,\n                s = new r(22 - n, -(i.imageName ? n : 0)),\n                o = new r(...v);\n          S._rotateAround(e, t)._add(s)._add(o), A._rotateAround(e, t)._add(s)._add(o), I._rotateAround(e, t)._add(s)._add(o), z._rotateAround(e, t)._add(s)._add(o);\n        }\n\n        if (u) {\n          const t = Math.sin(u),\n                e = Math.cos(u),\n                r = [e, -t, t, e];\n          S._matMult(r), A._matMult(r), I._matMult(r), z._matMult(r);\n        }\n\n        const M = new r(0, 0),\n              B = new r(0, 0);\n        c.push({\n          tl: S,\n          tr: A,\n          bl: I,\n          br: z,\n          tex: o,\n          writingMode: e.writingMode,\n          glyphOffset: g,\n          sectionIndex: i.sectionIndex,\n          isSDF: p,\n          pixelOffsetTL: M,\n          pixelOffsetBR: B,\n          minFontScaleX: 0,\n          minFontScaleY: 0\n        });\n      }\n\n      return c;\n    }(0, n, l, s, o, a, i, t.allowVerticalPlacement),\n          g = t.textSizeData;\n\n    let v = null;\n    \"source\" === g.kind ? (v = [128 * s.layout.get(\"text-size\").evaluate(a, {}, y)], v[0] > 32640 && x(`${t.layerIds[0]}: Value for \"text-size\" is >= 255. Reduce your \"text-size\".`)) : \"composite\" === g.kind && (v = [128 * d.compositeTextSizes[0].evaluate(a, {}, y), 128 * d.compositeTextSizes[1].evaluate(a, {}, y)], (v[0] > 32640 || v[1] > 32640) && x(`${t.layerIds[0]}: Value for \"text-size\" is >= 255. Reduce your \"text-size\".`)), t.addSymbols(t.text, m, v, l, o, a, c, e, u.lineStartIndex, u.lineLength, f, y);\n\n    for (const e of h) p[e] = t.text.placedSymbolArray.length - 1;\n\n    return 4 * m.length;\n  }\n\n  function pu(t) {\n    for (const e in t) return t[e];\n\n    return null;\n  }\n\n  function fu(t, e, n, i, s, o, l, u, c) {\n    let h = o.top,\n        p = o.bottom,\n        f = o.left,\n        d = o.right;\n    const y = o.collisionPadding;\n\n    if (y && (f -= y[0], h -= y[1], d += y[2], p += y[3]), c) {\n      const t = new r(f, h),\n            e = new r(d, h),\n            n = new r(f, p),\n            i = new r(d, p),\n            s = a(c);\n      t._rotate(s), e._rotate(s), n._rotate(s), i._rotate(s), f = Math.min(t.x, e.x, n.x, i.x), d = Math.max(t.x, e.x, n.x, i.x), h = Math.min(t.y, e.y, n.y, i.y), p = Math.max(t.y, e.y, n.y, i.y);\n    }\n\n    return t.emplaceBack(e.x, e.y, f, h, d, p, u, n, i, s), t.length - 1;\n  }\n\n  function du(t) {\n    t.collisionPadding && (t.top -= t.collisionPadding[1], t.bottom += t.collisionPadding[3]);\n    const e = t.bottom - t.top;\n    return e > 0 ? Math.max(10, e) : null;\n  }\n\n  function yu(t, e, r, n) {\n    const i = t.compareText;\n\n    if (e in i) {\n      const t = i[e];\n\n      for (let e = t.length - 1; e >= 0; e--) if (n.dist(t[e]) < r) return !0;\n    } else i[e] = [];\n\n    return i[e].push(n), !1;\n  }\n\n  const mu = wa.VectorTileFeature.types,\n        gu = [{\n    name: \"a_fade_opacity\",\n    components: 1,\n    type: \"Uint8\",\n    offset: 0\n  }];\n\n  function xu(t, e, r, n, i, s, o, a, l, u, c, h, p) {\n    const f = a ? Math.min(32640, Math.round(a[0])) : 0,\n          d = a ? Math.min(32640, Math.round(a[1])) : 0;\n    t.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), s, o, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * c, 256 * h, 256 * p);\n  }\n\n  function vu(t, e, r) {\n    t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r);\n  }\n\n  function bu(t) {\n    for (const e of t.sections) if (Pn(e.text)) return !0;\n\n    return !1;\n  }\n\n  class wu {\n    constructor(t) {\n      this.layoutVertexArray = new Vi(), this.indexArray = new $i(), this.programConfigurations = t, this.segments = new Cs(), this.dynamicLayoutVertexArray = new Ti(), this.opacityVertexArray = new Ei(), this.placedSymbolArray = new Hi();\n    }\n\n    isEmpty() {\n      return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;\n    }\n\n    upload(t, e, r, n) {\n      this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ja.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Za.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, gu, !0), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));\n    }\n\n    destroy() {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());\n    }\n\n  }\n\n  Je(\"SymbolBuffers\", wu);\n\n  class _u {\n    constructor(t, e, r) {\n      this.layoutVertexArray = new t(), this.layoutAttributes = e, this.indexArray = new r(), this.segments = new Cs(), this.collisionVertexArray = new Oi(), this.collisionVertexArrayExt = new Ti();\n    }\n\n    upload(t) {\n      this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Ga.members, !0), this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, Xa.members, !0);\n    }\n\n    destroy() {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());\n    }\n\n  }\n\n  Je(\"CollisionBuffers\", _u);\n\n  class ku {\n    constructor(t) {\n      this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = no([]), this.placementViewportMatrix = no([]);\n      const e = this.layers[0]._unevaluatedLayout._values;\n      this.textSizeData = Ya(this.zoom, e[\"text-size\"]), this.iconSizeData = Ya(this.zoom, e[\"icon-size\"]);\n      const r = this.layers[0].layout,\n            n = r.get(\"symbol-sort-key\"),\n            i = r.get(\"symbol-z-order\");\n      this.canOverlap = r.get(\"text-allow-overlap\") || r.get(\"icon-allow-overlap\") || r.get(\"text-ignore-placement\") || r.get(\"icon-ignore-placement\"), this.sortFeaturesByKey = \"viewport-y\" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = (\"viewport-y\" === i || \"auto\" === i && !this.sortFeaturesByKey) && this.canOverlap, \"point\" === r.get(\"symbol-placement\") && (this.writingModes = r.get(\"text-writing-mode\").map(t => kl[t])), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.sourceID = t.sourceID;\n    }\n\n    createArrays() {\n      this.text = new wu(new As(this.layers, this.zoom, t => /^text/.test(t))), this.icon = new wu(new As(this.layers, this.zoom, t => /^icon/.test(t))), this.glyphOffsetArray = new ts(), this.lineVertexArray = new es(), this.symbolInstances = new Qi();\n    }\n\n    calculateGlyphDependencies(t, e, r, n, i) {\n      for (let s = 0; s < t.length; s++) if (e[t.charCodeAt(s)] = !0, (r || n) && i) {\n        const r = Qa[t.charAt(s)];\n        r && (e[r.charCodeAt(0)] = !0);\n      }\n    }\n\n    populate(t, e, r) {\n      const n = this.layers[0],\n            i = n.layout,\n            s = i.get(\"text-font\"),\n            o = i.get(\"text-field\"),\n            a = i.get(\"icon-image\"),\n            l = (\"constant\" !== o.value.kind || o.value.value instanceof W && !o.value.value.isEmpty() || o.value.value.toString().length > 0) && (\"constant\" !== s.value.kind || s.value.value.length > 0),\n            u = \"constant\" !== a.value.kind || !!a.value.value || Object.keys(a.parameters).length > 0,\n            c = i.get(\"symbol-sort-key\");\n      if (this.features = [], !l && !u) return;\n      const h = e.iconDependencies,\n            p = e.glyphDependencies,\n            f = e.availableImages,\n            d = new oi(this.zoom);\n\n      for (const {\n        feature: e,\n        id: o,\n        index: a,\n        sourceLayerIndex: y\n      } of t) {\n        const t = n._featureFilter.needGeometry,\n              m = Ds(e, t);\n        if (!n._featureFilter.filter(d, m, r)) continue;\n        let g, x;\n\n        if (t || (m.geometry = Es(e)), l) {\n          const t = n.getValueAndResolveTokens(\"text-field\", m, r, f),\n                e = W.factory(t);\n          bu(e) && (this.hasRTLText = !0), (!this.hasRTLText || \"unavailable\" === ni || this.hasRTLText && si.isParsed()) && (g = Wa(e, n, m));\n        }\n\n        if (u) {\n          const t = n.getValueAndResolveTokens(\"icon-image\", m, r, f);\n          x = t instanceof Q ? t : Q.fromString(t);\n        }\n\n        if (!g && !x) continue;\n        const v = this.sortFeaturesByKey ? c.evaluate(m, {}, r) : void 0;\n\n        if (this.features.push({\n          id: o,\n          text: g,\n          icon: x,\n          index: a,\n          sourceLayerIndex: y,\n          geometry: m.geometry,\n          properties: e.properties,\n          type: mu[e.type],\n          sortKey: v\n        }), x && (h[x.name] = !0), g) {\n          const t = s.evaluate(m, {}, r).join(\",\"),\n                e = \"map\" === i.get(\"text-rotation-alignment\") && \"point\" !== i.get(\"symbol-placement\");\n          this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(kl.vertical) >= 0;\n\n          for (const r of g.sections) if (r.image) h[r.image.name] = !0;else {\n            const n = kn(g.toString()),\n                  i = r.fontStack || t,\n                  s = p[i] = p[i] || {};\n            this.calculateGlyphDependencies(r.text, s, e, this.allowVerticalPlacement, n);\n          }\n        }\n      }\n\n      \"line\" === i.get(\"symbol-placement\") && (this.features = function (t) {\n        const e = {},\n              r = {},\n              n = [];\n        let i = 0;\n\n        function s(e) {\n          n.push(t[e]), i++;\n        }\n\n        function o(t, e, i) {\n          const s = r[t];\n          return delete r[t], r[e] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;\n        }\n\n        function a(t, r, i) {\n          const s = e[r];\n          return delete e[r], e[t] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;\n        }\n\n        function l(t, e, r) {\n          const n = r ? e[0][e[0].length - 1] : e[0][0];\n          return `${t}:${n.x}:${n.y}`;\n        }\n\n        for (let u = 0; u < t.length; u++) {\n          const c = t[u],\n                h = c.geometry,\n                p = c.text ? c.text.toString() : null;\n\n          if (!p) {\n            s(u);\n            continue;\n          }\n\n          const f = l(p, h),\n                d = l(p, h, !0);\n\n          if (f in r && d in e && r[f] !== e[d]) {\n            const t = a(f, d, h),\n                  i = o(f, d, n[t].geometry);\n            delete e[f], delete r[d], r[l(p, n[i].geometry, !0)] = i, n[t].geometry = null;\n          } else f in r ? o(f, d, h) : d in e ? a(f, d, h) : (s(u), e[f] = i - 1, r[d] = i - 1);\n        }\n\n        return n.filter(t => t.geometry);\n      }(this.features)), this.sortFeaturesByKey && this.features.sort((t, e) => t.sortKey - e.sortKey);\n    }\n\n    update(t, e, r) {\n      this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, r), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, r));\n    }\n\n    isEmpty() {\n      return 0 === this.symbolInstances.length && !this.hasRTLText;\n    }\n\n    uploadPending() {\n      return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;\n    }\n\n    upload(t) {\n      !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;\n    }\n\n    destroyDebugData() {\n      this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();\n    }\n\n    destroy() {\n      this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();\n    }\n\n    addToLineVertexArray(t, e) {\n      const r = this.lineVertexArray.length;\n\n      if (void 0 !== t.segment) {\n        let r = t.dist(e[t.segment + 1]),\n            n = t.dist(e[t.segment]);\n        const i = {};\n\n        for (let n = t.segment + 1; n < e.length; n++) i[n] = {\n          x: e[n].x,\n          y: e[n].y,\n          tileUnitDistanceFromAnchor: r\n        }, n < e.length - 1 && (r += e[n + 1].dist(e[n]));\n\n        for (let r = t.segment || 0; r >= 0; r--) i[r] = {\n          x: e[r].x,\n          y: e[r].y,\n          tileUnitDistanceFromAnchor: n\n        }, r > 0 && (n += e[r - 1].dist(e[r]));\n\n        for (let t = 0; t < e.length; t++) {\n          const e = i[t];\n          this.lineVertexArray.emplaceBack(e.x, e.y, e.tileUnitDistanceFromAnchor);\n        }\n      }\n\n      return {\n        lineStartIndex: r,\n        lineLength: this.lineVertexArray.length - r\n      };\n    }\n\n    addSymbols(t, e, r, n, i, s, o, a, l, u, c, h) {\n      const p = t.indexArray,\n            f = t.layoutVertexArray,\n            d = t.segments.prepareSegment(4 * e.length, f, p, this.canOverlap ? s.sortKey : void 0),\n            y = this.glyphOffsetArray.length,\n            m = d.vertexLength,\n            g = this.allowVerticalPlacement && o === kl.vertical ? Math.PI / 2 : 0,\n            x = s.text && s.text.sections;\n\n      for (let n = 0; n < e.length; n++) {\n        const {\n          tl: i,\n          tr: o,\n          bl: l,\n          br: u,\n          tex: c,\n          pixelOffsetTL: y,\n          pixelOffsetBR: m,\n          minFontScaleX: v,\n          minFontScaleY: b,\n          glyphOffset: w,\n          isSDF: _,\n          sectionIndex: k\n        } = e[n],\n              S = d.vertexLength,\n              A = w[1];\n        xu(f, a.x, a.y, i.x, A + i.y, c.x, c.y, r, _, y.x, y.y, v, b), xu(f, a.x, a.y, o.x, A + o.y, c.x + c.w, c.y, r, _, m.x, y.y, v, b), xu(f, a.x, a.y, l.x, A + l.y, c.x, c.y + c.h, r, _, y.x, m.y, v, b), xu(f, a.x, a.y, u.x, A + u.y, c.x + c.w, c.y + c.h, r, _, m.x, m.y, v, b), vu(t.dynamicLayoutVertexArray, a, g), p.emplaceBack(S, S + 1, S + 2), p.emplaceBack(S + 1, S + 2, S + 3), d.vertexLength += 4, d.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w[0]), n !== e.length - 1 && k === e[n + 1].sectionIndex || t.programConfigurations.populatePaintArrays(f.length, s, s.index, {}, h, x && x[k]);\n      }\n\n      t.placedSymbolArray.emplaceBack(a.x, a.y, y, this.glyphOffsetArray.length - y, m, l, u, a.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], o, 0, !1, 0, c);\n    }\n\n    _commitLayoutVertex(t, e, r, n, i) {\n      t.emplaceBack(e.x, e.y, r, n, Math.round(i.x), Math.round(i.y));\n    }\n\n    _addCollisionDebugVertices(t, e, n, i, s) {\n      const o = n.segments.prepareSegment(4, n.layoutVertexArray, n.indexArray),\n            a = o.vertexLength,\n            l = s.anchorX,\n            u = s.anchorY;\n\n      for (let t = 0; t < 4; t++) n.collisionVertexArray.emplaceBack(0, 0, 0, 0);\n\n      n.collisionVertexArrayExt.emplaceBack(e, -t.padding, -t.padding), n.collisionVertexArrayExt.emplaceBack(e, t.padding, -t.padding), n.collisionVertexArrayExt.emplaceBack(e, t.padding, t.padding), n.collisionVertexArrayExt.emplaceBack(e, -t.padding, t.padding), this._commitLayoutVertex(n.layoutVertexArray, i, l, u, new r(t.x1, t.y1)), this._commitLayoutVertex(n.layoutVertexArray, i, l, u, new r(t.x2, t.y1)), this._commitLayoutVertex(n.layoutVertexArray, i, l, u, new r(t.x2, t.y2)), this._commitLayoutVertex(n.layoutVertexArray, i, l, u, new r(t.x1, t.y2)), o.vertexLength += 4;\n      const c = n.indexArray;\n      c.emplaceBack(a, a + 1), c.emplaceBack(a + 1, a + 2), c.emplaceBack(a + 2, a + 3), c.emplaceBack(a + 3, a), o.primitiveLength += 4;\n    }\n\n    _addTextDebugCollisionBoxes(t, e, r, n, i, s) {\n      for (let o = n; o < i; o++) {\n        const n = r.get(o),\n              i = this.getSymbolInstanceTextSize(t, s, e, o);\n\n        this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.anchorPoint, s);\n      }\n    }\n\n    _addIconDebugCollisionBoxes(t, e, r, n, i, s) {\n      for (let o = n; o < i; o++) {\n        const n = r.get(o),\n              i = this.getSymbolInstanceIconSize(t, e, o);\n\n        this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.anchorPoint, s);\n      }\n    }\n\n    generateCollisionDebugBuffers(t, e) {\n      this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new _u(Fi, Ja.members, Zi), this.iconCollisionBox = new _u(Fi, Ja.members, Zi);\n      const r = Ha(this.iconSizeData, t),\n            n = Ha(this.textSizeData, t);\n\n      for (let i = 0; i < this.symbolInstances.length; i++) {\n        const s = this.symbolInstances.get(i);\n        this._addTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);\n      }\n    }\n\n    getSymbolInstanceTextSize(t, e, r, n) {\n      const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n),\n            s = Ka(this.textSizeData, t, i) / 24;\n      return this.tilePixelRatio * s;\n    }\n\n    getSymbolInstanceIconSize(t, e, r) {\n      const n = this.icon.placedSymbolArray.get(r),\n            i = Ka(this.iconSizeData, t, n);\n      return this.tilePixelRatio * i;\n    }\n\n    _commitDebugCollisionVertexUpdate(t, e, r) {\n      t.emplaceBack(e, -r, -r), t.emplaceBack(e, r, -r), t.emplaceBack(e, r, r), t.emplaceBack(e, -r, r);\n    }\n\n    _updateTextDebugCollisionBoxes(t, e, r, n, i, s) {\n      for (let o = n; o < i; o++) {\n        const n = r.get(o),\n              i = this.getSymbolInstanceTextSize(t, s, e, o);\n\n        this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding);\n      }\n    }\n\n    _updateIconDebugCollisionBoxes(t, e, r, n, i) {\n      for (let s = n; s < i; s++) {\n        const n = r.get(s),\n              i = this.getSymbolInstanceIconSize(t, e, s);\n\n        this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding);\n      }\n    }\n\n    updateCollisionDebugBuffers(t, e) {\n      if (!this.hasDebugData()) return;\n      this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();\n      const r = Ha(this.iconSizeData, t),\n            n = Ha(this.textSizeData, t);\n\n      for (let i = 0; i < this.symbolInstances.length; i++) {\n        const s = this.symbolInstances.get(i);\n        this._updateTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._updateTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._updateIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex), this._updateIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex);\n      }\n\n      this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);\n    }\n\n    _deserializeCollisionBoxesForSymbol(t, e, r, n, i, s, o, a, l) {\n      const u = {};\n\n      for (let n = e; n < r; n++) {\n        const e = t.get(n);\n        u.textBox = {\n          x1: e.x1,\n          y1: e.y1,\n          x2: e.x2,\n          y2: e.y2,\n          padding: e.padding,\n          anchorPointX: e.anchorPointX,\n          anchorPointY: e.anchorPointY\n        }, u.textFeatureIndex = e.featureIndex;\n        break;\n      }\n\n      for (let e = n; e < i; e++) {\n        const r = t.get(e);\n        u.verticalTextBox = {\n          x1: r.x1,\n          y1: r.y1,\n          x2: r.x2,\n          y2: r.y2,\n          padding: r.padding,\n          anchorPointX: r.anchorPointX,\n          anchorPointY: r.anchorPointY\n        }, u.verticalTextFeatureIndex = r.featureIndex;\n        break;\n      }\n\n      for (let e = s; e < o; e++) {\n        const r = t.get(e);\n        u.iconBox = {\n          x1: r.x1,\n          y1: r.y1,\n          x2: r.x2,\n          y2: r.y2,\n          padding: r.padding,\n          anchorPointX: r.anchorPointX,\n          anchorPointY: r.anchorPointY\n        }, u.iconFeatureIndex = r.featureIndex;\n        break;\n      }\n\n      for (let e = a; e < l; e++) {\n        const r = t.get(e);\n        u.verticalIconBox = {\n          x1: r.x1,\n          y1: r.y1,\n          x2: r.x2,\n          y2: r.y2,\n          padding: r.padding,\n          anchorPointX: r.anchorPointX,\n          anchorPointY: r.anchorPointY\n        }, u.verticalIconFeatureIndex = r.featureIndex;\n        break;\n      }\n\n      return u;\n    }\n\n    deserializeCollisionBoxes(t) {\n      this.collisionArrays = [];\n\n      for (let e = 0; e < this.symbolInstances.length; e++) {\n        const r = this.symbolInstances.get(e);\n        this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));\n      }\n    }\n\n    hasTextData() {\n      return this.text.segments.get().length > 0;\n    }\n\n    hasIconData() {\n      return this.icon.segments.get().length > 0;\n    }\n\n    hasDebugData() {\n      return this.textCollisionBox && this.iconCollisionBox;\n    }\n\n    hasTextCollisionBoxData() {\n      return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;\n    }\n\n    hasIconCollisionBoxData() {\n      return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;\n    }\n\n    addIndicesForPlacedSymbol(t, e) {\n      const r = t.placedSymbolArray.get(e),\n            n = r.vertexStartIndex + 4 * r.numGlyphs;\n\n      for (let e = r.vertexStartIndex; e < n; e += 4) t.indexArray.emplaceBack(e, e + 1, e + 2), t.indexArray.emplaceBack(e + 1, e + 2, e + 3);\n    }\n\n    getSortedSymbolIndexes(t) {\n      if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;\n      const e = Math.sin(t),\n            r = Math.cos(t),\n            n = [],\n            i = [],\n            s = [];\n\n      for (let t = 0; t < this.symbolInstances.length; ++t) {\n        s.push(t);\n        const o = this.symbolInstances.get(t);\n        n.push(0 | Math.round(e * o.anchorX + r * o.anchorY)), i.push(o.featureIndex);\n      }\n\n      return s.sort((t, e) => n[t] - n[e] || i[e] - i[t]), s;\n    }\n\n    addToSortKeyRanges(t, e) {\n      const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];\n      r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({\n        sortKey: e,\n        symbolInstanceStart: t,\n        symbolInstanceEnd: t + 1\n      });\n    }\n\n    sortFeatures(t) {\n      if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {\n        this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];\n\n        for (const t of this.symbolInstanceIndexes) {\n          const e = this.symbolInstances.get(t);\n          this.featureSortOrder.push(e.featureIndex), [e.rightJustifiedTextSymbolIndex, e.centerJustifiedTextSymbolIndex, e.leftJustifiedTextSymbolIndex].forEach((t, e, r) => {\n            t >= 0 && r.indexOf(t) === e && this.addIndicesForPlacedSymbol(this.text, t);\n          }), e.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e.verticalPlacedTextSymbolIndex), e.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e.placedIconSymbolIndex), e.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e.verticalPlacedIconSymbolIndex);\n        }\n\n        this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);\n      }\n    }\n\n  }\n\n  Je(\"SymbolBucket\", ku, {\n    omit: [\"layers\", \"collisionBoxArray\", \"features\", \"compareText\"]\n  }), ku.MAX_GLYPHS = 65535, ku.addDynamicAttributes = vu;\n  const Su = new bi({\n    \"symbol-placement\": new yi(sr.layout_symbol[\"symbol-placement\"]),\n    \"symbol-spacing\": new yi(sr.layout_symbol[\"symbol-spacing\"]),\n    \"symbol-avoid-edges\": new yi(sr.layout_symbol[\"symbol-avoid-edges\"]),\n    \"symbol-sort-key\": new mi(sr.layout_symbol[\"symbol-sort-key\"]),\n    \"symbol-z-order\": new yi(sr.layout_symbol[\"symbol-z-order\"]),\n    \"icon-allow-overlap\": new yi(sr.layout_symbol[\"icon-allow-overlap\"]),\n    \"icon-ignore-placement\": new yi(sr.layout_symbol[\"icon-ignore-placement\"]),\n    \"icon-optional\": new yi(sr.layout_symbol[\"icon-optional\"]),\n    \"icon-rotation-alignment\": new yi(sr.layout_symbol[\"icon-rotation-alignment\"]),\n    \"icon-size\": new mi(sr.layout_symbol[\"icon-size\"]),\n    \"icon-text-fit\": new yi(sr.layout_symbol[\"icon-text-fit\"]),\n    \"icon-text-fit-padding\": new yi(sr.layout_symbol[\"icon-text-fit-padding\"]),\n    \"icon-image\": new mi(sr.layout_symbol[\"icon-image\"]),\n    \"icon-rotate\": new mi(sr.layout_symbol[\"icon-rotate\"]),\n    \"icon-padding\": new yi(sr.layout_symbol[\"icon-padding\"]),\n    \"icon-keep-upright\": new yi(sr.layout_symbol[\"icon-keep-upright\"]),\n    \"icon-offset\": new mi(sr.layout_symbol[\"icon-offset\"]),\n    \"icon-anchor\": new mi(sr.layout_symbol[\"icon-anchor\"]),\n    \"icon-pitch-alignment\": new yi(sr.layout_symbol[\"icon-pitch-alignment\"]),\n    \"text-pitch-alignment\": new yi(sr.layout_symbol[\"text-pitch-alignment\"]),\n    \"text-rotation-alignment\": new yi(sr.layout_symbol[\"text-rotation-alignment\"]),\n    \"text-field\": new mi(sr.layout_symbol[\"text-field\"]),\n    \"text-font\": new mi(sr.layout_symbol[\"text-font\"]),\n    \"text-size\": new mi(sr.layout_symbol[\"text-size\"]),\n    \"text-max-width\": new mi(sr.layout_symbol[\"text-max-width\"]),\n    \"text-line-height\": new yi(sr.layout_symbol[\"text-line-height\"]),\n    \"text-letter-spacing\": new mi(sr.layout_symbol[\"text-letter-spacing\"]),\n    \"text-justify\": new mi(sr.layout_symbol[\"text-justify\"]),\n    \"text-radial-offset\": new mi(sr.layout_symbol[\"text-radial-offset\"]),\n    \"text-variable-anchor\": new yi(sr.layout_symbol[\"text-variable-anchor\"]),\n    \"text-anchor\": new mi(sr.layout_symbol[\"text-anchor\"]),\n    \"text-max-angle\": new yi(sr.layout_symbol[\"text-max-angle\"]),\n    \"text-writing-mode\": new yi(sr.layout_symbol[\"text-writing-mode\"]),\n    \"text-rotate\": new mi(sr.layout_symbol[\"text-rotate\"]),\n    \"text-padding\": new yi(sr.layout_symbol[\"text-padding\"]),\n    \"text-keep-upright\": new yi(sr.layout_symbol[\"text-keep-upright\"]),\n    \"text-transform\": new mi(sr.layout_symbol[\"text-transform\"]),\n    \"text-offset\": new mi(sr.layout_symbol[\"text-offset\"]),\n    \"text-allow-overlap\": new yi(sr.layout_symbol[\"text-allow-overlap\"]),\n    \"text-ignore-placement\": new yi(sr.layout_symbol[\"text-ignore-placement\"]),\n    \"text-optional\": new yi(sr.layout_symbol[\"text-optional\"])\n  });\n  var Au = {\n    paint: new bi({\n      \"icon-opacity\": new mi(sr.paint_symbol[\"icon-opacity\"]),\n      \"icon-color\": new mi(sr.paint_symbol[\"icon-color\"]),\n      \"icon-halo-color\": new mi(sr.paint_symbol[\"icon-halo-color\"]),\n      \"icon-halo-width\": new mi(sr.paint_symbol[\"icon-halo-width\"]),\n      \"icon-halo-blur\": new mi(sr.paint_symbol[\"icon-halo-blur\"]),\n      \"icon-translate\": new yi(sr.paint_symbol[\"icon-translate\"]),\n      \"icon-translate-anchor\": new yi(sr.paint_symbol[\"icon-translate-anchor\"]),\n      \"text-opacity\": new mi(sr.paint_symbol[\"text-opacity\"]),\n      \"text-color\": new mi(sr.paint_symbol[\"text-color\"], {\n        runtimeType: O,\n        getOverride: t => t.textColor,\n        hasOverride: t => !!t.textColor\n      }),\n      \"text-halo-color\": new mi(sr.paint_symbol[\"text-halo-color\"]),\n      \"text-halo-width\": new mi(sr.paint_symbol[\"text-halo-width\"]),\n      \"text-halo-blur\": new mi(sr.paint_symbol[\"text-halo-blur\"]),\n      \"text-translate\": new yi(sr.paint_symbol[\"text-translate\"]),\n      \"text-translate-anchor\": new yi(sr.paint_symbol[\"text-translate-anchor\"])\n    }),\n    layout: Su\n  };\n\n  class Iu {\n    constructor(t) {\n      this.type = t.property.overrides ? t.property.overrides.runtimeType : E, this.defaultValue = t;\n    }\n\n    evaluate(t) {\n      if (t.formattedSection) {\n        const e = this.defaultValue.property.overrides;\n        if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection);\n      }\n\n      return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;\n    }\n\n    eachChild(t) {\n      this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);\n    }\n\n    outputDefined() {\n      return !1;\n    }\n\n    serialize() {\n      return null;\n    }\n\n  }\n\n  Je(\"FormatSectionOverride\", Iu, {\n    omit: [\"defaultValue\"]\n  });\n\n  class zu extends Ms {\n    constructor(t) {\n      super(t, Au);\n    }\n\n    recalculate(t, e) {\n      if (super.recalculate(t, e), \"auto\" === this.layout.get(\"icon-rotation-alignment\") && (this.layout._values[\"icon-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-rotation-alignment\") && (this.layout._values[\"text-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-pitch-alignment\") && (this.layout._values[\"text-pitch-alignment\"] = this.layout.get(\"text-rotation-alignment\")), \"auto\" === this.layout.get(\"icon-pitch-alignment\") && (this.layout._values[\"icon-pitch-alignment\"] = this.layout.get(\"icon-rotation-alignment\")), \"point\" === this.layout.get(\"symbol-placement\")) {\n        const t = this.layout.get(\"text-writing-mode\");\n\n        if (t) {\n          const e = [];\n\n          for (const r of t) e.indexOf(r) < 0 && e.push(r);\n\n          this.layout._values[\"text-writing-mode\"] = e;\n        } else this.layout._values[\"text-writing-mode\"] = [\"horizontal\"];\n      }\n\n      this._setPaintOverrides();\n    }\n\n    getValueAndResolveTokens(t, e, r, n) {\n      const i = this.layout.get(t).evaluate(e, {}, r, n),\n            s = this._unevaluatedLayout._values[t];\n      return s.isDataDriven() || $e(s.value) || !i ? i : function (t, e) {\n        return e.replace(/{([^{}]+)}/g, (e, r) => r in t ? String(t[r]) : \"\");\n      }(e.properties, i);\n    }\n\n    createBucket(t) {\n      return new ku(t);\n    }\n\n    queryRadius() {\n      return 0;\n    }\n\n    queryIntersectsFeature() {\n      return !1;\n    }\n\n    _setPaintOverrides() {\n      for (const t of Au.paint.overridableProperties) {\n        if (!zu.hasPaintOverride(this.layout, t)) continue;\n        const e = this.paint.get(t),\n              r = new Iu(e),\n              n = new Oe(r, e.property.specification);\n        let i = null;\n        i = \"constant\" === e.value.kind || \"source\" === e.value.kind ? new qe(\"source\", n) : new Ue(\"composite\", n, e.value.zoomStops, e.value._interpolationType), this.paint._values[t] = new fi(e.property, i, e.parameters);\n      }\n    }\n\n    _handleOverridablePaintPropertyUpdate(t, e, r) {\n      return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && zu.hasPaintOverride(this.layout, t);\n    }\n\n    static hasPaintOverride(t, e) {\n      const r = t.get(\"text-field\"),\n            n = Au.paint.properties[e];\n      let i = !1;\n\n      const s = t => {\n        for (const e of t) if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);\n      };\n\n      if (\"constant\" === r.value.kind && r.value.value instanceof W) s(r.value.value.sections);else if (\"source\" === r.value.kind) {\n        const t = e => {\n          i || (e instanceof it && rt(e.value) === U ? s(e.value.sections) : e instanceof lt ? s(e.sections) : e.eachChild(t));\n        },\n              e = r.value;\n\n        e._styleExpression && t(e._styleExpression.expression);\n      }\n      return i;\n    }\n\n    getProgramConfiguration(t) {\n      return new Ss(this, t);\n    }\n\n  }\n\n  var Mu = {\n    paint: new bi({\n      \"background-color\": new yi(sr.paint_background[\"background-color\"]),\n      \"background-pattern\": new xi(sr.paint_background[\"background-pattern\"]),\n      \"background-opacity\": new yi(sr.paint_background[\"background-opacity\"])\n    })\n  },\n      Bu = {\n    paint: new bi({\n      \"raster-opacity\": new yi(sr.paint_raster[\"raster-opacity\"]),\n      \"raster-hue-rotate\": new yi(sr.paint_raster[\"raster-hue-rotate\"]),\n      \"raster-brightness-min\": new yi(sr.paint_raster[\"raster-brightness-min\"]),\n      \"raster-brightness-max\": new yi(sr.paint_raster[\"raster-brightness-max\"]),\n      \"raster-saturation\": new yi(sr.paint_raster[\"raster-saturation\"]),\n      \"raster-contrast\": new yi(sr.paint_raster[\"raster-contrast\"]),\n      \"raster-resampling\": new yi(sr.paint_raster[\"raster-resampling\"]),\n      \"raster-fade-duration\": new yi(sr.paint_raster[\"raster-fade-duration\"])\n    })\n  };\n\n  class Pu extends Ms {\n    constructor(t) {\n      super(t, {}), this.implementation = t;\n    }\n\n    is3D() {\n      return \"3d\" === this.implementation.renderingMode;\n    }\n\n    hasOffscreenPass() {\n      return void 0 !== this.implementation.prerender;\n    }\n\n    recalculate() {}\n\n    updateTransitions() {}\n\n    hasTransition() {}\n\n    serialize() {}\n\n    onAdd(t) {\n      this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);\n    }\n\n    onRemove(t) {\n      this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);\n    }\n\n  }\n\n  var Cu = {\n    paint: new bi({\n      \"sky-type\": new yi(sr.paint_sky[\"sky-type\"]),\n      \"sky-atmosphere-sun\": new yi(sr.paint_sky[\"sky-atmosphere-sun\"]),\n      \"sky-atmosphere-sun-intensity\": new yi(sr.paint_sky[\"sky-atmosphere-sun-intensity\"]),\n      \"sky-gradient-center\": new yi(sr.paint_sky[\"sky-gradient-center\"]),\n      \"sky-gradient-radius\": new yi(sr.paint_sky[\"sky-gradient-radius\"]),\n      \"sky-gradient\": new vi(sr.paint_sky[\"sky-gradient\"]),\n      \"sky-atmosphere-halo-color\": new yi(sr.paint_sky[\"sky-atmosphere-halo-color\"]),\n      \"sky-atmosphere-color\": new yi(sr.paint_sky[\"sky-atmosphere-color\"]),\n      \"sky-opacity\": new yi(sr.paint_sky[\"sky-opacity\"])\n    })\n  };\n\n  function Vu(t, e, r) {\n    const n = so(0, 0, 1),\n          i = function (t) {\n      return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;\n    }(uo());\n\n    return function (t, e, r) {\n      r *= .5;\n      var n = e[0],\n          i = e[1],\n          s = e[2],\n          o = e[3],\n          a = Math.sin(r),\n          l = Math.cos(r);\n      t[0] = n * l - s * a, t[1] = i * l + o * a, t[2] = s * l + n * a, t[3] = o * l - i * a;\n    }(i, i, r ? -a(t) + Math.PI : a(t)), function (t, e, r) {\n      r *= .5;\n      var n = e[0],\n          i = e[1],\n          s = e[2],\n          o = e[3],\n          a = Math.sin(r),\n          l = Math.cos(r);\n      t[0] = n * l + o * a, t[1] = i * l + s * a, t[2] = s * l - i * a, t[3] = o * l - n * a;\n    }(i, i, -a(e)), function (t, e, r) {\n      var n = r[0],\n          i = r[1],\n          s = r[2],\n          o = e[0],\n          a = e[1],\n          l = e[2],\n          u = i * l - s * a,\n          c = s * o - n * l,\n          h = n * a - i * o,\n          p = i * h - s * c,\n          f = s * u - n * h,\n          d = n * c - i * u,\n          y = 2 * r[3];\n      c *= y, h *= y, f *= 2, d *= 2, t[0] = o + (u *= y) + (p *= 2), t[1] = a + c + f, t[2] = l + h + d;\n    }(n, n, i), function (t, e) {\n      var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = r * r + n * n + i * i;\n      return s > 0 && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t;\n    }(n, n);\n  }\n\n  const Tu = {\n    circle: class extends Ms {\n      constructor(t) {\n        super(t, eo);\n      }\n\n      createBucket(t) {\n        return new Ls(t);\n      }\n\n      queryRadius(t) {\n        const e = t;\n        return Ys(\"circle-radius\", this, e) + Ys(\"circle-stroke-width\", this, e) + Ks(this.paint.get(\"circle-translate\"));\n      }\n\n      queryIntersectsFeature(t, e, r, n, i, s, o, a) {\n        const l = \"map\" === this.paint.get(\"circle-pitch-alignment\");\n        if (l && t.queryGeometry.isAboveHorizon) return !1;\n        const u = Ws(this.paint.get(\"circle-translate\"), this.paint.get(\"circle-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor),\n              c = this.paint.get(\"circle-radius\").evaluate(e, r) + this.paint.get(\"circle-stroke-width\").evaluate(e, r),\n              h = l ? c * t.pixelToTileUnitsFactor : c;\n\n        for (const e of n) for (const r of e) {\n          const e = r.add(u),\n                n = a && s.elevation ? s.elevation.exaggeration() * a.getElevationAt(e.x, e.y, !0) : 0,\n                i = l ? e : co(e, n, o),\n                c = l ? t.tilespaceRays.map(t => fo(t, n)) : t.queryGeometry.screenGeometry;\n          let p = h;\n          const f = lo([], [r.x, r.y, n, 1], o);\n          if (\"viewport\" === this.paint.get(\"circle-pitch-scale\") && \"map\" === this.paint.get(\"circle-pitch-alignment\") ? p *= f[3] / s.cameraToCenterDistance : \"map\" === this.paint.get(\"circle-pitch-scale\") && \"viewport\" === this.paint.get(\"circle-pitch-alignment\") && (p *= s.cameraToCenterDistance / f[3]), $s(c, i, p)) return !0;\n        }\n\n        return !1;\n      }\n\n      getProgramIds() {\n        return [\"circle\"];\n      }\n\n      getProgramConfiguration(t) {\n        return new Ss(this, t);\n      }\n\n    },\n    heatmap: class extends Ms {\n      createBucket(t) {\n        return new yo(t);\n      }\n\n      constructor(t) {\n        super(t, wo), this._updateColorRamp();\n      }\n\n      _handleSpecialPaintPropertyUpdate(t) {\n        \"heatmap-color\" === t && this._updateColorRamp();\n      }\n\n      _updateColorRamp() {\n        this.colorRamp = _o({\n          expression: this._transitionablePaint._values[\"heatmap-color\"].value.expression,\n          evaluationKey: \"heatmapDensity\",\n          image: this.colorRamp\n        }), this.colorRampTexture = null;\n      }\n\n      resize() {\n        this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);\n      }\n\n      queryRadius() {\n        return 0;\n      }\n\n      queryIntersectsFeature() {\n        return !1;\n      }\n\n      hasOffscreenPass() {\n        return 0 !== this.paint.get(\"heatmap-opacity\") && \"none\" !== this.visibility;\n      }\n\n      getProgramIds() {\n        return [\"heatmap\", \"heatmapTexture\"];\n      }\n\n      getProgramConfiguration(t) {\n        return new Ss(this, t);\n      }\n\n    },\n    hillshade: class extends Ms {\n      constructor(t) {\n        super(t, ko);\n      }\n\n      hasOffscreenPass() {\n        return 0 !== this.paint.get(\"hillshade-exaggeration\") && \"none\" !== this.visibility;\n      }\n\n      getProgramIds() {\n        return [\"hillshade\", \"hillshadePrepare\"];\n      }\n\n      getProgramConfiguration(t) {\n        return new Ss(this, t);\n      }\n\n    },\n    fill: class extends Ms {\n      constructor(t) {\n        super(t, ua);\n      }\n\n      getProgramIds() {\n        const t = this.paint.get(\"fill-pattern\"),\n              e = t && t.constantOr(1),\n              r = [e ? \"fillPattern\" : \"fill\"];\n        return this.paint.get(\"fill-antialias\") && r.push(e && !this.getPaintProperty(\"fill-outline-color\") ? \"fillOutlinePattern\" : \"fillOutline\"), r;\n      }\n\n      getProgramConfiguration(t) {\n        return new Ss(this, t);\n      }\n\n      recalculate(t, e) {\n        super.recalculate(t, e);\n        const r = this.paint._values[\"fill-outline-color\"];\n        \"constant\" === r.value.kind && void 0 === r.value.value && (this.paint._values[\"fill-outline-color\"] = this.paint._values[\"fill-color\"]);\n      }\n\n      createBucket(t) {\n        return new aa(t);\n      }\n\n      queryRadius() {\n        return Ks(this.paint.get(\"fill-translate\"));\n      }\n\n      queryIntersectsFeature(t, e, r, n, i, s) {\n        return !t.queryGeometry.isAboveHorizon && Rs(Hs(t.tilespaceGeometry, this.paint.get(\"fill-translate\"), this.paint.get(\"fill-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor), n);\n      }\n\n      isTileClipped() {\n        return !0;\n      }\n\n    },\n    \"fill-extrusion\": class extends Ms {\n      constructor(t) {\n        super(t, Ma);\n      }\n\n      createBucket(t) {\n        return new Ia(t);\n      }\n\n      queryRadius() {\n        return Ks(this.paint.get(\"fill-extrusion-translate\"));\n      }\n\n      is3D() {\n        return !0;\n      }\n\n      getProgramIds() {\n        return [this.paint.get(\"fill-extrusion-pattern\").constantOr(1) ? \"fillExtrusionPattern\" : \"fillExtrusion\"];\n      }\n\n      getProgramConfiguration(t) {\n        return new Ss(this, t);\n      }\n\n      queryIntersectsFeature(t, e, n, i, s, o, a, l, u) {\n        const c = Ws(this.paint.get(\"fill-extrusion-translate\"), this.paint.get(\"fill-extrusion-translate-anchor\"), o.angle, t.pixelToTileUnitsFactor),\n              h = this.paint.get(\"fill-extrusion-height\").evaluate(e, n),\n              p = this.paint.get(\"fill-extrusion-base\").evaluate(e, n),\n              f = [0, 0],\n              d = l && o.elevation,\n              y = o.elevation ? o.elevation.exaggeration() : 1;\n\n        if (d) {\n          const e = t.tile.getBucket(this).centroidVertexArray,\n                r = u + 1;\n\n          if (r < e.length) {\n            const t = e.get(r);\n            f[0] = t.a_centroid_pos0, f[1] = t.a_centroid_pos1;\n          }\n        }\n\n        if (0 === f[0] && 1 === f[1]) return !1;\n\n        const m = function (t, e, n, i, s, o, a, l, u) {\n          return o ? function (t, e, r, n, i, s, o, a, l) {\n            const u = [],\n                  c = [],\n                  h = [0, 0, 0];\n\n            for (const p of t) {\n              const t = [],\n                    f = [];\n\n              for (const u of p) {\n                const c = u.x + n.x,\n                      p = u.y + n.y,\n                      d = Va(c, p, e, r, s, o, a, l);\n                h[0] = c, h[1] = p, h[2] = d.base;\n                const y = Ca(ao(h, h, i));\n                h[0] = c, h[1] = p, h[2] = d.top;\n                const m = Ca(ao(h, h, i));\n                t.push(y), f.push(m);\n              }\n\n              u.push(t), c.push(f);\n            }\n\n            return [u, c];\n          }(t, e, n, i, s, o, a, l, u) : function (t, e, n, i, s) {\n            const o = [],\n                  a = [],\n                  l = s[8] * e,\n                  u = s[9] * e,\n                  c = s[10] * e,\n                  h = s[11] * e,\n                  p = s[8] * n,\n                  f = s[9] * n,\n                  d = s[10] * n,\n                  y = s[11] * n;\n\n            for (const e of t) {\n              const t = [],\n                    n = [];\n\n              for (const o of e) {\n                const e = o.x + i.x,\n                      a = o.y + i.y,\n                      m = s[0] * e + s[4] * a + s[12],\n                      g = s[1] * e + s[5] * a + s[13],\n                      x = s[2] * e + s[6] * a + s[14],\n                      v = s[3] * e + s[7] * a + s[15],\n                      b = x + c,\n                      w = v + h,\n                      _ = m + p,\n                      k = g + f,\n                      S = x + d,\n                      A = v + y,\n                      I = new r((m + l) / w, (g + u) / w);\n\n                I.z = b / w, t.push(I);\n                const z = new r(_ / A, k / A);\n                z.z = S / A, n.push(z);\n              }\n\n              o.push(t), a.push(n);\n            }\n\n            return [o, a];\n          }(t, e, n, i, s);\n        }(i, p, h, c, a, d ? l : null, f, y, o.center.lat),\n              g = t.queryGeometry;\n\n        return function (t, e, r) {\n          let n = 1 / 0;\n          Rs(r, e) && (n = Pa(r, e[0]));\n\n          for (let i = 0; i < e.length; i++) {\n            const s = e[i],\n                  o = t[i];\n\n            for (let t = 0; t < s.length - 1; t++) {\n              const e = s[t],\n                    i = [e, s[t + 1], o[t + 1], o[t], e];\n              Os(r, i) && (n = Math.min(n, Pa(r, i)));\n            }\n          }\n\n          return n !== 1 / 0 && n;\n        }(m[0], m[1], g.isPointQuery() ? g.screenBounds : g.screenGeometry);\n      }\n\n    },\n    line: class extends Ms {\n      constructor(t) {\n        super(t, qa), this.gradientVersion = 0;\n      }\n\n      _handleSpecialPaintPropertyUpdate(t) {\n        \"line-gradient\" === t && (this.stepInterpolant = this._transitionablePaint._values[\"line-gradient\"].value.expression._styleExpression.expression instanceof Ot, this.gradientVersion = (this.gradientVersion + 1) % s);\n      }\n\n      gradientExpression() {\n        return this._transitionablePaint._values[\"line-gradient\"].value.expression;\n      }\n\n      recalculate(t, e) {\n        super.recalculate(t, e), this.paint._values[\"line-floorwidth\"] = Ua.possiblyEvaluate(this._transitioningPaint._values[\"line-width\"].value, t);\n      }\n\n      createBucket(t) {\n        return new $a(t);\n      }\n\n      getProgramIds() {\n        const t = this.paint.get(\"line-dasharray\"),\n              e = this.paint.get(\"line-pattern\").constantOr(1),\n              r = this.paint.get(\"line-gradient\");\n        return [e ? \"linePattern\" : t ? \"lineSDF\" : r ? \"lineGradient\" : \"line\"];\n      }\n\n      getProgramConfiguration(t) {\n        return new Ss(this, t);\n      }\n\n      queryRadius(t) {\n        const e = t,\n              r = Na(Ys(\"line-width\", this, e), Ys(\"line-gap-width\", this, e)),\n              n = Ys(\"line-offset\", this, e);\n        return r / 2 + Math.abs(n) + Ks(this.paint.get(\"line-translate\"));\n      }\n\n      queryIntersectsFeature(t, e, n, i, s, o) {\n        if (t.queryGeometry.isAboveHorizon) return !1;\n        const a = Hs(t.tilespaceGeometry, this.paint.get(\"line-translate\"), this.paint.get(\"line-translate-anchor\"), o.angle, t.pixelToTileUnitsFactor),\n              l = t.pixelToTileUnitsFactor / 2 * Na(this.paint.get(\"line-width\").evaluate(e, n), this.paint.get(\"line-gap-width\").evaluate(e, n)),\n              u = this.paint.get(\"line-offset\").evaluate(e, n);\n        return u && (i = function (t, e) {\n          const n = [],\n                i = new r(0, 0);\n\n          for (let r = 0; r < t.length; r++) {\n            const s = t[r],\n                  o = [];\n\n            for (let t = 0; t < s.length; t++) {\n              const r = s[t - 1],\n                    n = s[t],\n                    a = s[t + 1],\n                    l = 0 === t ? i : n.sub(r)._unit()._perp(),\n                    u = t === s.length - 1 ? i : a.sub(n)._unit()._perp(),\n                    c = l._add(u)._unit();\n\n              c._mult(1 / (c.x * u.x + c.y * u.y)), o.push(c._mult(e)._add(n));\n            }\n\n            n.push(o);\n          }\n\n          return n;\n        }(i, u * t.pixelToTileUnitsFactor)), function (t, e, r) {\n          for (let n = 0; n < e.length; n++) {\n            const i = e[n];\n            if (t.length >= 3) for (let e = 0; e < i.length; e++) if (Xs(t, i[e])) return !0;\n            if (qs(t, i, r)) return !0;\n          }\n\n          return !1;\n        }(a, i, l);\n      }\n\n      isTileClipped() {\n        return !0;\n      }\n\n    },\n    symbol: zu,\n    background: class extends Ms {\n      constructor(t) {\n        super(t, Mu);\n      }\n\n      getProgramIds() {\n        return [this.paint.get(\"background-pattern\") ? \"backgroundPattern\" : \"background\"];\n      }\n\n    },\n    raster: class extends Ms {\n      constructor(t) {\n        super(t, Bu);\n      }\n\n      getProgramIds() {\n        return [\"raster\"];\n      }\n\n    },\n    sky: class extends Ms {\n      constructor(t) {\n        super(t, Cu), this._updateColorRamp();\n      }\n\n      _handleSpecialPaintPropertyUpdate(t) {\n        \"sky-gradient\" === t ? this._updateColorRamp() : \"sky-atmosphere-sun\" !== t && \"sky-atmosphere-halo-color\" !== t && \"sky-atmosphere-color\" !== t && \"sky-atmosphere-sun-intensity\" !== t || (this._skyboxInvalidated = !0);\n      }\n\n      _updateColorRamp() {\n        this.colorRamp = _o({\n          expression: this._transitionablePaint._values[\"sky-gradient\"].value.expression,\n          evaluationKey: \"skyRadialProgress\"\n        }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);\n      }\n\n      needsSkyboxCapture(t) {\n        if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;\n\n        if (!this.paint.get(\"sky-atmosphere-sun\")) {\n          const e = t.style.light.properties.get(\"position\");\n          return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;\n        }\n      }\n\n      getCenter(t, e) {\n        const r = this.paint.get(\"sky-type\");\n\n        if (\"atmosphere\" === r) {\n          const r = this.paint.get(\"sky-atmosphere-sun\"),\n                n = !r,\n                i = t.style.light,\n                s = i.properties.get(\"position\");\n          return n && \"viewport\" === i.properties.get(\"anchor\") && x(\"The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly.\"), n ? Vu(s.azimuthal, 90 - s.polar, e) : Vu(r[0], 90 - r[1], e);\n        }\n\n        if (\"gradient\" === r) {\n          const t = this.paint.get(\"sky-gradient-center\");\n          return Vu(t[0], 90 - t[1], e);\n        }\n      }\n\n      is3D() {\n        return !1;\n      }\n\n      isSky() {\n        return !0;\n      }\n\n      markSkyboxValid(t) {\n        this._skyboxInvalidated = !1, this._lightPosition = t.style.light.properties.get(\"position\");\n      }\n\n      hasOffscreenPass() {\n        return !0;\n      }\n\n      getProgramIds() {\n        const t = this.paint.get(\"sky-type\");\n        return \"atmosphere\" === t ? [\"skyboxCapture\", \"skybox\"] : \"gradient\" === t ? [\"skyboxGradient\"] : null;\n      }\n\n    }\n  };\n\n  function Eu(t) {\n    return \"custom\" === t.type ? new Pu(t) : new Tu[t.type](t);\n  }\n\n  var Du = [\"type\", \"source\", \"source-layer\", \"minzoom\", \"maxzoom\", \"filter\", \"layout\"];\n\n  function Fu(t) {\n    const e = typeof t;\n    if (\"number\" === e || \"boolean\" === e || \"string\" === e || null == t) return JSON.stringify(t);\n\n    if (Array.isArray(t)) {\n      let e = \"[\";\n\n      for (const r of t) e += `${Fu(r)},`;\n\n      return `${e}]`;\n    }\n\n    const r = Object.keys(t).sort();\n    let n = \"{\";\n\n    for (let e = 0; e < r.length; e++) n += `${JSON.stringify(r[e])}:${Fu(t[r[e]])},`;\n\n    return `${n}}`;\n  }\n\n  function Lu(t) {\n    let e = \"\";\n\n    for (const r of Du) e += `/${Fu(t[r])}`;\n\n    return e;\n  }\n\n  class Ou {\n    constructor(t) {\n      this.keyCache = {}, t && this.replace(t);\n    }\n\n    replace(t) {\n      this._layerConfigs = {}, this._layers = {}, this.update(t, []);\n    }\n\n    update(t, e) {\n      for (const e of t) {\n        this._layerConfigs[e.id] = e;\n        const t = this._layers[e.id] = Eu(e);\n        t._featureFilter = xr(t.filter), this.keyCache[e.id] && delete this.keyCache[e.id];\n      }\n\n      for (const t of e) delete this.keyCache[t], delete this._layerConfigs[t], delete this._layers[t];\n\n      this.familiesBySource = {};\n\n      const r = function (t, e) {\n        const r = {};\n\n        for (let n = 0; n < t.length; n++) {\n          const i = e && e[t[n].id] || Lu(t[n]);\n          e && (e[t[n].id] = i);\n          let s = r[i];\n          s || (s = r[i] = []), s.push(t[n]);\n        }\n\n        const n = [];\n\n        for (const t in r) n.push(r[t]);\n\n        return n;\n      }(u(this._layerConfigs), this.keyCache);\n\n      for (const t of r) {\n        const e = t.map(t => this._layers[t.id]),\n              r = e[0];\n        if (\"none\" === r.visibility) continue;\n        const n = r.source || \"\";\n        let i = this.familiesBySource[n];\n        i || (i = this.familiesBySource[n] = {});\n        const s = r.sourceLayer || \"_geojsonTileLayer\";\n        let o = i[s];\n        o || (o = i[s] = []), o.push(e);\n      }\n    }\n\n  }\n\n  class $u {\n    constructor(t) {\n      this._stringToNumber = {}, this._numberToString = [];\n\n      for (let e = 0; e < t.length; e++) {\n        const r = t[e];\n        this._stringToNumber[r] = e, this._numberToString[e] = r;\n      }\n    }\n\n    encode(t) {\n      return this._stringToNumber[t];\n    }\n\n    decode(t) {\n      return this._numberToString[t];\n    }\n\n  }\n\n  class Ru {\n    constructor(t, e, r, n, i) {\n      this.type = \"Feature\", this._vectorTileFeature = t, t._z = e, t._x = r, t._y = n, this.properties = t.properties, this.id = i;\n    }\n\n    get geometry() {\n      return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;\n    }\n\n    set geometry(t) {\n      this._geometry = t;\n    }\n\n    toJSON() {\n      const t = {\n        geometry: this.geometry\n      };\n\n      for (const e in this) \"_geometry\" !== e && \"_vectorTileFeature\" !== e && (t[e] = this[e]);\n\n      return t;\n    }\n\n  }\n\n  function qu(t, e, r) {\n    var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);\n    return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];\n  }\n\n  class Uu {\n    constructor(t, e) {\n      t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));\n    }\n\n    setNorthEast(t) {\n      return this._ne = t instanceof Nu ? new Nu(t.lng, t.lat) : Nu.convert(t), this;\n    }\n\n    setSouthWest(t) {\n      return this._sw = t instanceof Nu ? new Nu(t.lng, t.lat) : Nu.convert(t), this;\n    }\n\n    extend(t) {\n      const e = this._sw,\n            r = this._ne;\n      let n, i;\n      if (t instanceof Nu) n = t, i = t;else {\n        if (!(t instanceof Uu)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(Uu.convert(t)) : this.extend(Nu.convert(t)) : this;\n        if (n = t._sw, i = t._ne, !n || !i) return this;\n      }\n      return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new Nu(n.lng, n.lat), this._ne = new Nu(i.lng, i.lat)), this;\n    }\n\n    getCenter() {\n      return new Nu((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n    }\n\n    getSouthWest() {\n      return this._sw;\n    }\n\n    getNorthEast() {\n      return this._ne;\n    }\n\n    getNorthWest() {\n      return new Nu(this.getWest(), this.getNorth());\n    }\n\n    getSouthEast() {\n      return new Nu(this.getEast(), this.getSouth());\n    }\n\n    getWest() {\n      return this._sw.lng;\n    }\n\n    getSouth() {\n      return this._sw.lat;\n    }\n\n    getEast() {\n      return this._ne.lng;\n    }\n\n    getNorth() {\n      return this._ne.lat;\n    }\n\n    toArray() {\n      return [this._sw.toArray(), this._ne.toArray()];\n    }\n\n    toString() {\n      return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n    }\n\n    isEmpty() {\n      return !(this._sw && this._ne);\n    }\n\n    contains(t) {\n      const {\n        lng: e,\n        lat: r\n      } = Nu.convert(t);\n      let n = this._sw.lng <= e && e <= this._ne.lng;\n      return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;\n    }\n\n    static convert(t) {\n      return !t || t instanceof Uu ? t : new Uu(t);\n    }\n\n  }\n\n  class Nu {\n    constructor(t, e) {\n      if (isNaN(t) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t}, ${e})`);\n      if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error(\"Invalid LngLat latitude value: must be between -90 and 90\");\n    }\n\n    wrap() {\n      return new Nu(function (t, e, r) {\n        const n = ((t - -180) % 360 + 360) % 360 - 180;\n        return -180 === n ? 180 : n;\n      }(this.lng), this.lat);\n    }\n\n    toArray() {\n      return [this.lng, this.lat];\n    }\n\n    toString() {\n      return `LngLat(${this.lng}, ${this.lat})`;\n    }\n\n    distanceTo(t) {\n      const e = Math.PI / 180,\n            r = this.lat * e,\n            n = t.lat * e,\n            i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);\n      return 6371008.8 * Math.acos(Math.min(i, 1));\n    }\n\n    toBounds(t = 0) {\n      const e = 360 * t / 40075017,\n            r = e / Math.cos(Math.PI / 180 * this.lat);\n      return new Uu(new Nu(this.lng - r, this.lat - e), new Nu(this.lng + r, this.lat + e));\n    }\n\n    static convert(t) {\n      if (t instanceof Nu) return t;\n      if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new Nu(Number(t[0]), Number(t[1]));\n      if (!Array.isArray(t) && \"object\" == typeof t && null !== t) return new Nu(Number(\"lng\" in t ? t.lng : t.lon), Number(t.lat));\n      throw new Error(\"`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n    }\n\n  }\n\n  const ju = 2 * Math.PI * 6371008.8;\n\n  function Zu(t) {\n    return ju * Math.cos(t * Math.PI / 180);\n  }\n\n  function Gu(t, e) {\n    return t / Zu(e);\n  }\n\n  function Xu(t) {\n    return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;\n  }\n\n  function Ju(t, e) {\n    return t * Zu(Xu(e));\n  }\n\n  class Yu {\n    constructor(t, e, r = 0) {\n      this.x = +t, this.y = +e, this.z = +r;\n    }\n\n    static fromLngLat(t, e = 0) {\n      const r = Nu.convert(t);\n      return new Yu((180 + r.lng) / 360, (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r.lat * Math.PI / 360))) / 360, Gu(e, r.lat));\n    }\n\n    toLngLat() {\n      return new Nu(360 * this.x - 180, Xu(this.y));\n    }\n\n    toAltitude() {\n      return Ju(this.z, this.y);\n    }\n\n    meterInMercatorCoordinateUnits() {\n      return 1 / ju * (t = Xu(this.y), 1 / Math.cos(t * Math.PI / 180));\n      var t;\n    }\n\n  }\n\n  class Ku {\n    constructor(t, e, r) {\n      this.z = t, this.x = e, this.y = r, this.key = Qu(0, t, t, e, r);\n    }\n\n    equals(t) {\n      return this.z === t.z && this.x === t.x && this.y === t.y;\n    }\n\n    url(t, e) {\n      const r = (i = this.y, s = this.z, o = qu(256 * (n = this.x), 256 * (i = Math.pow(2, s) - i - 1), s), a = qu(256 * (n + 1), 256 * (i + 1), s), o[0] + \",\" + o[1] + \",\" + a[0] + \",\" + a[1]);\n      var n, i, s, o, a;\n\n      const l = function (t, e, r) {\n        let n,\n            i = \"\";\n\n        for (let s = t; s > 0; s--) n = 1 << s - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);\n\n        return i;\n      }(this.z, this.x, this.y);\n\n      return t[(this.x + this.y) % t.length].replace(\"{prefix}\", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(\"{z}\", String(this.z)).replace(\"{x}\", String(this.x)).replace(\"{y}\", String(\"tms\" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(\"{quadkey}\", l).replace(\"{bbox-epsg-3857}\", r);\n    }\n\n    getTilePoint(t) {\n      const e = Math.pow(2, this.z);\n      return new r(8192 * (t.x * e - this.x), 8192 * (t.y * e - this.y));\n    }\n\n    getTileVec3(t) {\n      const e = Math.pow(2, this.z);\n      return so(8192 * (t.x * e - this.x), 8192 * (t.y * e - this.y), Ju(t.z, t.y));\n    }\n\n    toString() {\n      return `${this.z}/${this.x}/${this.y}`;\n    }\n\n  }\n\n  class Hu {\n    constructor(t, e) {\n      this.wrap = t, this.canonical = e, this.key = Qu(t, e.z, e.z, e.x, e.y);\n    }\n\n  }\n\n  class Wu {\n    constructor(t, e, r, n, i) {\n      this.overscaledZ = t, this.wrap = e, this.canonical = new Ku(r, +n, +i), this.key = 0 === e && t === r ? this.canonical.key : Qu(e, t, r, n, i);\n    }\n\n    equals(t) {\n      return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);\n    }\n\n    scaledTo(t) {\n      const e = this.canonical.z - t;\n      return t > this.canonical.z ? new Wu(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Wu(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e);\n    }\n\n    calculateScaledKey(t, e = !0) {\n      if (this.overscaledZ === t && e) return this.key;\n      if (t > this.canonical.z) return Qu(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y);\n      {\n        const r = this.canonical.z - t;\n        return Qu(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r);\n      }\n    }\n\n    isChildOf(t) {\n      if (t.wrap !== this.wrap) return !1;\n      const e = this.canonical.z - t.canonical.z;\n      return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e;\n    }\n\n    children(t) {\n      if (this.overscaledZ >= t) return [new Wu(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n      const e = this.canonical.z + 1,\n            r = 2 * this.canonical.x,\n            n = 2 * this.canonical.y;\n      return [new Wu(e, this.wrap, e, r, n), new Wu(e, this.wrap, e, r + 1, n), new Wu(e, this.wrap, e, r, n + 1), new Wu(e, this.wrap, e, r + 1, n + 1)];\n    }\n\n    isLessThan(t) {\n      return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));\n    }\n\n    wrapped() {\n      return new Wu(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n    }\n\n    unwrapTo(t) {\n      return new Wu(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);\n    }\n\n    overscaleFactor() {\n      return Math.pow(2, this.overscaledZ - this.canonical.z);\n    }\n\n    toUnwrapped() {\n      return new Hu(this.wrap, this.canonical);\n    }\n\n    toString() {\n      return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;\n    }\n\n    getTilePoint(t) {\n      return this.canonical.getTilePoint(new Yu(t.x - this.wrap, t.y));\n    }\n\n    getTileVec3(t) {\n      return this.canonical.getTileVec3(new Yu(t.x - this.wrap, t.y, t.z));\n    }\n\n  }\n\n  function Qu(t, e, r, n, i) {\n    const s = 1 << Math.min(r, 22);\n    let o = s * (i % s) + n % s;\n    return t && r < 22 && (o += s * s * ((t < 0 ? -2 * t - 1 : 2 * t) % (1 << 2 * (22 - r)))), 16 * (32 * o + r) + (e - r);\n  }\n\n  Je(\"CanonicalTileID\", Ku), Je(\"OverscaledTileID\", Wu, {\n    omit: [\"posMatrix\"]\n  }), Ai([{\n    name: \"a_pos\",\n    type: \"Int16\",\n    components: 2\n  }]);\n\n  class tc {\n    constructor(t) {\n      this.size = t, this.minimums = [], this.maximums = [], this.leaves = [];\n    }\n\n    getElevation(t, e) {\n      const r = this.toIdx(t, e);\n      return {\n        min: this.minimums[r],\n        max: this.maximums[r]\n      };\n    }\n\n    isLeaf(t, e) {\n      return this.leaves[this.toIdx(t, e)];\n    }\n\n    toIdx(t, e) {\n      return e * this.size + t;\n    }\n\n  }\n\n  function ec(t, e, r, n) {\n    let i = 0,\n        s = Number.MAX_VALUE;\n\n    for (let o = 0; o < 3; o++) if (Math.abs(n[o]) < 1e-15) {\n      if (r[o] < t[o] || r[o] > e[o]) return null;\n    } else {\n      const a = 1 / n[o];\n      let l = (t[o] - r[o]) * a,\n          u = (e[o] - r[o]) * a;\n\n      if (l > u) {\n        const t = l;\n        l = u, u = t;\n      }\n\n      if (l > i && (i = l), u < s && (s = u), i > s) return null;\n    }\n\n    return i;\n  }\n\n  function rc(t, e, r, n, i, s, o, a, l, u, c) {\n    const h = n - t,\n          p = i - e,\n          f = s - r,\n          d = o - t,\n          y = a - e,\n          m = l - r,\n          g = c[1] * m - c[2] * y,\n          x = c[2] * d - c[0] * m,\n          v = c[0] * y - c[1] * d,\n          b = h * g + p * x + f * v;\n    if (Math.abs(b) < 1e-15) return null;\n\n    const w = 1 / b,\n          _ = u[0] - t,\n          k = u[1] - e,\n          S = u[2] - r,\n          A = (_ * g + k * x + S * v) * w;\n\n    if (A < 0 || A > 1) return null;\n    const I = k * f - S * p,\n          z = S * h - _ * f,\n          M = _ * p - k * h,\n          B = (c[0] * I + c[1] * z + c[2] * M) * w;\n    return B < 0 || A + B > 1 ? null : (d * I + y * z + m * M) * w;\n  }\n\n  function nc(t, e, r) {\n    return (t - e) / (r - e);\n  }\n\n  function ic(t, e, r, n, i, s, o, a, l) {\n    const u = 1 << r,\n          c = s - n,\n          h = o - i,\n          p = (t + 1) / u * c + n,\n          f = (e + 0) / u * h + i,\n          d = (e + 1) / u * h + i;\n    a[0] = (t + 0) / u * c + n, a[1] = f, l[0] = p, l[1] = d;\n  }\n\n  class sc {\n    constructor(t) {\n      if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;\n\n      const e = function (t) {\n        const e = Math.ceil(Math.log2(t.dim / 8)),\n              r = [];\n        let n = Math.ceil(Math.pow(2, e));\n\n        const i = 1 / n,\n              s = (t, e, r, n, i) => {\n          const s = n ? 1 : 0,\n                o = (t + 1) * r - s,\n                a = e * r,\n                l = (e + 1) * r - s;\n          i[0] = t * r, i[1] = a, i[2] = o, i[3] = l;\n        };\n\n        let o = new tc(n);\n        const a = [];\n\n        for (let e = 0; e < n * n; e++) {\n          s(e % n, Math.floor(e / n), i, !1, a);\n          const r = ac(a[0], a[1], t),\n                l = ac(a[2], a[1], t),\n                u = ac(a[2], a[3], t),\n                c = ac(a[0], a[3], t);\n          o.minimums.push(Math.min(r, l, u, c)), o.maximums.push(Math.max(r, l, u, c)), o.leaves.push(1);\n        }\n\n        for (r.push(o), n /= 2; n >= 1; n /= 2) {\n          const t = r[r.length - 1];\n          o = new tc(n);\n\n          for (let e = 0; e < n * n; e++) {\n            s(e % n, Math.floor(e / n), 2, !0, a);\n            const r = t.getElevation(a[0], a[1]),\n                  i = t.getElevation(a[2], a[1]),\n                  l = t.getElevation(a[2], a[3]),\n                  u = t.getElevation(a[0], a[3]),\n                  c = t.isLeaf(a[0], a[1]),\n                  h = t.isLeaf(a[2], a[1]),\n                  p = t.isLeaf(a[2], a[3]),\n                  f = t.isLeaf(a[0], a[3]),\n                  d = Math.min(r.min, i.min, l.min, u.min),\n                  y = Math.max(r.max, i.max, l.max, u.max),\n                  m = c && h && p && f;\n            o.maximums.push(y), o.minimums.push(d), o.leaves.push(y - d <= 5 && m ? 1 : 0);\n          }\n\n          r.push(o);\n        }\n\n        return r;\n      }(this.dem),\n            r = e.length - 1,\n            n = e[r];\n\n      this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e, 0, 0, r, 0);\n    }\n\n    raycastRoot(t, e, r, n, i, s, o = 1) {\n      return ec([t, e, -100], [r, n, this.maximums[0] * o], i, s);\n    }\n\n    raycast(t, e, r, n, i, s, o = 1) {\n      if (!this.nodeCount) return null;\n      const a = this.raycastRoot(t, e, r, n, i, s, o);\n      if (null == a) return null;\n      const l = [],\n            u = [],\n            c = [],\n            h = [],\n            p = [{\n        idx: 0,\n        t: a,\n        nodex: 0,\n        nodey: 0,\n        depth: 0\n      }];\n\n      for (; p.length > 0;) {\n        const {\n          idx: a,\n          t: f,\n          nodex: d,\n          nodey: y,\n          depth: m\n        } = p.pop();\n\n        if (this.leaves[a]) {\n          ic(d, y, m, t, e, r, n, c, h);\n\n          const a = 1 << m,\n                l = (d + 0) / a,\n                u = (d + 1) / a,\n                p = (y + 0) / a,\n                g = (y + 1) / a,\n                x = ac(l, p, this.dem) * o,\n                v = ac(u, p, this.dem) * o,\n                b = ac(u, g, this.dem) * o,\n                w = ac(l, g, this.dem) * o,\n                _ = rc(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, s),\n                k = rc(h[0], h[1], b, c[0], h[1], w, c[0], c[1], x, i, s),\n                S = Math.min(null !== _ ? _ : Number.MAX_VALUE, null !== k ? k : Number.MAX_VALUE);\n\n          if (S !== Number.MAX_VALUE) return S;\n          {\n            const t = oo([], i, s, f);\n            if (oc(x, v, w, b, nc(t[0], c[0], h[0]), nc(t[1], c[1], h[1])) >= t[2]) return f;\n          }\n          continue;\n        }\n\n        let g = 0;\n\n        for (let p = 0; p < this._siblingOffset.length; p++) {\n          ic((d << 1) + this._siblingOffset[p][0], (y << 1) + this._siblingOffset[p][1], m + 1, t, e, r, n, c, h), c[2] = -100, h[2] = this.maximums[this.childOffsets[a] + p] * o;\n          const f = ec(c, h, i, s);\n\n          if (null != f) {\n            const t = f;\n            l[p] = t;\n            let e = !1;\n\n            for (let r = 0; r < g && !e; r++) t >= l[u[r]] && (u.splice(r, 0, p), e = !0);\n\n            e || (u[g] = p), g++;\n          }\n        }\n\n        for (let t = 0; t < g; t++) {\n          const e = u[t];\n          p.push({\n            idx: this.childOffsets[a] + e,\n            t: l[e],\n            nodex: (d << 1) + this._siblingOffset[e][0],\n            nodey: (y << 1) + this._siblingOffset[e][1],\n            depth: m + 1\n          });\n        }\n      }\n\n      return null;\n    }\n\n    _addNode(t, e, r) {\n      return this.minimums.push(t), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;\n    }\n\n    _construct(t, e, r, n, i) {\n      if (1 === t[n].isLeaf(e, r)) return;\n      this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);\n      const s = n - 1,\n            o = t[s];\n      let a,\n          l = 0;\n\n      for (let t = 0; t < this._siblingOffset.length; t++) {\n        const n = 2 * e + this._siblingOffset[t][0],\n              i = 2 * r + this._siblingOffset[t][1],\n              s = o.getElevation(n, i),\n              u = o.isLeaf(n, i),\n              c = this._addNode(s.min, s.max, u);\n\n        u && (l |= 1 << t), a || (a = c);\n      }\n\n      for (let n = 0; n < this._siblingOffset.length; n++) l & 1 << n || this._construct(t, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, a + n);\n    }\n\n  }\n\n  function oc(t, e, r, n, i, s) {\n    return $t($t(t, r, s), $t(e, n, s), i);\n  }\n\n  function ac(t, e, r) {\n    const n = r.dim,\n          i = l(t * n - .5, 0, n - 1),\n          s = l(e * n - .5, 0, n - 1),\n          o = Math.floor(i),\n          a = Math.floor(s),\n          u = Math.min(o + 1, n - 1),\n          c = Math.min(a + 1, n - 1);\n    return oc(r.get(o, a), r.get(u, a), r.get(o, c), r.get(u, c), i - o, s - a);\n  }\n\n  const lc = {\n    mapbox: [6553.6, 25.6, .1, 1e4],\n    terrarium: [256, 1, 1 / 256, 32768]\n  };\n\n  class uc {\n    get tree() {\n      return this._tree || this._buildQuadTree(), this._tree;\n    }\n\n    constructor(t, e, r, n = !1, i = !1) {\n      if (this.uid = t, e.height !== e.width) throw new RangeError(\"DEM tiles must be square\");\n      if (r && \"mapbox\" !== r && \"terrarium\" !== r) return x(`\"${r}\" is not a valid encoding type. Valid types include \"mapbox\" and \"terrarium\".`);\n      this.stride = e.height;\n      const s = this.dim = e.height - 2;\n\n      if (this.data = new Uint32Array(e.data.buffer), this.encoding = r || \"mapbox\", this.borderReady = n, !n) {\n        for (let t = 0; t < s; t++) this.data[this._idx(-1, t)] = this.data[this._idx(0, t)], this.data[this._idx(s, t)] = this.data[this._idx(s - 1, t)], this.data[this._idx(t, -1)] = this.data[this._idx(t, 0)], this.data[this._idx(t, s)] = this.data[this._idx(t, s - 1)];\n\n        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(s, -1)] = this.data[this._idx(s - 1, 0)], this.data[this._idx(-1, s)] = this.data[this._idx(0, s - 1)], this.data[this._idx(s, s)] = this.data[this._idx(s - 1, s - 1)], i && this._buildQuadTree();\n      }\n    }\n\n    _buildQuadTree() {\n      this._tree = new sc(this);\n    }\n\n    get(t, e, r = !1) {\n      const n = new Uint8Array(this.data.buffer);\n      r && (t = l(t, -1, this.dim), e = l(e, -1, this.dim));\n\n      const i = 4 * this._idx(t, e);\n\n      return (\"terrarium\" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(n[i], n[i + 1], n[i + 2]);\n    }\n\n    static getUnpackVector(t) {\n      return lc[t];\n    }\n\n    get unpackVector() {\n      return lc[this.encoding];\n    }\n\n    _idx(t, e) {\n      if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError(\"out of range source coordinates for DEM data\");\n      return (e + 1) * this.stride + (t + 1);\n    }\n\n    _unpackMapbox(t, e, r) {\n      return (256 * t * 256 + 256 * e + r) / 10 - 1e4;\n    }\n\n    _unpackTerrarium(t, e, r) {\n      return 256 * t + e + r / 256 - 32768;\n    }\n\n    static pack(t, e) {\n      const r = [0, 0, 0, 0],\n            n = uc.getUnpackVector(e);\n      let i = Math.floor((t + n[3]) / n[2]);\n      return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;\n    }\n\n    getPixels() {\n      return new bo({\n        width: this.stride,\n        height: this.stride\n      }, new Uint8Array(this.data.buffer));\n    }\n\n    backfillBorder(t, e, r) {\n      if (this.dim !== t.dim) throw new Error(\"dem dimension mismatch\");\n      let n = e * this.dim,\n          i = e * this.dim + this.dim,\n          s = r * this.dim,\n          o = r * this.dim + this.dim;\n\n      switch (e) {\n        case -1:\n          n = i - 1;\n          break;\n\n        case 1:\n          i = n + 1;\n      }\n\n      switch (r) {\n        case -1:\n          s = o - 1;\n          break;\n\n        case 1:\n          o = s + 1;\n      }\n\n      const a = -e * this.dim,\n            l = -r * this.dim;\n\n      for (let e = s; e < o; e++) for (let r = n; r < i; r++) this.data[this._idx(r, e)] = t.data[this._idx(r + a, e + l)];\n    }\n\n    onDeserialize() {\n      this._tree && (this._tree.dem = this);\n    }\n\n  }\n\n  Je(\"DEMData\", uc), Je(\"DemMinMaxQuadTree\", sc, {\n    omit: [\"dem\"]\n  });\n\n  class cc {\n    constructor(t, e, r) {\n      this._demTile = t, this._dem = this._demTile.dem, this._scale = e, this._offset = r;\n    }\n\n    static create(t, e, r) {\n      const n = r || t.findDEMTileFor(e);\n      if (!n || !n.dem) return;\n      const i = n.dem,\n            s = n.tileID,\n            o = 1 << e.canonical.z - s.canonical.z;\n      return new cc(n, n.tileSize / 8192 / o, [(e.canonical.x / o - s.canonical.x) * i.dim, (e.canonical.y / o - s.canonical.y) * i.dim]);\n    }\n\n    tileCoordToPixel(t, e) {\n      const n = e * this._scale + this._offset[1],\n            i = Math.floor(t * this._scale + this._offset[0]),\n            s = Math.floor(n);\n      return new r(i, s);\n    }\n\n    getElevationAt(t, e, r, n) {\n      const i = t * this._scale + this._offset[0],\n            s = e * this._scale + this._offset[1],\n            o = Math.floor(i),\n            a = Math.floor(s),\n            l = this._dem;\n      return n = !!n, r ? $t($t(l.get(o, a, n), l.get(o, a + 1, n), s - a), $t(l.get(o + 1, a, n), l.get(o + 1, a + 1, n), s - a), i - o) : l.get(o, a, n);\n    }\n\n    getElevationAtPixel(t, e, r) {\n      return this._dem.get(t, e, !!r);\n    }\n\n    getMeterToDEM(t) {\n      return (1 << this._demTile.tileID.canonical.z) * Gu(1, t) * this._dem.stride;\n    }\n\n  }\n\n  class hc {\n    constructor(t, e) {\n      this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new I(8192, 16, 0), this.featureIndexArray = new ns(), this.promoteId = e;\n    }\n\n    insert(t, e, r, n, i, s = 0) {\n      const o = this.featureIndexArray.length;\n      this.featureIndexArray.emplaceBack(r, n, i, s);\n      const a = this.grid;\n\n      for (let t = 0; t < e.length; t++) {\n        const r = e[t],\n              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n\n        for (let t = 0; t < r.length; t++) {\n          const e = r[t];\n          n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);\n        }\n\n        n[0] < 8192 && n[1] < 8192 && n[2] >= 0 && n[3] >= 0 && a.insert(o, n[0], n[1], n[2], n[3]);\n      }\n    }\n\n    loadVTLayers() {\n      return this.vtLayers || (this.vtLayers = new wa.VectorTile(new rl(this.rawTileData)).layers, this.sourceLayerCoder = new $u(this.vtLayers ? Object.keys(this.vtLayers).sort() : [\"_geojsonTileLayer\"])), this.vtLayers;\n    }\n\n    query(t, e, n, i) {\n      this.loadVTLayers();\n      const s = t.params || {},\n            o = xr(s.filter),\n            a = t.tileResult,\n            l = t.transform,\n            u = a.bufferedTilespaceBounds,\n            c = this.grid.query(u.min.x, u.min.y, u.max.x, u.max.y, (t, e, n, i) => function (t, e, n, i, s) {\n        for (const r of t) if (e <= r.x && n <= r.y && i >= r.x && s >= r.y) return !0;\n\n        const o = [new r(e, n), new r(e, s), new r(i, s), new r(i, n)];\n        if (t.length > 2) for (const e of o) if (Xs(t, e)) return !0;\n\n        for (let e = 0; e < t.length - 1; e++) if (Js(t[e], t[e + 1], o)) return !0;\n\n        return !1;\n      }(a.bufferedTilespaceGeometry, t, e, n, i));\n      c.sort(fc);\n      let h = null;\n      l.elevation && c.length > 0 && (h = cc.create(l.elevation, this.tileID));\n      const p = {};\n      let f;\n\n      for (let r = 0; r < c.length; r++) {\n        const l = c[r];\n        if (l === f) continue;\n        f = l;\n        const u = this.featureIndexArray.get(l);\n        let d = null;\n        this.loadMatchingFeature(p, u, o, s.layers, s.availableImages, e, n, i, (e, r, n, i = 0) => (d || (d = Es(e)), r.queryIntersectsFeature(a, e, n, d, this.z, t.transform, t.pixelPosMatrix, h, i)));\n      }\n\n      return p;\n    }\n\n    loadMatchingFeature(t, e, r, n, i, s, o, a, l) {\n      const {\n        featureIndex: u,\n        bucketIndex: h,\n        sourceLayerIndex: p,\n        layoutVertexArrayOffset: f\n      } = e,\n            d = this.bucketLayerIDs[h];\n      if (n && !function (t, e) {\n        for (let r = 0; r < t.length; r++) if (e.indexOf(t[r]) >= 0) return !0;\n\n        return !1;\n      }(n, d)) return;\n      const y = this.sourceLayerCoder.decode(p),\n            m = this.vtLayers[y].feature(u);\n\n      if (r.needGeometry) {\n        const t = Ds(m, !0);\n        if (!r.filter(new oi(this.tileID.overscaledZ), t, this.tileID.canonical)) return;\n      } else if (!r.filter(new oi(this.tileID.overscaledZ), m)) return;\n\n      const g = this.getId(m, y);\n\n      for (let e = 0; e < d.length; e++) {\n        const r = d[e];\n        if (n && n.indexOf(r) < 0) continue;\n        const h = s[r];\n        if (!h) continue;\n        let p = {};\n        void 0 !== g && a && (p = a.getState(h.sourceLayer || \"_geojsonTileLayer\", g));\n        const y = c({}, o[r]);\n        y.paint = pc(y.paint, h.paint, m, p, i), y.layout = pc(y.layout, h.layout, m, p, i);\n        const x = !l || l(m, h, p, f);\n        if (!x) continue;\n        const v = new Ru(m, this.z, this.x, this.y, g);\n        v.layer = y;\n        let b = t[r];\n        void 0 === b && (b = t[r] = []), b.push({\n          featureIndex: u,\n          feature: v,\n          intersectionZ: x\n        });\n      }\n    }\n\n    lookupSymbolFeatures(t, e, r, n, i, s, o, a) {\n      const l = {};\n      this.loadVTLayers();\n      const u = xr(i);\n\n      for (const i of t) this.loadMatchingFeature(l, {\n        bucketIndex: r,\n        sourceLayerIndex: n,\n        featureIndex: i,\n        layoutVertexArrayOffset: 0\n      }, u, s, o, a, e);\n\n      return l;\n    }\n\n    hasLayer(t) {\n      for (const e of this.bucketLayerIDs) for (const r of e) if (t === r) return !0;\n\n      return !1;\n    }\n\n    getId(t, e) {\n      let r = t.id;\n      return this.promoteId && (r = t.properties[\"string\" == typeof this.promoteId ? this.promoteId : this.promoteId[e]], \"boolean\" == typeof r && (r = Number(r))), r;\n    }\n\n  }\n\n  function pc(t, e, r, n, i) {\n    return y(t, (t, s) => {\n      const o = e instanceof di ? e.get(s) : null;\n      return o && o.evaluate ? o.evaluate(r, n, i) : o;\n    });\n  }\n\n  function fc(t, e) {\n    return e - t;\n  }\n\n  Je(\"FeatureIndex\", hc, {\n    omit: [\"rawTileData\", \"sourceLayerCoder\"]\n  });\n\n  class dc {\n    constructor(t) {\n      const e = {},\n            r = [];\n\n      for (const n in t) {\n        const i = t[n],\n              s = e[n] = {};\n\n        for (const t in i) {\n          const e = i[+t];\n          if (!e || 0 === e.bitmap.width || 0 === e.bitmap.height) continue;\n          const n = e.metrics.localGlyph ? 2 : 1,\n                o = {\n            x: 0,\n            y: 0,\n            w: e.bitmap.width + 2 * n,\n            h: e.bitmap.height + 2 * n\n          };\n          r.push(o), s[t] = {\n            rect: o,\n            metrics: e.metrics\n          };\n        }\n      }\n\n      const {\n        w: n,\n        h: i\n      } = bl(r),\n            s = new vo({\n        width: n || 1,\n        height: i || 1\n      });\n\n      for (const r in t) {\n        const n = t[r];\n\n        for (const t in n) {\n          const i = n[+t];\n          if (!i || 0 === i.bitmap.width || 0 === i.bitmap.height) continue;\n          const o = e[r][t].rect,\n                a = i.metrics.localGlyph ? 2 : 1;\n          vo.copy(i.bitmap, s, {\n            x: 0,\n            y: 0\n          }, {\n            x: o.x + a,\n            y: o.y + a\n          }, i.bitmap);\n        }\n      }\n\n      this.image = s, this.positions = e;\n    }\n\n  }\n\n  Je(\"GlyphAtlas\", dc);\n\n  class yc {\n    constructor(t) {\n      this.tileID = new Wu(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.tileZoom = t.tileZoom, this.uid = t.uid, this.zoom = t.zoom, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming, this.returnDependencies = !!t.returnDependencies, this.promoteId = t.promoteId, this.enableTerrain = !!t.enableTerrain, this.isSymbolTile = t.isSymbolTile;\n    }\n\n    parse(t, e, r, n, i) {\n      this.status = \"parsing\", this.data = t, this.collisionBoxArray = new Yi();\n      const s = new $u(Object.keys(t.layers).sort()),\n            o = new hc(this.tileID, this.promoteId);\n      o.bucketLayerIDs = [];\n      const a = {},\n            l = {\n        featureIndex: o,\n        iconDependencies: {},\n        patternDependencies: {},\n        glyphDependencies: {},\n        availableImages: r\n      },\n            c = e.familiesBySource[this.source];\n\n      for (const e in c) {\n        const n = t.layers[e];\n        if (!n) continue;\n        let i = !1,\n            u = !1;\n\n        for (const t of c[e]) \"symbol\" === t[0].type ? i = !0 : u = !0;\n\n        if (!0 === this.isSymbolTile && !i) continue;\n        if (!1 === this.isSymbolTile && !u) continue;\n        1 === n.version && x(`Vector tile source \"${this.source}\" layer \"${e}\" ` + \"does not use vector tile spec v2 and therefore may have some rendering errors.\");\n        const h = s.encode(e),\n              p = [];\n\n        for (let t = 0; t < n.length; t++) {\n          const r = n.feature(t),\n                i = o.getId(r, e);\n          p.push({\n            feature: r,\n            id: i,\n            index: t,\n            sourceLayerIndex: h\n          });\n        }\n\n        for (const t of c[e]) {\n          const e = t[0];\n          void 0 !== this.isSymbolTile && \"symbol\" === e.type !== this.isSymbolTile || e.minzoom && this.zoom < Math.floor(e.minzoom) || e.maxzoom && this.zoom >= e.maxzoom || \"none\" !== e.visibility && (mc(t, this.zoom, r), (a[e.id] = e.createBucket({\n            index: o.bucketLayerIDs.length,\n            layers: t,\n            zoom: this.zoom,\n            pixelRatio: this.pixelRatio,\n            overscaling: this.overscaling,\n            collisionBoxArray: this.collisionBoxArray,\n            sourceLayerIndex: h,\n            sourceID: this.source,\n            enableTerrain: this.enableTerrain\n          })).populate(p, l, this.tileID.canonical), o.bucketLayerIDs.push(t.map(t => t.id)));\n        }\n      }\n\n      let h, p, f, d;\n      const m = {\n        type: \"maybePrepare\",\n        isSymbolTile: this.isSymbolTile,\n        zoom: this.zoom\n      },\n            g = y(l.glyphDependencies, t => Object.keys(t).map(Number));\n      Object.keys(g).length ? n.send(\"getGlyphs\", {\n        uid: this.uid,\n        stacks: g\n      }, (t, e) => {\n        h || (h = t, p = e, w.call(this));\n      }, void 0, void 0, m) : p = {};\n      const v = Object.keys(l.iconDependencies);\n      v.length ? n.send(\"getImages\", {\n        icons: v,\n        source: this.source,\n        tileID: this.tileID,\n        type: \"icons\"\n      }, (t, e) => {\n        h || (h = t, f = e, w.call(this));\n      }, void 0, void 0, m) : f = {};\n      const b = Object.keys(l.patternDependencies);\n\n      function w() {\n        if (h) return i(h);\n\n        if (p && f && d) {\n          const t = new dc(p),\n                e = new _l(f, d);\n\n          for (const n in a) {\n            const i = a[n];\n            i instanceof ku ? (mc(i.layers, this.zoom, r), lu(i, p, t.positions, f, e.iconPositions, this.showCollisionBoxes, this.tileID.canonical, this.tileZoom)) : i.hasPattern && (i instanceof $a || i instanceof aa || i instanceof Ia) && (mc(i.layers, this.zoom, r), i.addFeatures(l, this.tileID.canonical, e.patternPositions));\n          }\n\n          this.status = \"done\", i(null, {\n            buckets: u(a).filter(t => !t.isEmpty()),\n            featureIndex: o,\n            collisionBoxArray: this.collisionBoxArray,\n            glyphAtlasImage: t.image,\n            imageAtlas: e,\n            glyphMap: this.returnDependencies ? p : null,\n            iconMap: this.returnDependencies ? f : null,\n            glyphPositions: this.returnDependencies ? t.positions : null\n          });\n        }\n      }\n\n      b.length ? n.send(\"getImages\", {\n        icons: b,\n        source: this.source,\n        tileID: this.tileID,\n        type: \"patterns\"\n      }, (t, e) => {\n        h || (h = t, d = e, w.call(this));\n      }, void 0, void 0, m) : d = {}, w.call(this);\n    }\n\n  }\n\n  function mc(t, e, r) {\n    const n = new oi(e);\n\n    for (const e of t) e.recalculate(n, r);\n  }\n\n  class gc {\n    constructor(t) {\n      this.entries = {}, this.scheduler = t;\n    }\n\n    request(t, e, r, n) {\n      const i = this.entries[t] = this.entries[t] || {\n        callbacks: []\n      };\n\n      if (i.result) {\n        const [t, r] = i.result;\n        return this.scheduler ? this.scheduler.add(() => {\n          n(t, r);\n        }, e) : n(t, r), () => {};\n      }\n\n      return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n) => {\n        i.result = [r, n];\n\n        for (const t of i.callbacks) this.scheduler ? this.scheduler.add(() => {\n          t(r, n);\n        }, e) : t(r, n);\n\n        setTimeout(() => delete this.entries[t], 3e3);\n      })), () => {\n        i.result || (i.callbacks = i.callbacks.filter(t => t !== n), i.callbacks.length || (i.cancel(), delete this.entries[t]));\n      };\n    }\n\n  }\n\n  function xc(t, e, r) {\n    const n = JSON.stringify(t.request);\n    return t.data && (this.deduped.entries[n] = {\n      result: [null, t.data]\n    }), this.deduped.request(n, {\n      type: \"parseTile\",\n      isSymbolTile: t.isSymbolTile,\n      zoom: t.tileZoom\n    }, e => {\n      const n = function (t, e) {\n        return ti(c(t, {\n          type: \"arrayBuffer\"\n        }), e);\n      }(t.request, (t, n, i, s) => {\n        t ? e(t) : n && e(null, {\n          vectorTile: r ? void 0 : new wa.VectorTile(new rl(n)),\n          rawData: n,\n          cacheControl: i,\n          expires: s\n        });\n      });\n\n      return () => {\n        n.cancel(), e();\n      };\n    }, e);\n  }\n\n  class vc extends Zr {\n    constructor(t, e, r, n, i) {\n      super(), this.actor = t, this.layerIndex = e, this.availableImages = r, this.loadVectorData = i || xc, this.loading = {}, this.loaded = {}, this.deduped = new gc(t.scheduler), this.isSpriteLoaded = n, this.scheduler = t.scheduler;\n    }\n\n    loadTile(t, e) {\n      const r = t.uid,\n            n = !!(t && t.request && t.request.collectResourceTiming) && new er(t.request),\n            i = this.loading[r] = new yc(t);\n      i.abort = this.loadVectorData(t, (s, o) => {\n        const a = !this.loading[r];\n        if (delete this.loading[r], a || s || !o) return i.status = \"done\", a || (this.loaded[r] = i), e(s);\n        const l = o.rawData,\n              u = {};\n        o.expires && (u.expires = o.expires), o.cacheControl && (u.cacheControl = o.cacheControl);\n        const h = {};\n\n        if (n) {\n          const t = n.finish();\n          t && (h.resourceTiming = JSON.parse(JSON.stringify(t)));\n        }\n\n        i.vectorTile = o.vectorTile || new wa.VectorTile(new rl(l));\n\n        const p = () => {\n          i.parse(i.vectorTile, this.layerIndex, this.availableImages, this.actor, (t, r) => {\n            if (t || !r) return e(t);\n            e(null, c({\n              rawTileData: l.slice(0)\n            }, r, u, h));\n          });\n        };\n\n        this.isSpriteLoaded ? p() : this.once(\"isSpriteLoaded\", () => {\n          this.scheduler ? this.scheduler.add(p, {\n            type: \"parseTile\",\n            isSymbolTile: t.isSymbolTile,\n            zoom: t.tileZoom\n          }) : p();\n        }), this.loaded = this.loaded || {}, this.loaded[r] = i;\n      });\n    }\n\n    reloadTile(t, e) {\n      const r = this.loaded,\n            n = t.uid,\n            i = this;\n\n      if (r && r[n]) {\n        const s = r[n];\n        s.showCollisionBoxes = t.showCollisionBoxes, s.enableTerrain = !!t.enableTerrain;\n\n        const o = (t, r) => {\n          const n = s.reloadCallback;\n          n && (delete s.reloadCallback, s.parse(s.vectorTile, i.layerIndex, this.availableImages, i.actor, n)), e(t, r);\n        };\n\n        \"parsing\" === s.status ? s.reloadCallback = o : \"done\" === s.status && (s.vectorTile ? s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, o) : o());\n      }\n    }\n\n    abortTile(t, e) {\n      const r = t.uid,\n            n = this.loading[r];\n      n && (n.abort && n.abort(), delete this.loading[r]), e();\n    }\n\n    removeTile(t, e) {\n      const r = this.loaded,\n            n = t.uid;\n      r && r[n] && delete r[n], e();\n    }\n\n  }\n\n  const {\n    ImageBitmap: bc\n  } = i;\n\n  class wc {\n    loadTile(t, e) {\n      const {\n        uid: r,\n        encoding: n,\n        rawImageData: i,\n        padding: s,\n        buildQuadTree: o\n      } = t,\n            a = bc && i instanceof bc ? this.getImageData(i, s) : i;\n      e(null, new uc(r, a, n, s < 1, o));\n    }\n\n    getImageData(t, e) {\n      this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t.width, t.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext(\"2d\")), this.offscreenCanvas.width = t.width, this.offscreenCanvas.height = t.height, this.offscreenCanvasContext.drawImage(t, 0, 0, t.width, t.height);\n      const r = this.offscreenCanvasContext.getImageData(-e, -e, t.width + 2 * e, t.height + 2 * e);\n      return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new bo({\n        width: r.width,\n        height: r.height\n      }, r.data);\n    }\n\n  }\n\n  function _c(t, e) {\n    if (0 !== t.length) {\n      kc(t[0], e);\n\n      for (var r = 1; r < t.length; r++) kc(t[r], !e);\n    }\n  }\n\n  function kc(t, e) {\n    for (var r = 0, n = 0, i = t.length, s = i - 1; n < i; s = n++) r += (t[n][0] - t[s][0]) * (t[s][1] + t[n][1]);\n\n    r >= 0 != !!e && t.reverse();\n  }\n\n  const Sc = wa.VectorTileFeature.prototype.toGeoJSON;\n\n  class Ac {\n    constructor(t) {\n      this._feature = t, this.extent = 8192, this.type = t.type, this.properties = t.tags, \"id\" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));\n    }\n\n    loadGeometry() {\n      if (1 === this._feature.type) {\n        const t = [];\n\n        for (const e of this._feature.geometry) t.push([new r(e[0], e[1])]);\n\n        return t;\n      }\n\n      {\n        const t = [];\n\n        for (const e of this._feature.geometry) {\n          const n = [];\n\n          for (const t of e) n.push(new r(t[0], t[1]));\n\n          t.push(n);\n        }\n\n        return t;\n      }\n    }\n\n    toGeoJSON(t, e, r) {\n      return Sc.call(this, t, e, r);\n    }\n\n  }\n\n  class Ic {\n    constructor(t) {\n      this.layers = {\n        _geojsonTileLayer: this\n      }, this.name = \"_geojsonTileLayer\", this.extent = 8192, this.length = t.length, this._features = t;\n    }\n\n    feature(t) {\n      return new Ac(this._features[t]);\n    }\n\n  }\n\n  var zc = wa.VectorTileFeature,\n      Mc = Bc;\n\n  function Bc(t, e) {\n    this.options = e || {}, this.features = t, this.length = t.length;\n  }\n\n  function Pc(t, e) {\n    this.id = \"number\" == typeof t.id ? t.id : void 0, this.type = t.type, this.rawGeometry = 1 === t.type ? [t.geometry] : t.geometry, this.properties = t.tags, this.extent = e || 4096;\n  }\n\n  Bc.prototype.feature = function (t) {\n    return new Pc(this.features[t], this.options.extent);\n  }, Pc.prototype.loadGeometry = function () {\n    var t = this.rawGeometry;\n    this.geometry = [];\n\n    for (var e = 0; e < t.length; e++) {\n      for (var n = t[e], i = [], s = 0; s < n.length; s++) i.push(new r(n[s][0], n[s][1]));\n\n      this.geometry.push(i);\n    }\n\n    return this.geometry;\n  }, Pc.prototype.bbox = function () {\n    this.geometry || this.loadGeometry();\n\n    for (var t = this.geometry, e = 1 / 0, r = -1 / 0, n = 1 / 0, i = -1 / 0, s = 0; s < t.length; s++) for (var o = t[s], a = 0; a < o.length; a++) {\n      var l = o[a];\n      e = Math.min(e, l.x), r = Math.max(r, l.x), n = Math.min(n, l.y), i = Math.max(i, l.y);\n    }\n\n    return [e, n, r, i];\n  }, Pc.prototype.toGeoJSON = zc.prototype.toGeoJSON;\n  var Cc = Tc,\n      Vc = Mc;\n\n  function Tc(t) {\n    var e = new rl();\n    return function (t, e) {\n      for (var r in t.layers) e.writeMessage(3, Ec, t.layers[r]);\n    }(t, e), e.finish();\n  }\n\n  function Ec(t, e) {\n    var r;\n    e.writeVarintField(15, t.version || 1), e.writeStringField(1, t.name || \"\"), e.writeVarintField(5, t.extent || 4096);\n    var n = {\n      keys: [],\n      values: [],\n      keycache: {},\n      valuecache: {}\n    };\n\n    for (r = 0; r < t.length; r++) n.feature = t.feature(r), e.writeMessage(2, Dc, n);\n\n    var i = n.keys;\n\n    for (r = 0; r < i.length; r++) e.writeStringField(3, i[r]);\n\n    var s = n.values;\n\n    for (r = 0; r < s.length; r++) e.writeMessage(4, Rc, s[r]);\n  }\n\n  function Dc(t, e) {\n    var r = t.feature;\n    void 0 !== r.id && e.writeVarintField(1, r.id), e.writeMessage(2, Fc, t), e.writeVarintField(3, r.type), e.writeMessage(4, $c, r);\n  }\n\n  function Fc(t, e) {\n    var r = t.feature,\n        n = t.keys,\n        i = t.values,\n        s = t.keycache,\n        o = t.valuecache;\n\n    for (var a in r.properties) {\n      var l = s[a];\n      void 0 === l && (n.push(a), s[a] = l = n.length - 1), e.writeVarint(l);\n      var u = r.properties[a],\n          c = typeof u;\n      \"string\" !== c && \"boolean\" !== c && \"number\" !== c && (u = JSON.stringify(u));\n      var h = c + \":\" + u,\n          p = o[h];\n      void 0 === p && (i.push(u), o[h] = p = i.length - 1), e.writeVarint(p);\n    }\n  }\n\n  function Lc(t, e) {\n    return (e << 3) + (7 & t);\n  }\n\n  function Oc(t) {\n    return t << 1 ^ t >> 31;\n  }\n\n  function $c(t, e) {\n    for (var r = t.loadGeometry(), n = t.type, i = 0, s = 0, o = r.length, a = 0; a < o; a++) {\n      var l = r[a],\n          u = 1;\n      1 === n && (u = l.length), e.writeVarint(Lc(1, u));\n\n      for (var c = 3 === n ? l.length - 1 : l.length, h = 0; h < c; h++) {\n        1 === h && 1 !== n && e.writeVarint(Lc(2, c - 1));\n        var p = l[h].x - i,\n            f = l[h].y - s;\n        e.writeVarint(Oc(p)), e.writeVarint(Oc(f)), i += p, s += f;\n      }\n\n      3 === n && e.writeVarint(Lc(7, 1));\n    }\n  }\n\n  function Rc(t, e) {\n    var r = typeof t;\n    \"string\" === r ? e.writeStringField(1, t) : \"boolean\" === r ? e.writeBooleanField(7, t) : \"number\" === r && (t % 1 != 0 ? e.writeDoubleField(3, t) : t < 0 ? e.writeSVarintField(6, t) : e.writeVarintField(5, t));\n  }\n\n  function qc(t, e, r, n) {\n    Uc(t, r, n), Uc(e, 2 * r, 2 * n), Uc(e, 2 * r + 1, 2 * n + 1);\n  }\n\n  function Uc(t, e, r) {\n    const n = t[e];\n    t[e] = t[r], t[r] = n;\n  }\n\n  function Nc(t, e, r, n) {\n    const i = t - r,\n          s = e - n;\n    return i * i + s * s;\n  }\n\n  Cc.fromVectorTileJs = Tc, Cc.fromGeojsonVt = function (t, e) {\n    e = e || {};\n    var r = {};\n\n    for (var n in t) r[n] = new Mc(t[n].features, e), r[n].name = n, r[n].version = e.version, r[n].extent = e.extent;\n\n    return Tc({\n      layers: r\n    });\n  }, Cc.GeoJSONWrapper = Vc;\n\n  const jc = t => t[0],\n        Zc = t => t[1];\n\n  class Gc {\n    constructor(t, e = jc, r = Zc, n = 64, i = Float64Array) {\n      this.nodeSize = n, this.points = t;\n      const s = t.length < 65536 ? Uint16Array : Uint32Array,\n            o = this.ids = new s(t.length),\n            a = this.coords = new i(2 * t.length);\n\n      for (let n = 0; n < t.length; n++) o[n] = n, a[2 * n] = e(t[n]), a[2 * n + 1] = r(t[n]);\n\n      !function t(e, r, n, i, s, o) {\n        if (s - i <= n) return;\n        const a = i + s >> 1;\n        !function t(e, r, n, i, s, o) {\n          for (; s > i;) {\n            if (s - i > 600) {\n              const a = s - i + 1,\n                    l = n - i + 1,\n                    u = Math.log(a),\n                    c = .5 * Math.exp(2 * u / 3),\n                    h = .5 * Math.sqrt(u * c * (a - c) / a) * (l - a / 2 < 0 ? -1 : 1);\n              t(e, r, n, Math.max(i, Math.floor(n - l * c / a + h)), Math.min(s, Math.floor(n + (a - l) * c / a + h)), o);\n            }\n\n            const a = r[2 * n + o];\n            let l = i,\n                u = s;\n\n            for (qc(e, r, i, n), r[2 * s + o] > a && qc(e, r, i, s); l < u;) {\n              for (qc(e, r, l, u), l++, u--; r[2 * l + o] < a;) l++;\n\n              for (; r[2 * u + o] > a;) u--;\n            }\n\n            r[2 * i + o] === a ? qc(e, r, i, u) : (u++, qc(e, r, u, s)), u <= n && (i = u + 1), n <= u && (s = u - 1);\n          }\n        }(e, r, a, i, s, o % 2), t(e, r, n, i, a - 1, o + 1), t(e, r, n, a + 1, s, o + 1);\n      }(o, a, n, 0, o.length - 1, 0);\n    }\n\n    range(t, e, r, n) {\n      return function (t, e, r, n, i, s, o) {\n        const a = [0, t.length - 1, 0],\n              l = [];\n        let u, c;\n\n        for (; a.length;) {\n          const h = a.pop(),\n                p = a.pop(),\n                f = a.pop();\n\n          if (p - f <= o) {\n            for (let o = f; o <= p; o++) u = e[2 * o], c = e[2 * o + 1], u >= r && u <= i && c >= n && c <= s && l.push(t[o]);\n\n            continue;\n          }\n\n          const d = Math.floor((f + p) / 2);\n          u = e[2 * d], c = e[2 * d + 1], u >= r && u <= i && c >= n && c <= s && l.push(t[d]);\n          const y = (h + 1) % 2;\n          (0 === h ? r <= u : n <= c) && (a.push(f), a.push(d - 1), a.push(y)), (0 === h ? i >= u : s >= c) && (a.push(d + 1), a.push(p), a.push(y));\n        }\n\n        return l;\n      }(this.ids, this.coords, t, e, r, n, this.nodeSize);\n    }\n\n    within(t, e, r) {\n      return function (t, e, r, n, i, s) {\n        const o = [0, t.length - 1, 0],\n              a = [],\n              l = i * i;\n\n        for (; o.length;) {\n          const u = o.pop(),\n                c = o.pop(),\n                h = o.pop();\n\n          if (c - h <= s) {\n            for (let i = h; i <= c; i++) Nc(e[2 * i], e[2 * i + 1], r, n) <= l && a.push(t[i]);\n\n            continue;\n          }\n\n          const p = Math.floor((h + c) / 2),\n                f = e[2 * p],\n                d = e[2 * p + 1];\n          Nc(f, d, r, n) <= l && a.push(t[p]);\n          const y = (u + 1) % 2;\n          (0 === u ? r - i <= f : n - i <= d) && (o.push(h), o.push(p - 1), o.push(y)), (0 === u ? r + i >= f : n + i >= d) && (o.push(p + 1), o.push(c), o.push(y));\n        }\n\n        return a;\n      }(this.ids, this.coords, t, e, r, this.nodeSize);\n    }\n\n  }\n\n  const Xc = {\n    minZoom: 0,\n    maxZoom: 16,\n    minPoints: 2,\n    radius: 40,\n    extent: 512,\n    nodeSize: 64,\n    log: !1,\n    generateId: !1,\n    reduce: null,\n    map: t => t\n  },\n        Jc = Math.fround || (Yc = new Float32Array(1), t => (Yc[0] = +t, Yc[0]));\n  var Yc;\n\n  class Kc {\n    constructor(t) {\n      this.options = ih(Object.create(Xc), t), this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(t) {\n      const {\n        log: e,\n        minZoom: r,\n        maxZoom: n,\n        nodeSize: i\n      } = this.options;\n      e && console.time(\"total time\");\n      const s = `prepare ${t.length} points`;\n      e && console.time(s), this.points = t;\n      let o = [];\n\n      for (let e = 0; e < t.length; e++) t[e].geometry && o.push(Wc(t[e], e));\n\n      this.trees[n + 1] = new Gc(o, sh, oh, i, Float32Array), e && console.timeEnd(s);\n\n      for (let t = n; t >= r; t--) {\n        const r = +Date.now();\n        o = this._cluster(o, t), this.trees[t] = new Gc(o, sh, oh, i, Float32Array), e && console.log(\"z%d: %d clusters in %dms\", t, o.length, +Date.now() - r);\n      }\n\n      return e && console.timeEnd(\"total time\"), this;\n    }\n\n    getClusters(t, e) {\n      let r = ((t[0] + 180) % 360 + 360) % 360 - 180;\n      const n = Math.max(-90, Math.min(90, t[1]));\n      let i = 180 === t[2] ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;\n      const s = Math.max(-90, Math.min(90, t[3]));\n      if (t[2] - t[0] >= 360) r = -180, i = 180;else if (r > i) {\n        const t = this.getClusters([r, n, 180, s], e),\n              o = this.getClusters([-180, n, i, s], e);\n        return t.concat(o);\n      }\n\n      const o = this.trees[this._limitZoom(e)],\n            a = o.range(eh(r), rh(s), eh(i), rh(n)),\n            l = [];\n\n      for (const t of a) {\n        const e = o.points[t];\n        l.push(e.numPoints ? Qc(e) : this.points[e.index]);\n      }\n\n      return l;\n    }\n\n    getChildren(t) {\n      const e = this._getOriginId(t),\n            r = this._getOriginZoom(t),\n            n = \"No cluster with the specified id.\",\n            i = this.trees[r];\n\n      if (!i) throw new Error(n);\n      const s = i.points[e];\n      if (!s) throw new Error(n);\n      const o = this.options.radius / (this.options.extent * Math.pow(2, r - 1)),\n            a = i.within(s.x, s.y, o),\n            l = [];\n\n      for (const e of a) {\n        const r = i.points[e];\n        r.parentId === t && l.push(r.numPoints ? Qc(r) : this.points[r.index]);\n      }\n\n      if (0 === l.length) throw new Error(n);\n      return l;\n    }\n\n    getLeaves(t, e, r) {\n      const n = [];\n      return this._appendLeaves(n, t, e = e || 10, r = r || 0, 0), n;\n    }\n\n    getTile(t, e, r) {\n      const n = this.trees[this._limitZoom(t)],\n            i = Math.pow(2, t),\n            {\n        extent: s,\n        radius: o\n      } = this.options,\n            a = o / s,\n            l = (r - a) / i,\n            u = (r + 1 + a) / i,\n            c = {\n        features: []\n      };\n\n      return this._addTileFeatures(n.range((e - a) / i, l, (e + 1 + a) / i, u), n.points, e, r, i, c), 0 === e && this._addTileFeatures(n.range(1 - a / i, l, 1, u), n.points, i, r, i, c), e === i - 1 && this._addTileFeatures(n.range(0, l, a / i, u), n.points, -1, r, i, c), c.features.length ? c : null;\n    }\n\n    getClusterExpansionZoom(t) {\n      let e = this._getOriginZoom(t) - 1;\n\n      for (; e <= this.options.maxZoom;) {\n        const r = this.getChildren(t);\n        if (e++, 1 !== r.length) break;\n        t = r[0].properties.cluster_id;\n      }\n\n      return e;\n    }\n\n    _appendLeaves(t, e, r, n, i) {\n      const s = this.getChildren(e);\n\n      for (const e of s) {\n        const s = e.properties;\n        if (s && s.cluster ? i + s.point_count <= n ? i += s.point_count : i = this._appendLeaves(t, s.cluster_id, r, n, i) : i < n ? i++ : t.push(e), t.length === r) break;\n      }\n\n      return i;\n    }\n\n    _addTileFeatures(t, e, r, n, i, s) {\n      for (const o of t) {\n        const t = e[o],\n              a = t.numPoints,\n              l = {\n          type: 1,\n          geometry: [[Math.round(this.options.extent * (t.x * i - r)), Math.round(this.options.extent * (t.y * i - n))]],\n          tags: a ? th(t) : this.points[t.index].properties\n        };\n        let u;\n        a ? u = t.id : this.options.generateId ? u = t.index : this.points[t.index].id && (u = this.points[t.index].id), void 0 !== u && (l.id = u), s.features.push(l);\n      }\n    }\n\n    _limitZoom(t) {\n      return Math.max(this.options.minZoom, Math.min(+t, this.options.maxZoom + 1));\n    }\n\n    _cluster(t, e) {\n      const r = [],\n            {\n        radius: n,\n        extent: i,\n        reduce: s,\n        minPoints: o\n      } = this.options,\n            a = n / (i * Math.pow(2, e));\n\n      for (let n = 0; n < t.length; n++) {\n        const i = t[n];\n        if (i.zoom <= e) continue;\n        i.zoom = e;\n        const l = this.trees[e + 1],\n              u = l.within(i.x, i.y, a),\n              c = i.numPoints || 1;\n        let h = c;\n\n        for (const t of u) {\n          const r = l.points[t];\n          r.zoom > e && (h += r.numPoints || 1);\n        }\n\n        if (h >= o) {\n          let t = i.x * c,\n              o = i.y * c,\n              a = s && c > 1 ? this._map(i, !0) : null;\n          const p = (n << 5) + (e + 1) + this.points.length;\n\n          for (const r of u) {\n            const n = l.points[r];\n            if (n.zoom <= e) continue;\n            n.zoom = e;\n            const u = n.numPoints || 1;\n            t += n.x * u, o += n.y * u, n.parentId = p, s && (a || (a = this._map(i, !0)), s(a, this._map(n)));\n          }\n\n          i.parentId = p, r.push(Hc(t / h, o / h, p, h, a));\n        } else if (r.push(i), h > 1) for (const t of u) {\n          const n = l.points[t];\n          n.zoom <= e || (n.zoom = e, r.push(n));\n        }\n      }\n\n      return r;\n    }\n\n    _getOriginId(t) {\n      return t - this.points.length >> 5;\n    }\n\n    _getOriginZoom(t) {\n      return (t - this.points.length) % 32;\n    }\n\n    _map(t, e) {\n      if (t.numPoints) return e ? ih({}, t.properties) : t.properties;\n      const r = this.points[t.index].properties,\n            n = this.options.map(r);\n      return e && n === r ? ih({}, n) : n;\n    }\n\n  }\n\n  function Hc(t, e, r, n, i) {\n    return {\n      x: Jc(t),\n      y: Jc(e),\n      zoom: 1 / 0,\n      id: r,\n      parentId: -1,\n      numPoints: n,\n      properties: i\n    };\n  }\n\n  function Wc(t, e) {\n    const [r, n] = t.geometry.coordinates;\n    return {\n      x: Jc(eh(r)),\n      y: Jc(rh(n)),\n      zoom: 1 / 0,\n      index: e,\n      parentId: -1\n    };\n  }\n\n  function Qc(t) {\n    return {\n      type: \"Feature\",\n      id: t.id,\n      properties: th(t),\n      geometry: {\n        type: \"Point\",\n        coordinates: [(e = t.x, 360 * (e - .5)), nh(t.y)]\n      }\n    };\n    var e;\n  }\n\n  function th(t) {\n    const e = t.numPoints,\n          r = e >= 1e4 ? `${Math.round(e / 1e3)}k` : e >= 1e3 ? `${Math.round(e / 100) / 10}k` : e;\n    return ih(ih({}, t.properties), {\n      cluster: !0,\n      cluster_id: t.id,\n      point_count: e,\n      point_count_abbreviated: r\n    });\n  }\n\n  function eh(t) {\n    return t / 360 + .5;\n  }\n\n  function rh(t) {\n    const e = Math.sin(t * Math.PI / 180),\n          r = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI;\n    return r < 0 ? 0 : r > 1 ? 1 : r;\n  }\n\n  function nh(t) {\n    const e = (180 - 360 * t) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(e)) / Math.PI - 90;\n  }\n\n  function ih(t, e) {\n    for (const r in e) t[r] = e[r];\n\n    return t;\n  }\n\n  function sh(t) {\n    return t.x;\n  }\n\n  function oh(t) {\n    return t.y;\n  }\n\n  function ah(t, e, r, n, i, s) {\n    var o = i - r,\n        a = s - n;\n\n    if (0 !== o || 0 !== a) {\n      var l = ((t - r) * o + (e - n) * a) / (o * o + a * a);\n      l > 1 ? (r = i, n = s) : l > 0 && (r += o * l, n += a * l);\n    }\n\n    return (o = t - r) * o + (a = e - n) * a;\n  }\n\n  function lh(t, e, r, n) {\n    var i = {\n      id: void 0 === t ? null : t,\n      type: e,\n      geometry: r,\n      tags: n,\n      minX: 1 / 0,\n      minY: 1 / 0,\n      maxX: -1 / 0,\n      maxY: -1 / 0\n    };\n    return function (t) {\n      var e = t.geometry,\n          r = t.type;\n      if (\"Point\" === r || \"MultiPoint\" === r || \"LineString\" === r) uh(t, e);else if (\"Polygon\" === r || \"MultiLineString\" === r) for (var n = 0; n < e.length; n++) uh(t, e[n]);else if (\"MultiPolygon\" === r) for (n = 0; n < e.length; n++) for (var i = 0; i < e[n].length; i++) uh(t, e[n][i]);\n    }(i), i;\n  }\n\n  function uh(t, e) {\n    for (var r = 0; r < e.length; r += 3) t.minX = Math.min(t.minX, e[r]), t.minY = Math.min(t.minY, e[r + 1]), t.maxX = Math.max(t.maxX, e[r]), t.maxY = Math.max(t.maxY, e[r + 1]);\n  }\n\n  function ch(t, e, r, n) {\n    if (e.geometry) {\n      var i = e.geometry.coordinates,\n          s = e.geometry.type,\n          o = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2),\n          a = [],\n          l = e.id;\n      if (r.promoteId ? l = e.properties[r.promoteId] : r.generateId && (l = n || 0), \"Point\" === s) hh(i, a);else if (\"MultiPoint\" === s) for (var u = 0; u < i.length; u++) hh(i[u], a);else if (\"LineString\" === s) ph(i, a, o, !1);else if (\"MultiLineString\" === s) {\n        if (r.lineMetrics) {\n          for (u = 0; u < i.length; u++) ph(i[u], a = [], o, !1), t.push(lh(l, \"LineString\", a, e.properties));\n\n          return;\n        }\n\n        fh(i, a, o, !1);\n      } else if (\"Polygon\" === s) fh(i, a, o, !0);else {\n        if (\"MultiPolygon\" !== s) {\n          if (\"GeometryCollection\" === s) {\n            for (u = 0; u < e.geometry.geometries.length; u++) ch(t, {\n              id: l,\n              geometry: e.geometry.geometries[u],\n              properties: e.properties\n            }, r, n);\n\n            return;\n          }\n\n          throw new Error(\"Input data is not a valid GeoJSON object.\");\n        }\n\n        for (u = 0; u < i.length; u++) {\n          var c = [];\n          fh(i[u], c, o, !0), a.push(c);\n        }\n      }\n      t.push(lh(l, s, a, e.properties));\n    }\n  }\n\n  function hh(t, e) {\n    e.push(dh(t[0])), e.push(yh(t[1])), e.push(0);\n  }\n\n  function ph(t, e, r, n) {\n    for (var i, s, o = 0, a = 0; a < t.length; a++) {\n      var l = dh(t[a][0]),\n          u = yh(t[a][1]);\n      e.push(l), e.push(u), e.push(0), a > 0 && (o += n ? (i * u - l * s) / 2 : Math.sqrt(Math.pow(l - i, 2) + Math.pow(u - s, 2))), i = l, s = u;\n    }\n\n    var c = e.length - 3;\n    e[2] = 1, function t(e, r, n, i) {\n      for (var s, o = i, a = n - r >> 1, l = n - r, u = e[r], c = e[r + 1], h = e[n], p = e[n + 1], f = r + 3; f < n; f += 3) {\n        var d = ah(e[f], e[f + 1], u, c, h, p);\n        if (d > o) s = f, o = d;else if (d === o) {\n          var y = Math.abs(f - a);\n          y < l && (s = f, l = y);\n        }\n      }\n\n      o > i && (s - r > 3 && t(e, r, s, i), e[s + 2] = o, n - s > 3 && t(e, s, n, i));\n    }(e, 0, c, r), e[c + 2] = 1, e.size = Math.abs(o), e.start = 0, e.end = e.size;\n  }\n\n  function fh(t, e, r, n) {\n    for (var i = 0; i < t.length; i++) {\n      var s = [];\n      ph(t[i], s, r, n), e.push(s);\n    }\n  }\n\n  function dh(t) {\n    return t / 360 + .5;\n  }\n\n  function yh(t) {\n    var e = Math.sin(t * Math.PI / 180),\n        r = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI;\n    return r < 0 ? 0 : r > 1 ? 1 : r;\n  }\n\n  function mh(t, e, r, n, i, s, o, a) {\n    if (n /= e, s >= (r /= e) && o < n) return t;\n    if (o < r || s >= n) return null;\n\n    for (var l = [], u = 0; u < t.length; u++) {\n      var c = t[u],\n          h = c.geometry,\n          p = c.type,\n          f = 0 === i ? c.minX : c.minY,\n          d = 0 === i ? c.maxX : c.maxY;\n      if (f >= r && d < n) l.push(c);else if (!(d < r || f >= n)) {\n        var y = [];\n        if (\"Point\" === p || \"MultiPoint\" === p) gh(h, y, r, n, i);else if (\"LineString\" === p) xh(h, y, r, n, i, !1, a.lineMetrics);else if (\"MultiLineString\" === p) bh(h, y, r, n, i, !1);else if (\"Polygon\" === p) bh(h, y, r, n, i, !0);else if (\"MultiPolygon\" === p) for (var m = 0; m < h.length; m++) {\n          var g = [];\n          bh(h[m], g, r, n, i, !0), g.length && y.push(g);\n        }\n\n        if (y.length) {\n          if (a.lineMetrics && \"LineString\" === p) {\n            for (m = 0; m < y.length; m++) l.push(lh(c.id, p, y[m], c.tags));\n\n            continue;\n          }\n\n          \"LineString\" !== p && \"MultiLineString\" !== p || (1 === y.length ? (p = \"LineString\", y = y[0]) : p = \"MultiLineString\"), \"Point\" !== p && \"MultiPoint\" !== p || (p = 3 === y.length ? \"Point\" : \"MultiPoint\"), l.push(lh(c.id, p, y, c.tags));\n        }\n      }\n    }\n\n    return l.length ? l : null;\n  }\n\n  function gh(t, e, r, n, i) {\n    for (var s = 0; s < t.length; s += 3) {\n      var o = t[s + i];\n      o >= r && o <= n && (e.push(t[s]), e.push(t[s + 1]), e.push(t[s + 2]));\n    }\n  }\n\n  function xh(t, e, r, n, i, s, o) {\n    for (var a, l, u = vh(t), c = 0 === i ? _h : kh, h = t.start, p = 0; p < t.length - 3; p += 3) {\n      var f = t[p],\n          d = t[p + 1],\n          y = t[p + 2],\n          m = t[p + 3],\n          g = t[p + 4],\n          x = 0 === i ? f : d,\n          v = 0 === i ? m : g,\n          b = !1;\n      o && (a = Math.sqrt(Math.pow(f - m, 2) + Math.pow(d - g, 2))), x < r ? v > r && (l = c(u, f, d, m, g, r), o && (u.start = h + a * l)) : x > n ? v < n && (l = c(u, f, d, m, g, n), o && (u.start = h + a * l)) : wh(u, f, d, y), v < r && x >= r && (l = c(u, f, d, m, g, r), b = !0), v > n && x <= n && (l = c(u, f, d, m, g, n), b = !0), !s && b && (o && (u.end = h + a * l), e.push(u), u = vh(t)), o && (h += a);\n    }\n\n    var w = t.length - 3;\n    f = t[w], d = t[w + 1], y = t[w + 2], (x = 0 === i ? f : d) >= r && x <= n && wh(u, f, d, y), w = u.length - 3, s && w >= 3 && (u[w] !== u[0] || u[w + 1] !== u[1]) && wh(u, u[0], u[1], u[2]), u.length && e.push(u);\n  }\n\n  function vh(t) {\n    var e = [];\n    return e.size = t.size, e.start = t.start, e.end = t.end, e;\n  }\n\n  function bh(t, e, r, n, i, s) {\n    for (var o = 0; o < t.length; o++) xh(t[o], e, r, n, i, s, !1);\n  }\n\n  function wh(t, e, r, n) {\n    t.push(e), t.push(r), t.push(n);\n  }\n\n  function _h(t, e, r, n, i, s) {\n    var o = (s - e) / (n - e);\n    return t.push(s), t.push(r + (i - r) * o), t.push(1), o;\n  }\n\n  function kh(t, e, r, n, i, s) {\n    var o = (s - r) / (i - r);\n    return t.push(e + (n - e) * o), t.push(s), t.push(1), o;\n  }\n\n  function Sh(t, e) {\n    for (var r = [], n = 0; n < t.length; n++) {\n      var i,\n          s = t[n],\n          o = s.type;\n      if (\"Point\" === o || \"MultiPoint\" === o || \"LineString\" === o) i = Ah(s.geometry, e);else if (\"MultiLineString\" === o || \"Polygon\" === o) {\n        i = [];\n\n        for (var a = 0; a < s.geometry.length; a++) i.push(Ah(s.geometry[a], e));\n      } else if (\"MultiPolygon\" === o) for (i = [], a = 0; a < s.geometry.length; a++) {\n        for (var l = [], u = 0; u < s.geometry[a].length; u++) l.push(Ah(s.geometry[a][u], e));\n\n        i.push(l);\n      }\n      r.push(lh(s.id, o, i, s.tags));\n    }\n\n    return r;\n  }\n\n  function Ah(t, e) {\n    var r = [];\n    r.size = t.size, void 0 !== t.start && (r.start = t.start, r.end = t.end);\n\n    for (var n = 0; n < t.length; n += 3) r.push(t[n] + e, t[n + 1], t[n + 2]);\n\n    return r;\n  }\n\n  function Ih(t, e) {\n    if (t.transformed) return t;\n    var r,\n        n,\n        i,\n        s = 1 << t.z,\n        o = t.x,\n        a = t.y;\n\n    for (r = 0; r < t.features.length; r++) {\n      var l = t.features[r],\n          u = l.geometry,\n          c = l.type;\n      if (l.geometry = [], 1 === c) for (n = 0; n < u.length; n += 2) l.geometry.push(zh(u[n], u[n + 1], e, s, o, a));else for (n = 0; n < u.length; n++) {\n        var h = [];\n\n        for (i = 0; i < u[n].length; i += 2) h.push(zh(u[n][i], u[n][i + 1], e, s, o, a));\n\n        l.geometry.push(h);\n      }\n    }\n\n    return t.transformed = !0, t;\n  }\n\n  function zh(t, e, r, n, i, s) {\n    return [Math.round(r * (t * n - i)), Math.round(r * (e * n - s))];\n  }\n\n  function Mh(t, e, r, n, i) {\n    for (var s = e === i.maxZoom ? 0 : i.tolerance / ((1 << e) * i.extent), o = {\n      features: [],\n      numPoints: 0,\n      numSimplified: 0,\n      numFeatures: 0,\n      source: null,\n      x: r,\n      y: n,\n      z: e,\n      transformed: !1,\n      minX: 2,\n      minY: 1,\n      maxX: -1,\n      maxY: 0\n    }, a = 0; a < t.length; a++) {\n      o.numFeatures++, Bh(o, t[a], s, i);\n      var l = t[a].minX,\n          u = t[a].minY,\n          c = t[a].maxX,\n          h = t[a].maxY;\n      l < o.minX && (o.minX = l), u < o.minY && (o.minY = u), c > o.maxX && (o.maxX = c), h > o.maxY && (o.maxY = h);\n    }\n\n    return o;\n  }\n\n  function Bh(t, e, r, n) {\n    var i = e.geometry,\n        s = e.type,\n        o = [];\n    if (\"Point\" === s || \"MultiPoint\" === s) for (var a = 0; a < i.length; a += 3) o.push(i[a]), o.push(i[a + 1]), t.numPoints++, t.numSimplified++;else if (\"LineString\" === s) Ph(o, i, t, r, !1, !1);else if (\"MultiLineString\" === s || \"Polygon\" === s) for (a = 0; a < i.length; a++) Ph(o, i[a], t, r, \"Polygon\" === s, 0 === a);else if (\"MultiPolygon\" === s) for (var l = 0; l < i.length; l++) {\n      var u = i[l];\n\n      for (a = 0; a < u.length; a++) Ph(o, u[a], t, r, !0, 0 === a);\n    }\n\n    if (o.length) {\n      var c = e.tags || null;\n\n      if (\"LineString\" === s && n.lineMetrics) {\n        for (var h in c = {}, e.tags) c[h] = e.tags[h];\n\n        c.mapbox_clip_start = i.start / i.size, c.mapbox_clip_end = i.end / i.size;\n      }\n\n      var p = {\n        geometry: o,\n        type: \"Polygon\" === s || \"MultiPolygon\" === s ? 3 : \"LineString\" === s || \"MultiLineString\" === s ? 2 : 1,\n        tags: c\n      };\n      null !== e.id && (p.id = e.id), t.features.push(p);\n    }\n  }\n\n  function Ph(t, e, r, n, i, s) {\n    var o = n * n;\n    if (n > 0 && e.size < (i ? o : n)) r.numPoints += e.length / 3;else {\n      for (var a = [], l = 0; l < e.length; l += 3) (0 === n || e[l + 2] > o) && (r.numSimplified++, a.push(e[l]), a.push(e[l + 1])), r.numPoints++;\n\n      i && function (t, e) {\n        for (var r = 0, n = 0, i = t.length, s = i - 2; n < i; s = n, n += 2) r += (t[n] - t[s]) * (t[n + 1] + t[s + 1]);\n\n        if (r > 0 === e) for (n = 0, i = t.length; n < i / 2; n += 2) {\n          var o = t[n],\n              a = t[n + 1];\n          t[n] = t[i - 2 - n], t[n + 1] = t[i - 1 - n], t[i - 2 - n] = o, t[i - 1 - n] = a;\n        }\n      }(a, s), t.push(a);\n    }\n  }\n\n  function Ch(t, e) {\n    var r = (e = this.options = function (t, e) {\n      for (var r in e) t[r] = e[r];\n\n      return t;\n    }(Object.create(this.options), e)).debug;\n\n    if (r && console.time(\"preprocess data\"), e.maxZoom < 0 || e.maxZoom > 24) throw new Error(\"maxZoom should be in the 0-24 range\");\n    if (e.promoteId && e.generateId) throw new Error(\"promoteId and generateId cannot be used together.\");\n\n    var n = function (t, e) {\n      var r = [];\n      if (\"FeatureCollection\" === t.type) for (var n = 0; n < t.features.length; n++) ch(r, t.features[n], e, n);else ch(r, \"Feature\" === t.type ? t : {\n        geometry: t\n      }, e);\n      return r;\n    }(t, e);\n\n    this.tiles = {}, this.tileCoords = [], r && (console.timeEnd(\"preprocess data\"), console.log(\"index: maxZoom: %d, maxPoints: %d\", e.indexMaxZoom, e.indexMaxPoints), console.time(\"generate tiles\"), this.stats = {}, this.total = 0), (n = function (t, e) {\n      var r = e.buffer / e.extent,\n          n = t,\n          i = mh(t, 1, -1 - r, r, 0, -1, 2, e),\n          s = mh(t, 1, 1 - r, 2 + r, 0, -1, 2, e);\n      return (i || s) && (n = mh(t, 1, -r, 1 + r, 0, -1, 2, e) || [], i && (n = Sh(i, 1).concat(n)), s && (n = n.concat(Sh(s, -1)))), n;\n    }(n, e)).length && this.splitTile(n, 0, 0, 0), r && (n.length && console.log(\"features: %d, points: %d\", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd(\"generate tiles\"), console.log(\"tiles generated:\", this.total, JSON.stringify(this.stats)));\n  }\n\n  function Vh(t, e, r) {\n    return 32 * ((1 << t) * r + e) + t;\n  }\n\n  function Th(t, e) {\n    const r = t.tileID.canonical;\n    if (!this._geoJSONIndex) return e(null, null);\n\n    const n = this._geoJSONIndex.getTile(r.z, r.x, r.y);\n\n    if (!n) return e(null, null);\n    const i = new Ic(n.features);\n    let s = Cc(i);\n    0 === s.byteOffset && s.byteLength === s.buffer.byteLength || (s = new Uint8Array(s)), e(null, {\n      vectorTile: i,\n      rawData: s.buffer\n    });\n  }\n\n  Ch.prototype.options = {\n    maxZoom: 14,\n    indexMaxZoom: 5,\n    indexMaxPoints: 1e5,\n    tolerance: 3,\n    extent: 4096,\n    buffer: 64,\n    lineMetrics: !1,\n    promoteId: null,\n    generateId: !1,\n    debug: 0\n  }, Ch.prototype.splitTile = function (t, e, r, n, i, s, o) {\n    for (var a = [t, e, r, n], l = this.options, u = l.debug; a.length;) {\n      n = a.pop(), r = a.pop(), e = a.pop(), t = a.pop();\n      var c = 1 << e,\n          h = Vh(e, r, n),\n          p = this.tiles[h];\n\n      if (!p && (u > 1 && console.time(\"creation\"), p = this.tiles[h] = Mh(t, e, r, n, l), this.tileCoords.push({\n        z: e,\n        x: r,\n        y: n\n      }), u)) {\n        u > 1 && (console.log(\"tile z%d-%d-%d (features: %d, points: %d, simplified: %d)\", e, r, n, p.numFeatures, p.numPoints, p.numSimplified), console.timeEnd(\"creation\"));\n        var f = \"z\" + e;\n        this.stats[f] = (this.stats[f] || 0) + 1, this.total++;\n      }\n\n      if (p.source = t, i) {\n        if (e === l.maxZoom || e === i) continue;\n        var d = 1 << i - e;\n        if (r !== Math.floor(s / d) || n !== Math.floor(o / d)) continue;\n      } else if (e === l.indexMaxZoom || p.numPoints <= l.indexMaxPoints) continue;\n\n      if (p.source = null, 0 !== t.length) {\n        u > 1 && console.time(\"clipping\");\n\n        var y,\n            m,\n            g,\n            x,\n            v,\n            b,\n            w = .5 * l.buffer / l.extent,\n            _ = .5 - w,\n            k = .5 + w,\n            S = 1 + w;\n\n        y = m = g = x = null, v = mh(t, c, r - w, r + k, 0, p.minX, p.maxX, l), b = mh(t, c, r + _, r + S, 0, p.minX, p.maxX, l), t = null, v && (y = mh(v, c, n - w, n + k, 1, p.minY, p.maxY, l), m = mh(v, c, n + _, n + S, 1, p.minY, p.maxY, l), v = null), b && (g = mh(b, c, n - w, n + k, 1, p.minY, p.maxY, l), x = mh(b, c, n + _, n + S, 1, p.minY, p.maxY, l), b = null), u > 1 && console.timeEnd(\"clipping\"), a.push(y || [], e + 1, 2 * r, 2 * n), a.push(m || [], e + 1, 2 * r, 2 * n + 1), a.push(g || [], e + 1, 2 * r + 1, 2 * n), a.push(x || [], e + 1, 2 * r + 1, 2 * n + 1);\n      }\n    }\n  }, Ch.prototype.getTile = function (t, e, r) {\n    var n = this.options,\n        i = n.extent,\n        s = n.debug;\n    if (t < 0 || t > 24) return null;\n    var o = 1 << t,\n        a = Vh(t, e = (e % o + o) % o, r);\n    if (this.tiles[a]) return Ih(this.tiles[a], i);\n    s > 1 && console.log(\"drilling down to z%d-%d-%d\", t, e, r);\n\n    for (var l, u = t, c = e, h = r; !l && u > 0;) u--, c = Math.floor(c / 2), h = Math.floor(h / 2), l = this.tiles[Vh(u, c, h)];\n\n    return l && l.source ? (s > 1 && console.log(\"found parent tile z%d-%d-%d\", u, c, h), s > 1 && console.time(\"drilling down\"), this.splitTile(l.source, u, c, h, t, e, r), s > 1 && console.timeEnd(\"drilling down\"), this.tiles[a] ? Ih(this.tiles[a], i) : null) : null;\n  };\n\n  class Eh extends vc {\n    constructor(t, e, r, n, i) {\n      super(t, e, r, n, Th), i && (this.loadGeoJSON = i);\n    }\n\n    loadData(t, e) {\n      this._pendingCallback && this._pendingCallback(null, {\n        abandoned: !0\n      }), this._pendingCallback = e, this._pendingLoadDataParams = t, this._state && \"Idle\" !== this._state ? this._state = \"NeedsLoadData\" : (this._state = \"Coalescing\", this._loadData());\n    }\n\n    _loadData() {\n      if (!this._pendingCallback || !this._pendingLoadDataParams) return;\n      const t = this._pendingCallback,\n            e = this._pendingLoadDataParams;\n      delete this._pendingCallback, delete this._pendingLoadDataParams;\n      const r = !!(e && e.request && e.request.collectResourceTiming) && new er(e.request);\n      this.loadGeoJSON(e, (n, i) => {\n        if (n || !i) return t(n);\n        if (\"object\" != typeof i) return t(new Error(`Input data given to '${e.source}' is not a valid GeoJSON object.`));\n        {\n          !function t(e, r) {\n            var n,\n                i = e && e.type;\n            if (\"FeatureCollection\" === i) for (n = 0; n < e.features.length; n++) t(e.features[n], r);else if (\"GeometryCollection\" === i) for (n = 0; n < e.geometries.length; n++) t(e.geometries[n], r);else if (\"Feature\" === i) t(e.geometry, r);else if (\"Polygon\" === i) _c(e.coordinates, r);else if (\"MultiPolygon\" === i) for (n = 0; n < e.coordinates.length; n++) _c(e.coordinates[n], r);\n            return e;\n          }(i, !0);\n\n          try {\n            if (e.filter) {\n              const t = Re(e.filter, {\n                type: \"boolean\",\n                \"property-type\": \"data-driven\",\n                overridable: !1,\n                transition: !1\n              });\n              if (\"error\" === t.result) throw new Error(t.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n              const r = i.features.filter(e => t.value.evaluate({\n                zoom: 0\n              }, e));\n              i = {\n                type: \"FeatureCollection\",\n                features: r\n              };\n            }\n\n            this._geoJSONIndex = e.cluster ? new Kc(function ({\n              superclusterOptions: t,\n              clusterProperties: e\n            }) {\n              if (!e || !t) return t;\n              const r = {},\n                    n = {},\n                    i = {\n                accumulated: null,\n                zoom: 0\n              },\n                    s = {\n                properties: null\n              },\n                    o = Object.keys(e);\n\n              for (const t of o) {\n                const [i, s] = e[t],\n                      o = Re(s),\n                      a = Re(\"string\" == typeof i ? [i, [\"accumulated\"], [\"get\", t]] : i);\n                r[t] = o.value, n[t] = a.value;\n              }\n\n              return t.map = t => {\n                s.properties = t;\n                const e = {};\n\n                for (const t of o) e[t] = r[t].evaluate(i, s);\n\n                return e;\n              }, t.reduce = (t, e) => {\n                s.properties = e;\n\n                for (const e of o) i.accumulated = t[e], t[e] = n[e].evaluate(i, s);\n              }, t;\n            }(e)).load(i.features) : function (t, e) {\n              return new Ch(t, e);\n            }(i, e.geojsonVtOptions);\n          } catch (n) {\n            return t(n);\n          }\n\n          this.loaded = {};\n          const s = {};\n\n          if (r) {\n            const t = r.finish();\n            t && (s.resourceTiming = {}, s.resourceTiming[e.source] = JSON.parse(JSON.stringify(t)));\n          }\n\n          t(null, s);\n        }\n      });\n    }\n\n    coalesce() {\n      \"Coalescing\" === this._state ? this._state = \"Idle\" : \"NeedsLoadData\" === this._state && (this._state = \"Coalescing\", this._loadData());\n    }\n\n    reloadTile(t, e) {\n      const r = this.loaded;\n      return r && r[t.uid] ? super.reloadTile(t, e) : this.loadTile(t, e);\n    }\n\n    loadGeoJSON(t, e) {\n      if (t.request) !function (t, e) {\n        ti(c(t, {\n          type: \"json\"\n        }), e);\n      }(t.request, e);else {\n        if (\"string\" != typeof t.data) return e(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n\n        try {\n          return e(null, JSON.parse(t.data));\n        } catch (r) {\n          return e(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n        }\n      }\n    }\n\n    removeSource(t, e) {\n      this._pendingCallback && this._pendingCallback(null, {\n        abandoned: !0\n      }), e();\n    }\n\n    getClusterExpansionZoom(t, e) {\n      try {\n        e(null, this._geoJSONIndex.getClusterExpansionZoom(t.clusterId));\n      } catch (t) {\n        e(t);\n      }\n    }\n\n    getClusterChildren(t, e) {\n      try {\n        e(null, this._geoJSONIndex.getChildren(t.clusterId));\n      } catch (t) {\n        e(t);\n      }\n    }\n\n    getClusterLeaves(t, e) {\n      try {\n        e(null, this._geoJSONIndex.getLeaves(t.clusterId, t.limit, t.offset));\n      } catch (t) {\n        e(t);\n      }\n    }\n\n  }\n\n  class Dh {\n    constructor(t) {\n      this.self = t, this.actor = new ir(t, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = !1, this.workerSourceTypes = {\n        vector: vc,\n        geojson: Eh\n      }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (t, e) => {\n        if (this.workerSourceTypes[t]) throw new Error(`Worker source with name \"${t}\" already registered.`);\n        this.workerSourceTypes[t] = e;\n      }, this.self.registerRTLTextPlugin = t => {\n        if (si.isParsed()) throw new Error(\"RTL text plugin already registered.\");\n        si.applyArabicShaping = t.applyArabicShaping, si.processBidirectionalText = t.processBidirectionalText, si.processStyledBidirectionalText = t.processStyledBidirectionalText;\n      };\n    }\n\n    checkIfReady(t, e, r) {\n      r();\n    }\n\n    setReferrer(t, e) {\n      this.referrer = e;\n    }\n\n    spriteLoaded(t, e) {\n      this.isSpriteLoaded = e;\n\n      for (const r in this.workerSources[t]) {\n        const n = this.workerSources[t][r];\n\n        for (const t in n) n[t] instanceof vc && (n[t].isSpriteLoaded = e, n[t].fire(new Nr(\"isSpriteLoaded\")));\n      }\n    }\n\n    setImages(t, e, r) {\n      this.availableImages[t] = e;\n\n      for (const r in this.workerSources[t]) {\n        const n = this.workerSources[t][r];\n\n        for (const t in n) n[t].availableImages = e;\n      }\n\n      r();\n    }\n\n    enableTerrain(t, e, r) {\n      this.terrain = e, r();\n    }\n\n    setLayers(t, e, r) {\n      this.getLayerIndex(t).replace(e), r();\n    }\n\n    updateLayers(t, e, r) {\n      this.getLayerIndex(t).update(e.layers, e.removedIds), r();\n    }\n\n    loadTile(t, e, r) {\n      const n = this.enableTerrain ? c({\n        enableTerrain: this.terrain\n      }, e) : e;\n      this.getWorkerSource(t, e.type, e.source).loadTile(n, r);\n    }\n\n    loadDEMTile(t, e, r) {\n      const n = this.enableTerrain ? c({\n        buildQuadTree: this.terrain\n      }, e) : e;\n      this.getDEMWorkerSource(t, e.source).loadTile(n, r);\n    }\n\n    reloadTile(t, e, r) {\n      const n = this.enableTerrain ? c({\n        enableTerrain: this.terrain\n      }, e) : e;\n      this.getWorkerSource(t, e.type, e.source).reloadTile(n, r);\n    }\n\n    abortTile(t, e, r) {\n      this.getWorkerSource(t, e.type, e.source).abortTile(e, r);\n    }\n\n    removeTile(t, e, r) {\n      this.getWorkerSource(t, e.type, e.source).removeTile(e, r);\n    }\n\n    removeSource(t, e, r) {\n      if (!this.workerSources[t] || !this.workerSources[t][e.type] || !this.workerSources[t][e.type][e.source]) return;\n      const n = this.workerSources[t][e.type][e.source];\n      delete this.workerSources[t][e.type][e.source], void 0 !== n.removeSource ? n.removeSource(e, r) : r();\n    }\n\n    loadWorkerSource(t, e, r) {\n      try {\n        this.self.importScripts(e.url), r();\n      } catch (t) {\n        r(t.toString());\n      }\n    }\n\n    syncRTLPluginState(t, e, r) {\n      try {\n        si.setState(e);\n        const t = si.getPluginURL();\n\n        if (si.isLoaded() && !si.isParsed() && null != t) {\n          this.self.importScripts(t);\n          const e = si.isParsed();\n          r(e ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t}`), e);\n        }\n      } catch (t) {\n        r(t.toString());\n      }\n    }\n\n    getAvailableImages(t) {\n      let e = this.availableImages[t];\n      return e || (e = []), e;\n    }\n\n    getLayerIndex(t) {\n      let e = this.layerIndexes[t];\n      return e || (e = this.layerIndexes[t] = new Ou()), e;\n    }\n\n    getWorkerSource(t, e, r) {\n      return this.workerSources[t] || (this.workerSources[t] = {}), this.workerSources[t][e] || (this.workerSources[t][e] = {}), this.workerSources[t][e][r] || (this.workerSources[t][e][r] = new this.workerSourceTypes[e]({\n        send: (e, r, n, i, s, o) => {\n          this.actor.send(e, r, n, t, i, o);\n        },\n        scheduler: this.actor.scheduler\n      }, this.getLayerIndex(t), this.getAvailableImages(t), this.isSpriteLoaded)), this.workerSources[t][e][r];\n    }\n\n    getDEMWorkerSource(t, e) {\n      return this.demWorkerSources[t] || (this.demWorkerSources[t] = {}), this.demWorkerSources[t][e] || (this.demWorkerSources[t][e] = new wc()), this.demWorkerSources[t][e];\n    }\n\n    enforceCacheSizeLimit(t, e) {\n      !function (t) {\n        Kn(), Jn && Jn.then(e => {\n          e.keys().then(r => {\n            for (let n = 0; n < r.length - t; n++) e.delete(r[n]);\n          });\n        });\n      }(e);\n    }\n\n    getWorkerPerformanceMetrics(t, e, r) {\n      r(void 0, void 0);\n    }\n\n  }\n\n  return \"undefined\" != typeof WorkerGlobalScope && \"undefined\" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Dh(self)), Dh;\n}();\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mapbox-gl/dist/mapbox-gl-csp-worker.js?./node_modules/babel-loader/lib");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ })

/******/ });